{"componentChunkName":"component---src-templates-posts-js","path":"/","result":{"data":{"allContentfulPost":{"edges":[{"node":{"title":"Airflow on Kubernetes (2)","id":"5fc58fbf-a43f-5cc7-b43f-3f43770235d5","slug":"airflow-on-kubernetes-2","publishDate":"July 12, 2020","heroImage":{"id":"dab22ea8-d54d-52a6-852a-278ba3b19a2b","title":"cover-dataengineering","fluid":{"aspectRatio":1.499531396438613,"src":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50 1600w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"166621a6-ce3b-537e-9ac0-f3c2b00413ff","childMarkdownRemark":{"id":"39523c20-8b80-5c48-889e-f9a249db1438","timeToRead":5,"html":"<p>최근 Airflow에는 Kubernetes 지원을 위해 다양한 컴포넌트들이 추가되고 있습니다. 이러한 변화의 흐름에 따라 Airflow를 Kubernetes 위에 배포하고 운영하는 방법에 대해 글을 작성해보고자 합니다. 이 글은 시리즈로 연재됩니다.</p>\n<ul>\n<li><a href=\"https://swalloow.github.io/airflow-on-kubernetes-1\">Airflow on Kubernetes (1): CeleryExecutor</a></li>\n<li><a href=\"https://swalloow.github.io/airflow-on-kubernetes-2\">Airflow on Kubernetes (2): KubernetesExecutor</a></li>\n<li>Airflow on Kubernetes (3): Prometheus를 활용한 Airflow 모니터링</li>\n</ul>\n<br>\n<h2 id=\"airflow-on-kubernetes\" style=\"position:relative;\"><a href=\"#airflow-on-kubernetes\" aria-label=\"airflow on kubernetes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Airflow on Kubernetes</h2>\n<p>지난 글에서는 <a href=\"https://github.com/helm/charts/tree/master/stable/airflow\">stable/airflow</a> helm chart를 이용하여 CeleryExecutor의 각 모듈을 Kubernetes 위에 올리는 방식에 대해 설명하였습니다. 이번 글에서는 많이 사용하는 Airflow Helm Chart에 대해 알아보고 최근에 추가된 <strong>Official Airflow Helm Chart</strong>를 이용하여 KubernetesExecutor를 배포했을 때 어떤 아키텍쳐를 가지는지에 대해 설명드리려 합니다. 먼저 많이 사용하는 차트는 아래와 같이 3가지가 있습니다.</p>\n<br>\n<p><strong>1. stable/airflow</strong>:\n다양한 옵션을 지원하고 많이 사용하지만 커뮤니티 버전입니다.\n공식 릴리즈 이후에 개발이 중단될 예정입니다.</p>\n<p><strong>2. astronomer/airflow-chart</strong>:\nAirflow as a Service를 개발하는 astronomer에서 공개한 차트입니다.\nairflow 2.0의 공식 차트로 활용될 예정입니다. (merge된 상태)</p>\n<p><strong>3. apache/airflow-on-k8s-operator</strong>:\nKubernetes Operator를 활용한 방식으로 위와 다른 구성을 가지고 있습니다.\n구글에서 apache에 기증했으며 GCP의 Composer에서 활용되고 있다고 알려져 있습니다.</p>\n<br>\n<p>이외에도 최근에 공식 차트가 <a href=\"https://github.com/apache/airflow/pull/8777\">PR-8777</a>을 통해 merge 되었습니다.\n아직 정식 릴리즈는 아니지만 큰 이슈는 없는 것으로 보여 공식 차트 기준으로 설명하겠습니다.</p>\n<br>\n<h2 id=\"airflow-executor-on-kubernetes\" style=\"position:relative;\"><a href=\"#airflow-executor-on-kubernetes\" aria-label=\"airflow executor on kubernetes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Airflow Executor on Kubernetes</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1Zi0Ql_Gfn9kQvz3i0P2Xgsh62n63TDYk\" alt=\"task_lifecycle\"></p>\n<p>먼저 공식 차트 기준으로 executor마다 컴포넌트가 어떤 형태로 올라가는지 알아보겠습니다.\n컴포넌트는 크게 아래와 같이 구분하고 있으며 위의 그림과 같은 라이프사이클에 따라 동작합니다.</p>\n<ul>\n<li><strong>webserver</strong>: Airflow UI, RBAC, DAG monitoring</li>\n<li><strong>scheduler</strong>: task monitoring, trigger, DAG sync, DAG processing</li>\n<li><strong>executor</strong>: how task instance running (pluggable)</li>\n<li><strong>worker</strong>: task instance processing</li>\n</ul>\n<br>\n<h2 id=\"localexecutor\" style=\"position:relative;\"><a href=\"#localexecutor\" aria-label=\"localexecutor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LocalExecutor</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1U7o-jJvDijVh842ueaZwG2joq4cdJZpc\" alt=\"localexecutor\"></p>\n<p>LocalExecutor는 Scheduler에서 각 task가 subprocess 형태로 돌아가는 구조입니다. Scale-Out이 어렵기 때문에 간단한 테스트 용도로 사용하는 경우가 많습니다.</p>\n<br>\n<h2 id=\"celeryexecutor--dag-pv\" style=\"position:relative;\"><a href=\"#celeryexecutor--dag-pv\" aria-label=\"celeryexecutor  dag pv permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CeleryExecutor + DAG PV</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1Yitccb8iF2rDnzC22wp5lWyxLowiRQhV\" alt=\"celeryexecutor3\"></p>\n<p>CeleryExecutor는 Scheduler가 task queue에 작업을 전달하고 worker에서 작업이 수행되는 구조입니다. 지난 번 글에서 언급했듯이 여러 노드에 걸쳐 있는 DAG 파일을 동기화하기 위해 <strong>PV, git-sync</strong> 2가지 옵션을 지원합니다. 이 옵션은 KubernetesExecutor에서도 지원합니다.</p>\n<br>\n<p>위의 그림에서는 AWS EFS를 기준으로 표현했지만 NFS를 지원하는 스토리지에서 모두 활용 가능합니다. 이 방식은 스토리지를 별도로 두기 때문에 git과 다르게 배포 주기를 가져갈 수 있습니다.\n그리고 worker pod이 <strong>statefulset</strong> 형태로 변경되었습니다. 이를 통해 각 worker에 PV를 연결하고 airflow UI에서 각 task의 로그를 볼 수 있습니다.</p>\n<br>\n<h2 id=\"celeryexecutor--dag-git-sync\" style=\"position:relative;\"><a href=\"#celeryexecutor--dag-git-sync\" aria-label=\"celeryexecutor  dag git sync permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CeleryExecutor + DAG git-sync</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1VodhbkJMzMbMWKookXTiGr8rPChS8Uwe\" alt=\"celeryexecutor4\"></p>\n<p>git-sync 옵션을 사용한다면 위와 같은 그림으로 구성됩니다.\nairflow의 각 컴포넌트에 git-sync 컨테이너가 sidecar 형태로 추가됩니다.\n이 방식은 <strong>DAG 전용 git repository가 있다면 자동으로 배포를 구성할 수 있다</strong>는 장점이 있습니다. 처음 차트를 배포할때 init container 단계에서 git clone을 수행하고 이후부터는 git-sync 사이드카 컨테이너를 통해 주기적으로 pull을 수행하게 됩니다.</p>\n<br>\n<h2 id=\"celeryexecutor--keda-autoscaler\" style=\"position:relative;\"><a href=\"#celeryexecutor--keda-autoscaler\" aria-label=\"celeryexecutor  keda autoscaler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CeleryExecutor + KEDA AutoScaler</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1gT38whMNgcmMLDhegS7TKjVXRO2bm38o\" alt=\"keda\"></p>\n<br>\n<p><strong>KEDA AutoScaler</strong>는 공식 차트에만 추가된 옵션입니다.\n기존의 Horizontal Pod Autoscaler는 리소스(CPU, Memory) 메트릭을 기반으로 스케일 여부를 결정하게 됩니다. 반면에 KEDA는 <strong>특정 이벤트를 기반으로 스케일 여부를 결정</strong>할 수 있습니다. 예를 들어 airflow는 metadb를 통해 현재 실행 중이거나 대기 중인 task가 얼마나 존재하는지 알 수 있습니다. 이러한 이벤트를 활용하여 worker의 scale을 결정한다면 queue에 task가 많이 추가되는 시점에 더 빠르게 확장할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> ceil<span class=\"token punctuation\">(</span><span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>::<span class=\"token keyword\">decimal</span> <span class=\"token operator\">/</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">FROM</span> task_instance\n<span class=\"token keyword\">WHERE</span> state<span class=\"token operator\">=</span><span class=\"token string\">'running'</span> <span class=\"token operator\">OR</span> state<span class=\"token operator\">=</span><span class=\"token string\">'queued'</span></code></pre></div>\n<p>이를 위해 airflow에서는 KEDA의 <strong>PostgreSQL trigger</strong>를 활용하였고 실제 위와 같은 쿼리가 등록되어 있습니다. KEDA는 CRD와 custom controller로 구성되어 있기 때문에 기존 HPA와 함께 사용 가능하며 모든 K8S 클러스터에 추가할 수 있습니다.</p>\n<br>\n<h2 id=\"celeryexecutor-vs-kubernetesexecutor\" style=\"position:relative;\"><a href=\"#celeryexecutor-vs-kubernetesexecutor\" aria-label=\"celeryexecutor vs kubernetesexecutor permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CeleryExecutor vs KubernetesExecutor</h2>\n<p>여기까지 CeleryExecutor에 대해 알아보았습니다. CeleryExecutor 또한 Kubernetes 위에 배포하면 Helm 차트를 통한 선언형 리소스 관리, 쉬운 버전 업데이트, DAG 배포 자동화, 쉬운 리소스 확장 등의 장점을 가질 수 있습니다. 하지만 Celery에 대한 의존성이 남아있기 때문에 Redis, Celery Worker에 대한 리소스를 계속 점유하고 있어야 합니다. 다시 말해서, <strong>Scale to Zero</strong>가 어렵다는 단점이 있습니다. KubernetesExecutor는 task가 존재할때만 pod이 생성되고 task가 완료되면 종료되기 때문에 더 리소스를 효율적으로 사용한다고 볼 수 있습니다.</p>\n<br>\n<h2 id=\"kubernetesexecutor-kubernetespodoperator\" style=\"position:relative;\"><a href=\"#kubernetesexecutor-kubernetespodoperator\" aria-label=\"kubernetesexecutor kubernetespodoperator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>KubernetesExecutor, KubernetesPodOperator</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1dSfx9OxnCYpw7g0gMmOtnF7mNDb_k5Cg\" alt=\"kubernetesexecutor\"></p>\n<br>\n<p>위의 그림처럼 KubernetesExecutor는 Broker와 같은 리소스를 점유하고 있을 필요가 없습니다. 리소스를 할당하고 스케줄링 하는 역할은 Kubernetes Scheduler가 수행하게 됩니다. Airflow Scheduler는 API Server에게 task 수행을 위한 Pod 생성을 요청합니다. worker는 <code class=\"language-text\">images.airflow</code>에 설정한 이미지로 Pod이 생성되기 때문에 추가로 필요한 파이썬 패키지가 존재한다면 별도의 이미지를 만들어주어야 합니다. 만일 task pod 마다 다른 이미지와 리소스 설정을 가지도록 하고 싶다면 <strong>KubernetesPodOperator</strong>를 사용하시면 됩니다. KubernetesPodOperator는 worker를 통해 pod이 생성되는 구조이므로 파라메터를 통해 사용자가 원하는 설정으로 변경할 수 있습니다.</p>\n<br>\n<h2 id=\"kubernetesexecutor-process\" style=\"position:relative;\"><a href=\"#kubernetesexecutor-process\" aria-label=\"kubernetesexecutor process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>KubernetesExecutor Process</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1mviHViGJS1tTQtl4JrgUFR9IdaersPoY\" alt=\"kubeexecutor2\"></p>\n<br>\n<p>KubernetesExecutor는 위와 같은 프로세스를 통해 동작합니다. 일반적으로 Pod이 생성되는 과정과 동일하며 airflow에서는 내부적으로 python kubernetes client library를 통해 k8s_model 이라는 객체로 K8S API를 추상화하여 사용하고 있습니다. </p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1hzzK8Jx5olsXsQTiVdPyKPqNA-CA-ulT\" alt=\"kubeexecutor3\"></p>\n<br>\n<p>task가 완료되기 전에 Airflow DB 상태 업데이트 단계에서 OOM 등의 이유로 Pod Crash가 언제나 발생할 수 있기 때문에 이에 대한 장애 시나리오도 준비되어 있습니다. DB 업데이트에 실패하더라도 airflow scheduler는 Kubernetes Watch API를 통해 pod의 상태를 전달받아 다시 DB 상태를 업데이트 할 수 있습니다. CeleryExecutor의 경우, task 상태에 대한 처리를 celery에 주기적으로 확인하는 방식이라면 KubernetesExecutor는 이벤트 스트림으로 전달받기 때문에 스케줄러에 대한 부하가 더 낮다고 볼 수 있습니다.</p>\n<br>\n<h2 id=\"kubernetesexecutor-batch-cronjob\" style=\"position:relative;\"><a href=\"#kubernetesexecutor-batch-cronjob\" aria-label=\"kubernetesexecutor batch cronjob permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>KubernetesExecutor Batch, CronJob</h2>\n<p>공식 차트에서는 사용자의 편의를 위해 RBAC 초기 사용자를 생성해주는 <strong>create-user BatchJob</strong>이 추가되었습니다. <strong>Helm Hooks (post-install)</strong> 를 통해 차트 리소스가 모두 생성된 이후에 수행됩니다.</p>\n<p>추가로 <strong>cleanup CronJob</strong>이 있습니다. <code class=\"language-text\">AIRFLOW__KUBERNETES__DELETE_WORKER_PODS</code> 옵션을 통해 task가 끝나더라도 pod이 종료되지 않도록 설정할 수 있는데 이때 내가 원하는 주기마다 오래된 pod을 삭제할 수 있는 CronJob 입니다.</p>\n<br>\n<h2 id=\"official-helm-chart-issue\" style=\"position:relative;\"><a href=\"#official-helm-chart-issue\" aria-label=\"official helm chart issue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Official Helm Chart Issue</h2>\n<p>공식 버전 차트는 아래와 같은 이슈가 남아있지만 2.0 정식 버전 출시와 함께 해결될 예정입니다.\n글을 작성하는 과정에서 DAG 동기화 관련 버그를 발견하였지만 리뷰를 통해 곧바로 수정되었습니다. (<a href=\"https://github.com/apache/airflow/pull/9371\">PR-9371</a>). stable/airflow 차트와 비교했을때 아쉬운 점은 아래와 같습니다.</p>\n<ul>\n<li>현재 버전에서는 backend로 postgresql만 지원 <a href=\"https://github.com/apache/airflow/issues/9627\">(ISSUE-9627)</a></li>\n<li>pip 등 작업 실행에 필요한 패키지 설치하는 옵션이 없음</li>\n<li>initContainer를 수정해서 설치하거나 이미지 별도로 생성해야함</li>\n<li>차트에 Ingress 설정에 대한 옵션이 부족</li>\n<li>KubernetesExecutor의 경우 remote logging 설정을 해야 UI에서 로그 확인 가능</li>\n</ul>\n<br>\n<h2 id=\"deploy\" style=\"position:relative;\"><a href=\"#deploy\" aria-label=\"deploy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deploy</h2>\n<p>사실 배포와 옵션에 대한 내용은 지난 글에서 말한 내용과 크게 다름이 없습니다. 아직 정식 릴리즈까지 변경될 여지가 많다보니 아래 공식 문서 따라하시는 방법을 추천드립니다 <a href=\"https://github.com/apache/airflow/tree/master/chart\">(apache/airflow/chart)</a>. 다음 글에서는 KubernetesExecutor의 로깅과 모니터링에 대해 다루어보겠습니다!</p>","excerpt":"최근 Airflow에는 Kubernetes 지원을 위해 다양한 컴포넌트들이 추가되고 있습니다. 이러한 변화의 흐름에 따라 Airflow…"}}}},{"node":{"title":"K8S 클러스터 초기 설정을 위한 Helm Chart 만들기","id":"50edb485-5b91-5e74-84e3-b28eb9d2dadd","slug":"umbrella-helm-chart","publishDate":"June 20, 2020","heroImage":{"id":"f36c235f-3e3e-517d-bd80-697bc6183072","title":"cover-devops","fluid":{"aspectRatio":1.5,"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50 1080w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50&fm=webp 1080w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"99c46de3-36d7-5f08-8771-e45fcd4ea237","childMarkdownRemark":{"id":"9bd3b1b0-ea88-5602-9ad0-2484e145b087","timeToRead":4,"html":"<p>K8S 클러스터를 설정하고 운영하다보면 <strong>버전 업데이트, 컴포넌트 추가 설치 등 다양한 변경</strong>에 대응할 수 있어야 합니다. 또한 Develop, Production, Staging 등 <strong>목적에 따라 다양한 클러스터를 추가로 설정하고 배포</strong>해야 하는 경우도 생깁니다. 오늘은 이러한 어려움을 해결할 수 있는 <strong>Umbrella Helm Chart</strong>에 대해 정리해보려고 합니다. Helm을 처음 접하신다면 <a href=\"https://helm.sh/docs/\">공식문서</a>를 먼저 보는 방법을 추천드립니다.</p>\n<br>\n<h2 id=\"umbrella-helm-chart\" style=\"position:relative;\"><a href=\"#umbrella-helm-chart\" aria-label=\"umbrella helm chart permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Umbrella Helm Chart</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1q9d6Dl9U4IIzOZ2VYrvKEC1-jcHxXWmJ\"></p>\n<p>Umbrella Helm Chart란 여러 개의 Helm Chart들이 모여있는 집합을 의미합니다. 어디에서부터 시작된 용어인지 모르겠으나 저는 <a href=\"https://kccncna19.sched.com/event/Uacr\">2019 Kubecon - Scaling to Thousands of Nodes (Airbnb)</a> 발표에서 처음 접하게 되었습니다. 사내에 K8S에 대한 요구사항이 빠르게 늘어나던 Airbnb는 멀티 클러스터 배포 전략을 통해 <a href=\"(https://kubernetes.io/docs/setup/best-practices/cluster-large/)\">Node Hard Limit</a> 이슈를 해결하게 되었고 클러스터마다 배포를 위해 Umbrella Chart를 만들어 활용했다고 합니다.</p>\n<br>\n<h2 id=\"helm-chart-만들기\" style=\"position:relative;\"><a href=\"#helm-chart-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"helm chart 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Helm Chart 만들기</h2>\n<p>말로하면 이해가 어려우니 클러스터를 새로 설정한다고 가정하고 예시를 통해 Helm Chart를 만들어보겠습니다. 예시의 클러스터에는 아래와 같은 의존성이 존재합니다. 예시는 Helm 2.16.7 버전을 사용했습니다.</p>\n<ul>\n<li><strong>cluster-autoscaler</strong>: EKS AutoScaling 설정</li>\n<li><strong>grafana</strong>: 모니터링 대시보드</li>\n<li><strong>prometheus</strong>: 시스템 지표 수집 및 저장</li>\n<li><strong>fluentbit</strong>: 어플리케이션 로그 수집</li>\n</ul>\n<br>\n<p>먼저 Helm Chart 생성을 위한 폴더 구조를 생성해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ helm create umbrella\n$ <span class=\"token builtin class-name\">cd</span> umbrella\n$ tree\n<span class=\"token builtin class-name\">.</span>\n├── Chart.yaml\n├── charts\n├── templates\n│   ├── NOTES.txt\n│   ├── _helpers.tpl\n│   ├── deployment.yaml\n│   ├── ingress.yaml\n│   ├── service.yaml\n│   └── tests\n│       └── test-connection.yaml\n├── requirements.yaml\n└── values.yaml</code></pre></div>\n<br>\n<p>기본 생성되는 폴더 구조에서 <code class=\"language-text\">requirements.yaml</code> 파일은 추가로 생성해주셔야 합니다.\n폴더 구조에서 알아두어야 할 경로는 아래와 같습니다.</p>\n<ul>\n<li><code class=\"language-text\">Chart.yaml</code>: 차트에 대한 메타 정보가 들어갑니다.</li>\n<li><code class=\"language-text\">charts/</code>: 의존성이 있는 차트 패키지들이 설치됩니다.</li>\n<li><code class=\"language-text\">templates/</code>: 차트에 필요한 template 파일들이 들어갑니다.</li>\n<li><code class=\"language-text\">templates/NOTES.txt</code>: 차트 생성 시 나타나는 설명이 들어갑니다.</li>\n<li><code class=\"language-text\">requirements.yaml</code>: 의존성 차트들이 들어갑니다.</li>\n<li><code class=\"language-text\">values.yaml</code>: 차트 설정에 필요한 default 값들이 들어갑니다.</li>\n</ul>\n<br>\n<h3 id=\"chart-metadata\" style=\"position:relative;\"><a href=\"#chart-metadata\" aria-label=\"chart metadata permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chart Metadata</h3>\n<p>먼저 <code class=\"language-text\">Chart.yaml</code> 파일을 간단히 수정해줍니다.\n이름과 버전, 설명 등의 정보를 본인에 맞게 작성해주시면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">appVersion</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"1.0\"</span>\n<span class=\"token key atrule\">description</span><span class=\"token punctuation\">:</span> A Helm chart for Cluster Setup\n<span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> umbrella\n<span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> 0.1.0</code></pre></div>\n<br>\n<h3 id=\"chart-dependencies\" style=\"position:relative;\"><a href=\"#chart-dependencies\" aria-label=\"chart dependencies permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chart Dependencies</h3>\n<p>이제 앞서 언급한 의존성 중에 Helm Chart 형태로 배포할 컴포넌트를 <code class=\"language-text\">requirements.yaml</code> 파일에 정의하겠습니다. 각 차트는 이름, 저장소, 버전, 컨디션 값을 지정할 수 있습니다. <code class=\"language-text\">condition: prometheus.enabled</code>의 의미는 <code class=\"language-text\">values.yaml</code>에 <code class=\"language-text\">prometheus.enabled</code> 값이 true 일 경우에만 해당 차트를 설정하겠다는 뜻 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">dependencies</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> prometheus\n    <span class=\"token key atrule\">repository</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//kubernetes<span class=\"token punctuation\">-</span>charts.storage.googleapis.com\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> 9.7.3\n    <span class=\"token key atrule\">condition</span><span class=\"token punctuation\">:</span> prometheus.enabled\n\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> grafana\n    <span class=\"token key atrule\">repository</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//kubernetes<span class=\"token punctuation\">-</span>charts.storage.googleapis.com\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> 4.2.2\n    <span class=\"token key atrule\">condition</span><span class=\"token punctuation\">:</span> grafana.enabled\n\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> cluster<span class=\"token punctuation\">-</span>autoscaler\n    <span class=\"token key atrule\">repository</span><span class=\"token punctuation\">:</span> https<span class=\"token punctuation\">:</span>//kubernetes<span class=\"token punctuation\">-</span>charts.storage.googleapis.com\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> 6.3.0</code></pre></div>\n<br>\n<p>이제 <code class=\"language-text\">helm dep up</code> 명령어를 통해 의존성 차트를 갱신할 수 있습니다.\n이를 통해 <code class=\"language-text\">charts/</code> 하위에 차트 파일들이 설치됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ helm dep up\nHang tight while we grab the latest from your chart repositories...\nUpdate Complete.\nSaving 3 charts\nDownloading prometheus from repo https://kubernetes-charts.storage.googleapis.com\nDownloading grafana from repo https://kubernetes-charts.storage.googleapis.com\nDownloading cluster-autoscaler from repo https://kubernetes-charts.storage.googleapis.com\nDeleting outdated charts</code></pre></div>\n<br>\n<p>의존성 차트에 적용할 설정 값들은 <code class=\"language-text\">values.yaml</code>에 정의할 수 있습니다.\ngrafana를 예시로 들면 아래와 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># values.yaml</span>\n<span class=\"token key atrule\">grafana</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">adminPassword</span><span class=\"token punctuation\">:</span> mypassword\n  <span class=\"token key atrule\">persistence</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">storageClass</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"gp2\"</span>\n    <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> pvc\n    <span class=\"token key atrule\">size</span><span class=\"token punctuation\">:</span> 5Gi\n  <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> ClusterIP</code></pre></div>\n<br>\n<h3 id=\"templates\" style=\"position:relative;\"><a href=\"#templates\" aria-label=\"templates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Templates</h3>\n<p>의존성 패키지가 공식 Helm Chart를 지원한다면 <code class=\"language-text\">dependencies</code> 부분에 정의할 수 있겠지만 yaml 파일만 제공하는 패키지도 많이 존재합니다. 이 경우, <code class=\"language-text\">templates/</code> 하위에 yaml 파일을 추가해주시면 됩니다. 외부 설정으로 내보내고 싶은 항목들은 <strong>template function</strong>을 활용해서 수정할 수 있습니다. 여기에서는 <code class=\"language-text\">fluentbit</code>만 예시로 추가하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token builtin class-name\">cd</span> templates\n$ <span class=\"token function\">curl</span> -O https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-service-account.yaml\n$ <span class=\"token function\">curl</span> -O https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-role.yaml\n$ <span class=\"token function\">curl</span> -O https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/fluent-bit-role-binding.yaml\n$ <span class=\"token function\">curl</span> -O https://raw.githubusercontent.com/fluent/fluent-bit-kubernetes-logging/master/output/elasticsearch/fluent-bit-configmap.yaml</code></pre></div>\n<br>\n<h3 id=\"deploy\" style=\"position:relative;\"><a href=\"#deploy\" aria-label=\"deploy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deploy</h3>\n<p>이제 예시 차트를 클러스터에 배포할 차례입니다. 배포 후 차트 내 컴포넌트 버전 업데이트가 발생하더라도 <code class=\"language-text\">helm upgrade</code> 명령어를 통해 쉽게 관리할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># install</span>\n$ helm <span class=\"token function\">install</span> <span class=\"token builtin class-name\">.</span> --name umbrella --namespace umbrella\n\n<span class=\"token comment\"># check status</span>\n$ helm status umbrella\n$ helm get umbrella\n\n<span class=\"token comment\"># upgrade</span>\n$ helm upgrade -f values.yaml umbrella <span class=\"token builtin class-name\">.</span>\n\n<span class=\"token comment\"># delete</span>\nhelm del umbrella --purge</code></pre></div>\n<br>\n<p>만일 어플리케이션들이 모두 별도의 Helm Chart로 관리되고 있다면 Umbrella Chart에서 어플리케이션 차트까지 의존성으로 추가하는 방식으로 운영하는 방법도 있습니다. 요즘에는 Helm 이외에도 kustomize 등 다양한 도구들이 있으니 비교해보고 적절한 방식을 선택하시면 좋습니다.</p>\n<br>","excerpt":"K8S 클러스터를 설정하고 운영하다보면 버전 업데이트, 컴포넌트 추가 설치 등 다양한 변경에 대응할 수 있어야 합니다. 또한 Develop…"}}}},{"node":{"title":"Airflow on Kubernetes (1)","id":"8a8dd949-d905-5883-8781-94ee011c3522","slug":"airflow-on-kubernetes-1","publishDate":"June 05, 2020","heroImage":{"id":"dab22ea8-d54d-52a6-852a-278ba3b19a2b","title":"cover-dataengineering","fluid":{"aspectRatio":1.499531396438613,"src":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50 1600w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"c12fefe6-aab9-599e-b87d-9d996a4e0bb5","childMarkdownRemark":{"id":"a96aecc2-d61d-5567-9728-1f9760a46ebc","timeToRead":5,"html":"<p>최근 Airflow에는 Kubernetes 지원을 위해 다양한 컴포넌트들이 추가되고 있습니다. 이러한 변화의 흐름에 따라 Airflow를 Kubernetes 위에 배포하고 운영하는 방법에 대해 글을 작성해보고자 합니다. 이 글은 시리즈로 연재됩니다.</p>\n<ul>\n<li><a href=\"https://swalloow.github.io/airflow-on-kubernetes-1\">Airflow on Kubernetes (1): CeleryExecutor</a></li>\n<li><a href=\"https://swalloow.github.io/airflow-on-kubernetes-2\">Airflow on Kubernetes (2): KubernetesExecutor</a></li>\n<li>Airflow on Kubernetes (3): Prometheus를 활용한 Airflow 모니터링</li>\n</ul>\n<br>\n<h2 id=\"airflow-on-kubernetes\" style=\"position:relative;\"><a href=\"#airflow-on-kubernetes\" aria-label=\"airflow on kubernetes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Airflow on Kubernetes</h2>\n<p>Airflow를 Kubernetes 인프라 위에서 운영하는 방법은 크게 두 가지로 나눌 수 있습니다.\n이 글에서 소개할 방법은 <strong>CeleryExecutor의 각 모듈을 Kubernetes 위에 올리는 방식</strong>입니다. 기존에 운영하던 형태와 유사하기 때문에 쉽게 적용할 수 있으나 Celery에 대한 의존성이 강하다보니 완전히 Cloud Native한 형태는 아닙니다. 아키텍쳐는 가장 많이 사용하는 <a href=\"https://github.com/helm/charts/blob/master/stable/airflow\">stable/airflow</a> Helm Chart를 참고하였습니다. 이제 몇 가지 컴포넌트 설정과 함께 자세히 알아보겠습니다.</p>\n<br>\n<h2 id=\"config\" style=\"position:relative;\"><a href=\"#config\" aria-label=\"config permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Config</h2>\n<p>Airflow는 <code class=\"language-text\">airflow.cfg</code> 파일 또는 <code class=\"language-text\">AIRFLOW__[SECTOR]__[VARIABLES]</code> 환경 변수를 통해 각 컴포넌트의 설정을 관리할 수 있었습니다. Helm Chart에서는 <code class=\"language-text\">values.yaml</code>의 config 필드를 통해 설정을 관리할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># CORE</span>\n  <span class=\"token key atrule\">AIRFLOW__CORE__DEFAULT_TIMEZONE</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Asia/Seoul\"</span>\n  <span class=\"token key atrule\">AIRFLOW__CORE__PARALLELISM</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"32\"</span>\n  <span class=\"token key atrule\">AIRFLOW__CORE__DAG_CONCURRENCY</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"16\"</span>\n  <span class=\"token key atrule\">AIRFLOW__CORE__MAX_ACTIVE_RUNS_PER_DAG</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"16\"</span>\n\n  <span class=\"token comment\"># WEBSERVER</span>\n  <span class=\"token key atrule\">AIRFLOW__WEBSERVER__DEFAULT_UI_TIMEZONE</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"Asia/Seoul\"</span>\n  <span class=\"token key atrule\">AIRFLOW__WEBSERVER__WORKER_REFRESH_INTERVAL</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"60\"</span>\n  \n  <span class=\"token comment\"># CELERY</span>\n  <span class=\"token key atrule\">AIRFLOW__CELERY__WORKER_CONCURRENCY</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"16\"</span>\n\n  <span class=\"token comment\"># SCHEDULER</span>\n  <span class=\"token key atrule\">AIRFLOW__SCHEDULER__SCHEDULER_HEARTBEAT_SEC</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"30\"</span>\n  <span class=\"token key atrule\">AIRFLOW__SCHEDULER__SCHEDULER_HEALTH_CHECK_THRESHOLD</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"120\"</span>\n  <span class=\"token key atrule\">AIRFLOW__SCHEDULER__DAG_DIR_LIST_INTERVAL</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"30\"</span>\n  <span class=\"token key atrule\">AIRFLOW__SCHEDULER__RUN_DURATION</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"10800\"</span>\n  <span class=\"token key atrule\">AIRFLOW__SCHEDULER__MAX_THREADS</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"2\"</span></code></pre></div>\n<br>\n<p>위에 정의한 설정 변수들은 Airflow의 성능과 관련되어 있기 때문에 각자 할당된 리소스에 맞게 설정해주셔야 합니다. 자세한 내용은 <a href=\"https://airflow.apache.org/docs/stable/faq.html#how-can-my-airflow-dag-run-faster\">공식문서 링크</a>를 참고하시기 바랍니다. 위와 같은 방식으로 DAG에서 활용하는 connection, variables도 정의할 수 있습니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># config.yaml</span>\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ConfigMap\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>webserver<span class=\"token punctuation\">-</span>config\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> airflow\n<span class=\"token key atrule\">data</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">webserver_config.py</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n    APP_THEME = \"flatly.css\"</span>\n\n<span class=\"token punctuation\">---</span>\n<span class=\"token comment\"># values.yaml</span>\n<span class=\"token key atrule\">extraConfigmapMounts</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>webserver<span class=\"token punctuation\">-</span>config\n    <span class=\"token key atrule\">mountPath</span><span class=\"token punctuation\">:</span> /opt/airflow/webserver_config.py\n    <span class=\"token key atrule\">configMap</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>webserver<span class=\"token punctuation\">-</span>config\n    <span class=\"token key atrule\">readOnly</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">subPath</span><span class=\"token punctuation\">:</span> webserver_config.py</code></pre></div>\n<br>\n<p>위와 같이 <code class=\"language-text\">ConfigMap</code>이나 <code class=\"language-text\">Secret</code>을 따로 만들고 참조하도록 연결하는 방식도 가능합니다. 특히 Airflow 1.10의 RBAC을 사용한다면 <code class=\"language-text\">webserver_config.py</code>를 통해 <code class=\"language-text\">APP_THEME</code>를 변경해줄 수 있는데 이런 경우에 <strong>extraConfigmap</strong>을 통해 적용할 수 있습니다.</p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1RzSP5YX2EyH3xDnk0VM4wB57lsn55j1o\" alt=\"airflow-webserver\"></p>\n<br>\n<p>제가 주로 사용하는 테마는 <code class=\"language-text\">flatly.css</code>에 <code class=\"language-text\">NAVBAR #18bc9c</code> 컬러 조합입니다. 적용된 화면은 위와 같습니다. (+ 태그 기능도 1.10.10 버전에 추가되었습니다)</p>\n<br>\n<h2 id=\"celery-worker\" style=\"position:relative;\"><a href=\"#celery-worker\" aria-label=\"celery worker permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Celery Worker</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1N81eEP8AT1ddwCDtHnDKblgwkZsc2FFB\" alt=\"celery\"></p>\n<br>\n<p>CeleryExecutor에서 worker는 실제 task를 수행을 담당하는 컴포넌트입니다. K8S에서는 celery worker가 StatefulSet으로 배포됩니다. 기존에는 worker가 <code class=\"language-text\">AutoScalingGroup</code> 등을 통해 인스턴스가 자동 확장되도록 구성했다면, K8S에서는 <code class=\"language-text\">HorizontalPodAutoscaler</code>를 통해 Pod 단위로 확장 가능하도록 구성할 수 있습니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">workers</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n\n  <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"2Gi\"</span>\n\n  <span class=\"token key atrule\">autoscaling</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">maxReplicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">16</span>\n    <span class=\"token key atrule\">metrics</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> Resource\n      <span class=\"token key atrule\">resource</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> memory\n        <span class=\"token key atrule\">target</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> Utilization\n          <span class=\"token key atrule\">averageUtilization</span><span class=\"token punctuation\">:</span> <span class=\"token number\">80</span></code></pre></div>\n<br>\n<h2 id=\"airflow-ingress\" style=\"position:relative;\"><a href=\"#airflow-ingress\" aria-label=\"airflow ingress permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Airflow Ingress</h2>\n<p>보통 K8S 클러스터에 Ingress Controller를 설정하고 path를 통해 여러 서비스에 접속하는 경우가 많습니다. Airflow Chart 역시 Webserver와 Flower UI에 대한 ingress를 지원합니다. 저는 nginx-ingress controller를 사용해서 진행해보겠습니다. 아래 예시는 각자의 ingress-controller 설정에 맞게 바꾸시면 됩니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">annotations</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> ClusterIP\n    <span class=\"token key atrule\">externalPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8080</span>\n    <span class=\"token key atrule\">loadBalancerIP</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token key atrule\">loadBalancerSourceRanges</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">...</span>\n\n<span class=\"token key atrule\">ingress</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">annotations</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">kubernetes.io/ingress.class</span><span class=\"token punctuation\">:</span> nginx\n      <span class=\"token key atrule\">ingress.kubernetes.io/rewrite-target</span><span class=\"token punctuation\">:</span> /\n      <span class=\"token key atrule\">nginx.ingress.kubernetes.io/ssl-redirect</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"false\"</span>\n    \n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/airflow\"</span>\n    <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"myloadbalancer-domain.com\"</span></code></pre></div>\n<p>예를 들어 web path에 <code class=\"language-text\">/airflow</code> 라고 설정하셨다면, UI 접속 주소는 <code class=\"language-text\">myloadbalancer-domain.com/airflow</code>가 됩니다. flower도 위와 동일한 방식으로 설정하시면 됩니다.</p>\n<br>\n<h2 id=\"airflow-auth\" style=\"position:relative;\"><a href=\"#airflow-auth\" aria-label=\"airflow auth permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Airflow Auth</h2>\n<p>Airflow 에서는 다양한 인증 방식을 지원하지만 여기에서는 가장 기본이 되는 Password Auth 방식으로 배포하겠습니다. 새로 추가된 RBAC 설정도 함께 추가해보겠습니다. 먼저 <code class=\"language-text\">extraPipPackages</code> 설정을 통해 의존성 패키지를 설치해주고 상단에 환경 변수도 추가해줍니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">config</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">AIRFLOW__WEBSERVER__RBAC</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"True\"</span>\n  <span class=\"token key atrule\">AIRFLOW__WEBSERVER__AUTHENTICATE</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"True\"</span>\n  <span class=\"token key atrule\">AIRFLOW__WEBSERVER__AUTH_BACKEND</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"airflow.contrib.auth.backends.password_auth\"</span>\n\n<span class=\"token punctuation\">...</span>\n\n<span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">extraPipPackages</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token string\">\"flask-bcrypt\"</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token string\">\"flask-oauthlib>=0.9\"</span></code></pre></div>\n<br>\n<p>이제 로그인할 사용자를 추가해주어야 합니다. Scheduler Pod의 Bash에서 create_user 명령어를 통해 생성해주시면 됩니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ kubectl exec \\\n  -it \\\n  --namespace airflow \\\n  --container airflow-scheduler \\\n  Deployment/airflow-scheduler \\\n  /bin/bash\n\n$ airflow create_user \\\n--username=admin \\\n--email=test@example.com \\\n--password=mypassword \\\n--role=Admin \\\n--firstname=test \\\n--lastname=park</code></pre></div>\n<br>\n<h2 id=\"airflow-iam-role\" style=\"position:relative;\"><a href=\"#airflow-iam-role\" aria-label=\"airflow iam role permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Airflow IAM Role</h2>\n<p>AWS EKS와 같은 클라우드 서비스 위에 배포한다면 각 컴포넌트의 세부 권한을 지정해주어야 합니다. 만일 Pod에 IAM Role을 할당하지 않는다면 Airflow는 클러스터의 기본 IAM Role인 EKS worker 설정을 따르게 됩니다. 따라서 보안을 신경쓰셔야 한다면 설정하는 것이 바람직합니다. 특히 Airflow에서 다른 AWS Managed Service(EMR, Athena, Lambda)와 연계하는 DAG이 존재하신다면 필수적입니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">serviceAccount</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">create</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"airflow\"</span>\n  <span class=\"token key atrule\">annotations</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">eks.amazonaws.com/role-arn</span><span class=\"token punctuation\">:</span> arn<span class=\"token punctuation\">:</span>aws<span class=\"token punctuation\">:</span>iam<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>123456789999<span class=\"token punctuation\">:</span>role/airflow\n\n<span class=\"token punctuation\">...</span>\n\n<span class=\"token key atrule\">securityContext</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">fsGroup</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1000</span></code></pre></div>\n<br>\n<p><code class=\"language-text\">values.yaml</code>에는 포함되어 있지 않지만 각 컴포넌트마다 <code class=\"language-text\">securityContext</code>를 지정해주셔야 IAM Role을 매핑할 수 있습니다. <code class=\"language-text\">IAM Role for Service Account</code>가 내부적으로 K8S TokenProjection을 사용하기 때문에 설정을 안하면 토큰을 읽을 수 없다는 오류가 발생합니다. IAM Role 설정에 대한 자세한 내용은 <a href=\"https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/iam-roles-for-service-accounts-technical-overview.html\">EKS 공식 문서</a>를 참고하시기 바랍니다.</p>\n<br>\n<h2 id=\"dags\" style=\"position:relative;\"><a href=\"#dags\" aria-label=\"dags permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DAGs</h2>\n<p>Airflow는 Scheduler가 DAG 파일을 주기적으로 동기화하며 문법적 오류가 없는지 체크하는 역할을 수행합니다. 단일 노드에서는 로컬에 있는 DAG 파일을 읽으면 되지만 K8S에서는 worker pod가 여러 노드에 걸쳐있기 때문에 모두 같은 DAG 파일을 바라보도록 하는 동기화 설정이 필요합니다. Helm Chart에서는 이를 지원하기 위해 두 가지 옵션을 제공합니다.</p>\n<br>\n<p><strong>1. Git-Sync Sidecar</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># git-sync sidecar</span>\n<span class=\"token key atrule\">dags</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">git</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">url</span><span class=\"token punctuation\">:</span> ssh<span class=\"token punctuation\">:</span>//git@repo.example.com/example.git\n    <span class=\"token key atrule\">repoHost</span><span class=\"token punctuation\">:</span> repo.example.com\n    <span class=\"token key atrule\">secret</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>git<span class=\"token punctuation\">-</span>keys\n    <span class=\"token key atrule\">privateKeyName</span><span class=\"token punctuation\">:</span> id_rsa\n\n    <span class=\"token key atrule\">gitSync</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n      <span class=\"token key atrule\">refreshTime</span><span class=\"token punctuation\">:</span> <span class=\"token number\">60</span></code></pre></div>\n<br>\n<p>첫 번째 방식은 <strong>git-sync 사이드카 컨테이너</strong>를 활용하는 방법입니다. 간단히 말하자면 주기적으로 외부 저장소를 당겨오는 방식으로 git 인증이 필요합니다. 사이드카 패턴이 생소하시다면 이전에 작성한 <a href=\"https://swalloow.github.io/container-patterns/#sidecar-pattern\">분산 컨테이너에서의 디자인 패턴</a> 글을 참고하시기 바랍니다.</p>\n<br>\n<p><strong>2. Shared Persistent Volume</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># EFS PV, PVC</span>\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolume\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>dags\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> airflow\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>dags\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> airflow\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 20Gi\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteMany\n  <span class=\"token key atrule\">nfs</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">server</span><span class=\"token punctuation\">:</span> 0.0.0.0 &lt;<span class=\"token punctuation\">-</span> EFS endpoint\n    <span class=\"token key atrule\">path</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"/airflow\"</span>\n\n<span class=\"token punctuation\">---</span>\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> PersistentVolumeClaim\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>dags\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> airflow\n  <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> airflow\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">storageClassName</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"\"</span>\n  <span class=\"token key atrule\">accessModes</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> ReadWriteMany\n  <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">storage</span><span class=\"token punctuation\">:</span> 10Gi\n  <span class=\"token key atrule\">selector</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">matchLabels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> airflow<span class=\"token punctuation\">-</span>dags\n\n<span class=\"token punctuation\">---</span>\n<span class=\"token comment\"># shared persistent volume</span>\n<span class=\"token key atrule\">dags</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">persistence</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enabled</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">existingClaim</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"airflow-dags\"</span>\n    <span class=\"token key atrule\">accessMode</span><span class=\"token punctuation\">:</span> ReadWriteMany\n    <span class=\"token key atrule\">size</span><span class=\"token punctuation\">:</span> 1Gi</code></pre></div>\n<br>\n<p>두 번째 방식은 <strong>EFS와 같은 공유 파일시스템을 활용한 방법</strong>입니다. EFS의 특정 경로에 DAG 파일을 저장하고 마운트를 통해 모든 Pod이 같은 경로를 바라보도록 설정하는 방식입니다. 저는 EFS PV와 PVC를 먼저 추가한다음 existingClaim을 통해 참조하도록 설정해주었습니다.</p>\n<br>\n<h2 id=\"deploy\" style=\"position:relative;\"><a href=\"#deploy\" aria-label=\"deploy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deploy</h2>\n<p>필요한 설정을 완료했다면 배포는 아래 Helm 명령어를 통해 할 수 있습니다. 가능하다면 데이터베이스는 external로 사용하는 방법을 추천드립니다. DB 암호는 secret을 통해 생성하고 참조하도록 설정해주시면 됩니다.</p>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">helm install stable/airflow \\\n--version 7.1.1 \\\n--namespace airflow \\\n--name airflow \\\n-f ./values.yaml</code></pre></div>\n<br>\n<p>배포 이후에 namespace를 보면 아래와 같은 Pod이 존재하는걸 확인할 수 있습니다.</p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1Ep52ZE0lhsbp2R3FOGlC3uFyq7CYPu1D\" alt=\"airflow-po\"></p>\n<br>\n<p>이 글에서 언급한 설정은 FIXME 주석을 해두었으니 궁금하신분들은 <a href=\"https://github.com/Swalloow/airflow-helm\">https://github.com/Swalloow/airflow-helm</a> 저장소를 확인하시기 바랍니다.</p>","excerpt":"최근 Airflow에는 Kubernetes 지원을 위해 다양한 컴포넌트들이 추가되고 있습니다. 이러한 변화의 흐름에 따라 Airflow…"}}}},{"node":{"title":"Gatsby와 Contentful로 블로그 이전한 후기","id":"fe483c60-6d5b-59ee-9cd0-820b11c14828","slug":"gatsby-contentful","publishDate":"April 25, 2020","heroImage":{"id":"1faaada3-e12b-5548-8532-08b7c04dc7eb","title":"cover-personal","fluid":{"aspectRatio":1.694915254237288,"src":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=450&h=266&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=900&h=531&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&q=50 1400w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=450&h=266&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=900&h=531&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&q=50&fm=webp 1400w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"3fa2d7af-63eb-5818-b706-6c142130b7a4","childMarkdownRemark":{"id":"8d657a56-940e-59dd-82e0-5d31d02e1821","timeToRead":3,"html":"<p>3년 정도 이어왔던 Jekyll 블로그를 Gatsby와 Contentful로 옮긴 이유와\n이에 따라 생긴 변화들에 대해 정리해보려 합니다.</p>\n<br>\n<h2 id=\"왜-옮기게-되었을까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%98%AE%EA%B8%B0%EA%B2%8C-%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C\" aria-label=\"왜 옮기게 되었을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 옮기게 되었을까</h2>\n<p>블로그를 옮기고 싶었던 가장 큰 이유는 <strong>컨텐츠 관리</strong>가 불편하다는 점이었습니다.\n이전에 사용하던 테마는 로컬에서 posts 하위의 md 파일을 통해 컨텐츠를 작성하고 이를 빌드 후 github.io 저장소에 배포하는 형태였습니다. 만일 개인적으로 사용하고 있는 노트북과 데스크탑이 여러 개라면 모든 기기에 블로그 개발환경을 구축해야만 합니다. md 기반의 글들은 테마를 옮겨가려고 해도 기존에 사용하던 방식과 맞지 않다면 많은 부분을 수정해야하는 불편함이 있습니다.</p>\n<p>또한 요즘 잘 구축되어 있는 블로그 플랫폼(brunch, velog, medium)들을 보면 <strong>글 작성을 위한 에디터</strong>가 정말 편리하게 구성되어 있습니다. 저 또한 이러한 장점을 사용하고 싶었지만 기존에 작성해둔 글을 옮기기에 무리가 있고, 글에 대한 링크가 변경된다는 점 때문에 옮길 수는 없다고 판단했습니다.</p>\n<p>두번째 이유는 사용하고 있던 Jekyll <strong>테마 자체에 대한 불만</strong>이었습니다.\n특히 코드 스타일링 플러그인의 사용 방식과 UI가 마음에 들지 않아 gist 링크를 사용하곤 했는데 옮겨다니면서 편집하려다보니 시간이 더 오래 걸렸습니다. 루비와 템플릿 엔진 방식의 테마는 커스터마이징하기 불편했고 이를 위해 사용하지도 않을 언어를 공부하고 싶지도 않았습니다.\n이러한 이유로 Gatsby를 선택하게 되었고 다양한 플러그인과 쉬운 커스터마이징에 만족하고 있습니다.</p>\n<br>\n<h2 id=\"contentful\" style=\"position:relative;\"><a href=\"#contentful\" aria-label=\"contentful permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contentful</h2>\n<p>제가 컨텐츠 관리를 더 편하게 하기 위해 선택한 플랫폼은 <strong>Contentful</strong> 입니다.\nHeadless CMS라 불리기도 하는 Contentful은 컨텐츠를 관리하기 위한 모든 역할을 수행할 수 있습니다. 실제로 사용해보면서 느낀 장점은 아래와 같습니다.</p>\n<ul>\n<li>컨텐츠와 이를 보여주는 부분이 분리되어있어 언제든지 테마 이동이 가능</li>\n<li>컨텐츠에 대해 자체적인 스키마 구성 가능 (저자, 태그 등)</li>\n<li>컨텐츠에 대한 상태관리</li>\n<li>글을 작성할 수 있는 에디터를 제공</li>\n<li>이미지 리사이징 및 프리뷰, 다양한 최적화기능</li>\n<li>대부분의 기능을 자동화할 수 있도록 API 제공</li>\n</ul>\n<p>이러한 장점들은 기존에 가지고 있던 불편함을 해소하기에 충분했고 글을 전부 마이그레이션하기에도 불편함이 없었습니다. 특히 slug 지정을 통해 기존 경로를 그대로 유지할 수 있었습니다. </p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1Z8OQ0u_QDqp2ClgYvQQVHvS0Z5ywx_Ig\" alt=\"BlogMeta\"></p>\n<br>\n<p><a href=\"https://swalloow.github.io/contents-url\">https://swalloow.github.io/contents-url</a> 경로를 예를 들면 하위에 오는 contents-url이 위 그림에서 slug 값에 해당합니다. 이런식으로 Post 마다 태그 등의 다양한 메타데이터를 설정할 수 있습니다. 모든 포스트는 <strong>Draft, Publish, Archive</strong> 단계의 상태를 가지게 됩니다. 아직 글을 작성 중이라면 Draft 상태로 남겨두고 완성 후 Pulish를 수행하는 식으로 활용할 수 있습니다. Publish 할때마다 자동으로 버전이 추가되기 때문에 이전으로 롤백하는 것도 쉽게 가능합니다.</p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=18hawHsV-JhNIbEAdyuNzX4wzkojDqIIM\" alt=\"BlogEditor\"></p>\n<br>\n<p>위 그림은 Contentful에서 제공하는 마크다운 에디터 입니다.\n마크다운 문법이 기억나지 않더라도 상단바를 통해 쉽게 글을 작성하고 편집할 수 있도록 구성되어 있습니다.</p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1n-ZeNrNt1lHmNzXDZw7141YTV4c1Hxkr\" alt=\"BlogTags\"></p>\n<p>위와 같이 내가 미리 설정해둔 태그를 포스트에 매핑시킬 수 있습니다. 태그마다 필요한 대표사진, 설명 등의 하위 필드도 사용자가 직접 정의할 수 있습니다.</p>\n<br>\n<br>\n<h2 id=\"github-action\" style=\"position:relative;\"><a href=\"#github-action\" aria-label=\"github action permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GitHub Action</h2>\n<p>이번에 GitHub Action을 통해 글을 배포하도록 개선하면서 블로그 개발 환경이 구축되어 있지 않더라도 어디서든지 글을 작성하고 내보낼 수 있게 되었습니다. 변경된 배포 방식은 아래와 같습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1r2z-LPwxU85CgKI5lvfraUQXQP8DxocN\" alt=\"actions\"></p>\n<p>이제 Contentful Editor를 통해 글을 작성하고 UI 상의 Publish 버튼만 누르면 알아서 GitHub Pages에 올라가게 되었습니다. 이 외에도 Contentful Webhook을 통해 netlify로 배포한다거나 알림을 받는 등 다양한 기능을 연계할 수 있다는 것도 장점 중 하나 입니다.</p>\n<br>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1ZXj54nt6Ou1LD7aMMjsJ-mHQi8A8Y1jf\" alt=\"master\"></p>\n<p>master 브랜치로 배포하는 step은 <code class=\"language-text\">JamesIves/github-pages-deploy-action@releases/v3</code>를 사용했습니다. 대상 폴더와 브랜치를 지정해주면 위 그림과 같은 형태로 push가 됩니다.</p>\n<br>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=198PaDWxlvRwhvoi7_1sv1V7SkGddXY6N\" alt=\"actions\"></p>\n<p>배포 결과는 위와 같이 Actions 메뉴에서 확인할 수 있습니다.</p>\n<br>\n<h2 id=\"gatsby\" style=\"position:relative;\"><a href=\"#gatsby\" aria-label=\"gatsby permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Gatsby</h2>\n<p>블로그 테마를 옮기면서 추가한 주요 플러그인들은 아래와 같습니다.</p>\n<ul>\n<li>gatsby-remark-katex: 수식 입력</li>\n<li>gatsby-source-contentful: contentful 연동</li>\n<li>gatsby-plugin-sitemap: sitemap 파일</li>\n<li>gatsby-plugin-robots-txt: robots 파일</li>\n<li>gatsby-plugin-feed: 피드 생성</li>\n</ul>\n<br>\n<p>블로그 댓글 기능도 기존 disqus에서 <strong>utterances</strong>로 변경하면서 댓글 확인도 편리해졌습니다. 이제 GitHub 모바일 앱이 있기 때문에 댓글이 달리면 휴대폰으로 확인하고 답글을 달 수 있게 되었습니다. 미세하게 utterances 렌더링 속도가 더 빠르기도 합니다.</p>\n<br>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1D53-6jE-I3d995SGjjZhUWOftR7baaFJ\"></p>\n<p>아주 큰 차이는 아니지만 이미지 최적화로 인해 첫 페이지 지연 시간도 단축되었습니다.\n언제 다시 테마를 옮기게 될지 모르겠으나 여러 측면에서 개선되고 편리해졌으니 이제 글 작성에만 집중할 수 있게 되었습니다!</p>","excerpt":"3년 정도 이어왔던 Jekyll 블로그를 Gatsby와 Contentful…"}}}},{"node":{"title":"EKS 클러스터에 VPC CIDR 추가하기","id":"2f37c986-e8fe-58e7-bb2e-2ca5f8cddcc1","slug":"eks-cidr","publishDate":"March 14, 2020","heroImage":{"id":"f36c235f-3e3e-517d-bd80-697bc6183072","title":"cover-devops","fluid":{"aspectRatio":1.5,"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50 1080w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50&fm=webp 1080w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"e085f98a-ff51-5f29-b126-529c3154a075","childMarkdownRemark":{"id":"0bd9b774-803c-53ac-9e9c-8f99d90548c5","timeToRead":2,"html":"<p>앞서 정리했던 <a href=\"https://swalloow.github.io/eks-vpc-cni\">EKS의 VPC 네트워크 구성 이해하기</a> 글을 먼저 보시는걸 권장드립니다. </p>\n<p>내 요구사항보다 적은 범위의 대역으로 클러스터를 생성한다면 VPC CNI로 인한 IP 제한에 마주할 수 있습니다. 처음부터 넓은 범위의 대역으로 생성하면 좋겠지만 이미 클러스터를 생성한 이후에는 어떻게 하면 좋을까요? 이러한 경우에는 VPC에 새로운 CIDR을 할당하고 이를 클러스터에 추가할 수 있습니다.</p>\n<br>\n<h2 id=\"vpc-cidr\" style=\"position:relative;\"><a href=\"#vpc-cidr\" aria-label=\"vpc cidr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VPC CIDR</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1i0LURjsrJbJWwqaVikpEDg3DQtmPhUp-\"></p>\n<p>먼저 확장하고자 하는 VPC를 선택한 후 새로운 CIDR 범위를 추가해주어야 합니다. 저는 위의 그림과 같이 10.X.X.X와 100.X.X.X 범위를 추가해주었습니다. 이후 새로운 CIDR 범위를 사용하여 서브넷을 생성한 다음 라우팅 테이블을 연결해줍니다.\nEKS에서 서브넷을 검색 가능하도록 하기 위해 아래와 같은 태그를 추가해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">Key</span><span class=\"token operator\">=</span>kubernetes.io/cluster/yourClusterName,Value<span class=\"token operator\">=</span>shared</code></pre></div>\n<br>\n<h2 id=\"custom-eni-config\" style=\"position:relative;\"><a href=\"#custom-eni-config\" aria-label=\"custom eni config permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom ENI Config</h2>\n<p>이제 새로운 CIDR 범위를 사용하도록 CNI 플러그인 설정을 변경해주어야 합니다. 먼저 클러스터에서 사용 중인 CNI 플러그인 버전을 확인하고 만일 1.5.3 미만인 경우 최신 버전으로 업데이트 합니다. (2020년 3월 기준, 최신 버전은 1.6 입니다)</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ kubectl describe daemonset aws-node --namespace kube-system <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> Image <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> -d <span class=\"token string\">\"/\"</span> -f <span class=\"token number\">2</span>\n$ kubectl apply -f https://raw.githubusercontent.com/aws/amazon-vpc-cni-k8s/master/config/v1.6/aws-k8s-cni.yaml</code></pre></div>\n<p>설치한 이후에 <code class=\"language-text\">kubectl get crd</code>를 통해 <strong>ENIConfig CRD</strong>가 제대로 설치되었는지 확인해줍니다. 만약 설치가 안되었다면 아래의 파일을 통해 CRD를 정의해주시면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> apiextensions.k8s.io/v1beta1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> CustomResourceDefinition\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> eniconfigs.crd.k8s.amazonaws.com\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">scope</span><span class=\"token punctuation\">:</span> Cluster\n  <span class=\"token key atrule\">group</span><span class=\"token punctuation\">:</span> crd.k8s.amazonaws.com\n  <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> v1alpha1\n  <span class=\"token key atrule\">names</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">plural</span><span class=\"token punctuation\">:</span> eniconfigs\n    <span class=\"token key atrule\">singular</span><span class=\"token punctuation\">:</span> eniconfig\n    <span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ENIConfig</code></pre></div>\n<p>이후에 aws-node daemonset에서 커스텀 네트워크 설정을 활성화하는 환경변수를 업데이트 해줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ kubectl <span class=\"token builtin class-name\">set</span> <span class=\"token function\">env</span> daemonset aws-node -n kube-system <span class=\"token assign-left variable\">AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG</span><span class=\"token operator\">=</span>true</code></pre></div>\n<p>이제 앞서 생성한 서브넷에 대해 ENIConfig CRD를 생성해줍니다.\n아래는 ap-northeast-2a, 2c에 대한 2개의 서브넷에 대한 파일입니다.\n보안 그룹도 클러스터 설정에 맞게 정의해주시면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> crd.k8s.amazonaws.com/v1alpha1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ENIConfig\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> private<span class=\"token punctuation\">-</span>user<span class=\"token punctuation\">-</span>2a\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">subnet</span><span class=\"token punctuation\">:</span> subnet<span class=\"token punctuation\">-</span>0ddddaaaaddddccdd\n  <span class=\"token key atrule\">securityGroups</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> sg<span class=\"token punctuation\">-</span>05555598cc88ffd00\n\n<span class=\"token punctuation\">---</span>\n<span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> crd.k8s.amazonaws.com/v1alpha1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ENIConfig\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> private<span class=\"token punctuation\">-</span>user<span class=\"token punctuation\">-</span>2c\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">subnet</span><span class=\"token punctuation\">:</span> subnet<span class=\"token punctuation\">-</span>0ccccaaaaddddccee\n  <span class=\"token key atrule\">securityGroups</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> sg<span class=\"token punctuation\">-</span>05555598cc88ffd00</code></pre></div>\n<p>마지막으로 클러스터에 해당하는 노드 그룹의 어노테이션을 수정해주어야 합니다. <a href=\"https://github.com/terraform-aws-modules/terraform-aws-eks\">terraform-aws-eks</a> 모듈을 통해 클러스터를 생성하셨다면 <code class=\"language-text\">worker_groups</code> 하위에 <code class=\"language-text\">kubelet_extra_args</code> 변수 설정을 통해 오토스케일링 그룹 설정을 수정할 수 있습니다.</p>\n<p>추가되어야할 어노테이션 값은 아래와 같습니다.\nValue 값의 경우, 위에서 추가한 ENIConfig CRD의 name metadata를 넣어주시면 됩니다. 업데이트 이후에는 노드를 재시작해주어야 정상적으로 적용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">k8s.amazonaws.com/eniConfig<span class=\"token operator\">=</span>private-user-2c</code></pre></div>\n<br>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/cni-custom-network.html\">https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/cni-custom-network.html</a></li>\n<li><a href=\"https://aws.amazon.com/ko/premiumsupport/knowledge-center/eks-multiple-cidr-ranges/\">https://aws.amazon.com/ko/premiumsupport/knowledge-center/eks-multiple-cidr-ranges/</a></li>\n</ul>\n<br>","excerpt":"앞서 정리했던 EKS의 VPC…"}}}},{"node":{"title":"AWS Solutions Architect Associate 취득 후기","id":"7167871b-8cf8-5f37-abf1-924bd4b13722","slug":"aws-cert","publishDate":"November 30, 2019","heroImage":{"id":"1faaada3-e12b-5548-8532-08b7c04dc7eb","title":"cover-personal","fluid":{"aspectRatio":1.694915254237288,"src":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=450&h=266&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=900&h=531&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&q=50 1400w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=450&h=266&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=900&h=531&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&q=50&fm=webp 1400w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"1a7067d9-45a7-5979-9cd6-deee5aabe25e","childMarkdownRemark":{"id":"1a13c5fd-fffb-56a4-a733-b41a87aad207","timeToRead":1,"html":"<p>그동안 관심은 있었지만 굳이 내 돈주고 시험볼 생각이 없었기에 미루고 있다가\n12월까지 취득하면 50달러를 준다는 이벤트에 눈이 돌아가 시험을 신청했다.\n시험 비용이 약 19만원이기 때문에 당연히 회사 지원금으로 봐야 한다.</p>\n<p>처음엔 그냥 시험봐도 상관없겠지라고 생각했지만 AWS에 생각보다 많은 기능과 서비스가 있어서\n준비안하고 보면 떨어질거라 생각한다. 이미 AWS에 익숙한 개발자 또는 인프라 엔지니어라면 Udemy에서\n<strong>AWS Solutions Architect Associate Practice Test</strong>를 통해 준비하면 충분하다.\n5~6회 정도의 실전 모의고사를 제공해주며 오답에 대한 풀이까지 친절하게 설명해준다.\n다만 영어로 말장난치는 문제들도 가끔 존재하는데 실제 시험에서 그런 문제는 안나온다고 보면 된다.</p>\n<p>시험을 보자마자 결과가 나오고 다음날 점수와 자격증 pdf 파일을 확인할 수 있다.\n기대안했던 것과 달리 준비하면서 새로 알게된 정보도 많아 관심있다면 보는 걸 추천한다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1TEZtk4Z65bzOmmEdgxcejTMEkkKaxTY0\"></p>","excerpt":"그동안 관심은 있었지만 굳이 내 돈주고 시험볼 생각이 없었기에 미루고 있다가\n12월까지 취득하면 5…"}}}},{"node":{"title":"EKS의 AutoScaling 이해하기","id":"777ba93e-b22c-5e74-9f0f-03d3290551b1","slug":"eks-autoscale","publishDate":"November 23, 2019","heroImage":{"id":"f36c235f-3e3e-517d-bd80-697bc6183072","title":"cover-devops","fluid":{"aspectRatio":1.5,"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50 1080w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50&fm=webp 1080w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"93814292-477d-5d50-b6f9-361473d42214","childMarkdownRemark":{"id":"2d86dba3-5c08-57c1-b59b-1a0ef1266b99","timeToRead":2,"html":"<p>오늘은 Kubernetes의 Cluster AutoScaling에 대해 정리해보려 합니다.\n그 다음 EKS에서는 어떻게 적용할 수 있는지, 어떤 효과를 볼 수 있는지 알아보겠습니다.</p>\n<br>\n<h2 id=\"kubernetes-cluster-autoscaling\" style=\"position:relative;\"><a href=\"#kubernetes-cluster-autoscaling\" aria-label=\"kubernetes cluster autoscaling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Kubernetes Cluster AutoScaling</h2>\n<p>Kubernetes는 Cluster AutoScaler를 통해 동적으로 인프라를 확장할 수 있습니다.\nCluster AutoScaler는 Pod의 리소스 요청에 따라 클러스터의 노드를 추가하거나 제거합니다.\n만약 리소스 부족으로 인해 스케줄링 대기 상태의 Pod가 존재하는 경우 Cluster AutoScaler가 노드를 추가합니다.\n추가 시 설정한 Min, Max 값을 넘어가지 않도록 구성 할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1XDum_t6J_lEt88o0X776XUxCHB-Ry_rW\"></p>\n<p>먼저 AutoScaler를 설정하면 대기 상태의 Pod을 주기적으로 확인합니다.\n클러스터 리소스가 부족하면서 사용자가 정의한 최대 노드 수에 도달하지 않은 경우 노드 프로비저닝을 요청합니다.\n노드가 추가되면 스케줄러에 의해 대기 상태의 Pod들이 새로운 노드로 할당됩니다.</p>\n<p>노드를 축소하는 프로세스는 사용자가 정의한 메트릭에 의해 시작됩니다.\n예를 들어 CPU Utilization이 50% 이하로 설정했다고 가정해보겠습니다.\nCluster AutoScaler는 삭제할 노드에서 실행 중인 Pod를 다른 노드로 안전하게 이동시킬 수 있는지 확인합니다.\n이때 Pod가 로컬 스토리지를 사용하고 있었다면 데이터 유실이 발생할 수 있으니 <strong>PV 사용</strong>을 권장합니다.\n이러한 확인 프로세스를 노드 또는 Pod 단위로 수행하고 Pod이 모두 이동하게 되면 노드를 제거합니다.</p>\n<br>\n<h2 id=\"eks-autoscaler\" style=\"position:relative;\"><a href=\"#eks-autoscaler\" aria-label=\"eks autoscaler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EKS AutoScaler</h2>\n<p>EKS의 AutoScaler는 AWS의 Auto Scaling Group을 활용하고 있습니다.\nASG는 주기적으로 현재 상태를 확인하고 <strong>Desired State</strong>로 변화하는 방식으로 동작합니다.\n사용자는 클러스터 노드 수를 제한하는 Min, Max 값을 지정할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1qZRhnghSiYRTzKTFJat2594-mv3hdPKS\"></p>\n<p>위와 같이 목적에 따라 여러 종류의 ASG를 설정하고 서로 다른 <strong>AutoScaling Policy</strong>를 적용할 수 있습니다.\n<strong>Spot Instance Group</strong>을 설정하면 저렴하지만 입찰 가격에 의해 언제든지 인스턴스가 내려갈 수 있습니다.\n하지만 EKS의 <strong>Spot Interrupt Handler (DeamonSet)</strong> 에 의해 정상적으로 실행 중인 Pod들을 재배치할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1jErnWXOdrtMQU0o1Aa504yZGMqSy8dbf\"></p>\n<p>그리고 위 그림과 같이 앞서 설정한 Cluster AutoScaler에 의해 새로운 Spot Instance가 추가됩니다.\n분석용 클러스터 같은 경우, 주말과 야간 시간에 사용량이 낮다는 사실을 이미 알고 있기 때문에\n<strong>CloudWatch Scheduled Policy</strong>를 통해 노드를 축소하면 비용을 절감할 수 있습니다.</p>\n<br>\n<h2 id=\"eks-autoscaler-설정\" style=\"position:relative;\"><a href=\"#eks-autoscaler-%EC%84%A4%EC%A0%95\" aria-label=\"eks autoscaler 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EKS AutoScaler 설정</h2>\n<p>먼저 EKS에 ASG 권한을 가지는 IAM Role을 만들어서 Worker Node 보안 그룹에 추가합니다.\n다음으로 ASG 그룹 태그를 설정하고 yaml 파일을 클러스터에 배포합니다.\n자세한 내용은 <a href=\"https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/cluster-autoscaler.html\">공식 문서</a>를 통해 진행하실 수 있습니다.\n만약 Policy로 메모리 지표를 사용하고 싶다면 각 노드에 <strong>CloudWatch Agent</strong>를 배포해야 합니다.</p>\n<br>","excerpt":"오늘은 Kubernetes의 Cluster AutoScaling에 대해 정리해보려 합니다.\n그 다음 EKS…"}}}}]}},"pageContext":{"basePath":"","paginationPath":"","pageNumber":0,"humanPageNumber":1,"skip":0,"limit":7,"numberOfPages":14,"previousPagePath":"","nextPagePath":"/2"}}}