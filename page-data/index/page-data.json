{"componentChunkName":"component---src-templates-posts-js","path":"/","result":{"data":{"allContentfulPost":{"edges":[{"node":{"title":"Pandas 2.0의 Copy-on-Write에 대하여","id":"ef1e9cc8-27ee-57ae-acf6-96d41704b9a0","slug":"pandas-2-0-copy-on-write","publishDate":"December 24, 2023","heroImage":{"title":"cover-dataengineering","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&q=50&fm=webp 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&q=50&fm=webp 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(min-width: 1600px) 1600px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&fl=progressive&q=50&fm=jpg 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&fl=progressive&q=50&fm=jpg 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"}},"layout":"constrained","width":1800,"height":1200,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgb/xAAcEAACAgMBAQAAAAAAAAAAAAAAAQIREiExYeH/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDK1DF0vgtxW9EylQu8nTotmo+gHfAEP//Z"}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":7,"html":"<p>Pandas 2.0 버전부터 <code class=\"language-text\">Copy-on-Write (CoW)</code>가 추가되었으며 3.0 버전부터 기본 값이 활성화로 변경됩니다. 이번 글에서는 Pandas Copy-on-Write가 Pandas가 가진 문제를 어떻게 해결하는지에 대해 알아보겠습니다.</p>\n<ul>\n<li><a href=\"https://swalloow.github.io/pandas-2-0-copy-on-write/#pandas-dataframe\">Pandas DataFrame</a></li>\n<li><a href=\"https://swalloow.github.io/pandas-2-0-copy-on-write/#pandas-settingwithcopywarning\">Pandas SettingWithCopyWarning</a></li>\n<li><a href=\"https://swalloow.github.io/pandas-2-0-copy-on-write/#pandas-copy-on-write\">Pandas Copy-on-Write</a></li>\n<li><a href=\"https://swalloow.github.io/pandas-2-0-copy-on-write/#pandas-copy-on-write-mode\">Pandas Copy-on-Write Mode</a></li>\n</ul>\n<br>\n<h2 id=\"pandas-dataframe\" style=\"position:relative;\"><a href=\"#pandas-dataframe\" aria-label=\"pandas dataframe permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pandas DataFrame</h2>\n<p>Pandas CoW에 대해 알아보기 이전에 먼저 DataFrame의 내부 구조에 대한 이해가 필요합니다.<br> <code class=\"language-text\">DataFrame</code>은 Pandas의 행, 열 기반 2차원 데이터 구조입니다.<br>\n초기에 Pandas는 아주 느린 컬럼 기반 연산을 빠르게 처리하기 위해 <code class=\"language-text\">BlockManager</code>를 추가했습니다.</p>\n<p><strong>BlockManager</strong><br>\nBlockManager는 numpy array로 저장된 데이터를 참조하는 블록을 관리하는 역할을 합니다.<br>\n아래 코드를 통해 자세히 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df <span class=\"token operator\">=</span> pd<span class=\"token punctuation\">.</span>DataFrame<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">)</span>\n\n   c1 c2  c3\n<span class=\"token number\">0</span>   <span class=\"token number\">1</span>  a  <span class=\"token number\">10</span>\n<span class=\"token number\">1</span>   <span class=\"token number\">2</span>  b  <span class=\"token number\">20</span>\n<span class=\"token number\">2</span>   <span class=\"token number\">3</span>  c  <span class=\"token number\">30</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">.</span>_data<span class=\"token punctuation\">)</span>\n\nBlockManager\nItems<span class=\"token punctuation\">:</span> Index<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'c1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c3'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span><span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span>\nAxis <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> RangeIndex<span class=\"token punctuation\">(</span>start<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> stop<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> step<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token builtin\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> int64\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token builtin\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> <span class=\"token builtin\">object</span></code></pre></div>\n<p>DataFrame을 생성하고 internal API를 통해 BlockManager 구조에 접근할 수 있습니다.<br>\n위 예시에서는 2개의 블록이 존재하며 그 중 int 타입을 가지는 <code class=\"language-text\">c1</code>, <code class=\"language-text\">c3</code>는 하나의 블록으로 통합되어 있습니다. 이처럼 BlockManager는 <strong>메모리 최적화와 효율적인 데이터 접근을 위해 동일한 타입을 하나의 블록으로 통합</strong>하여 관리합니다. 이번에는 동일한 타입을 가지는 <code class=\"language-text\">c4</code> 컬럼을 추가하고 다시 확인해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df<span class=\"token punctuation\">[</span><span class=\"token string\">'c4'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span><span class=\"token number\">300</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">.</span>_data<span class=\"token punctuation\">)</span>\n\nBlockManager\nItems<span class=\"token punctuation\">:</span> Index<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'c1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c4'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span><span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span>\nAxis <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> RangeIndex<span class=\"token punctuation\">(</span>start<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> stop<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> step<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token builtin\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> int64\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token builtin\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> <span class=\"token builtin\">object</span>\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token builtin\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> int64</code></pre></div>\n<p>이번에는 새로운 블록이 추가된 것을 확인할 수 있습니다.<br>\n<strong>BlockManager는 새로운 블록이 추가될때마다 동일한 타입의 블록을 통합하지 않습니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df<span class=\"token punctuation\">.</span>_data<span class=\"token punctuation\">.</span>consolidate<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nBlockManager\nItems<span class=\"token punctuation\">:</span> Index<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token string\">'c1'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c2'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c3'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'c4'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dtype<span class=\"token operator\">=</span><span class=\"token string\">'object'</span><span class=\"token punctuation\">)</span>\nAxis <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> RangeIndex<span class=\"token punctuation\">(</span>start<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> stop<span class=\"token operator\">=</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span> step<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> int64\nNumpyBlock<span class=\"token punctuation\">:</span> <span class=\"token builtin\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> x <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> dtype<span class=\"token punctuation\">:</span> <span class=\"token builtin\">object</span></code></pre></div>\n<p>DataFrame 연산이 실행되기 직전에 <code class=\"language-text\">consolidate()</code> 메서드를 통해 자동으로 통합합니다.<br>\n구체적으로는 블록 통합이 연산에 유리한 경우에만 블록 통합이 이루어집니다.</p>\n<p><br><br></p>\n<h2 id=\"pandas-settingwithcopywarning\" style=\"position:relative;\"><a href=\"#pandas-settingwithcopywarning\" aria-label=\"pandas settingwithcopywarning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pandas SettingWithCopyWarning</h2>\n<p>앞서 Pandas가 BlockManager를 통해 어떻게 블록을 관리하는지 알아보았습니다.<br>\n이번에는 CoW에서 해결하고자 하는 <code class=\"language-text\">SettingWithCopyWarning</code> 문제에 대해 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> pandas <span class=\"token keyword\">as</span> pd\n\ndf <span class=\"token operator\">=</span> pd<span class=\"token punctuation\">.</span>DataFrame<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">)</span>\n\n   student_id grade\n<span class=\"token number\">0</span>           <span class=\"token number\">1</span>     A\n<span class=\"token number\">1</span>           <span class=\"token number\">2</span>     C\n<span class=\"token number\">2</span>           <span class=\"token number\">3</span>     D</code></pre></div>\n<p>위와 같은 DataFrame에서 첫 번째 행의 <code class=\"language-text\">grade</code> 값을 E로 변경해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">grades <span class=\"token operator\">=</span> df<span class=\"token punctuation\">[</span><span class=\"token string\">\"grade\"</span><span class=\"token punctuation\">]</span>\ngrades<span class=\"token punctuation\">.</span>iloc<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"E\"</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">)</span>\n\n   student_id grade\n<span class=\"token number\">0</span>           <span class=\"token number\">1</span>     E\n<span class=\"token number\">1</span>           <span class=\"token number\">2</span>     C\n<span class=\"token number\">2</span>           <span class=\"token number\">3</span>     D\n\nSettingWithCopyWarning<span class=\"token punctuation\">:</span> \nA value <span class=\"token keyword\">is</span> trying to be <span class=\"token builtin\">set</span> on a copy of a <span class=\"token builtin\">slice</span> <span class=\"token keyword\">from</span> a DataFrame</code></pre></div>\n<p>코드만 보면 <code class=\"language-text\">grade</code> 변수에만 변경내용이 적용된 것처럼 보입니다.<br>\n하지만 실제로는 <code class=\"language-text\">df</code> 내용도 변경되어 있으며 <code class=\"language-text\">SettingWithCopyWarning</code> 경고 문구가 나타납니다.\n<code class=\"language-text\">ChainedIndexing</code>을 사용한 다른 예시도 확인해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df<span class=\"token punctuation\">[</span>df<span class=\"token punctuation\">[</span><span class=\"token string\">\"student_id\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"grades\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"F\"</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">)</span>\n\n   student_id grade\n<span class=\"token number\">0</span>           <span class=\"token number\">1</span>     E\n<span class=\"token number\">1</span>           <span class=\"token number\">2</span>     C\n<span class=\"token number\">2</span>           <span class=\"token number\">3</span>     D</code></pre></div>\n<p>이번에도 <code class=\"language-text\">SettingWithCopyWarning</code> 경고 문구가 나타나며 <code class=\"language-text\">df</code>에는 어떠한 변화도 없는 것을 확인할 수 있습니다.\n이러한 문제가 발생하는 <strong>원인은 Pandas, Numpy가 내부적으로 view 또는 copy를 반환하는 방식</strong>에서 찾아볼 수 있습니다.</p>\n<p><strong>Views and Copies</strong><br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n\norigin <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\nview <span class=\"token operator\">=</span> origin<span class=\"token punctuation\">.</span>view<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ncopy <span class=\"token operator\">=</span> origin<span class=\"token punctuation\">.</span>copy<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\narr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>origin<span class=\"token punctuation\">)</span>\narray<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>view<span class=\"token punctuation\">)</span>\narray<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>copy<span class=\"token punctuation\">)</span>\narray<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 코드 결과를 보면 <code class=\"language-text\">origin</code>, <code class=\"language-text\">view</code>는 변경된 값으로 반영되어 있지만 <code class=\"language-text\">copy</code>는 반영안되어 있는 것을 확인할 수 있습니다. <strong>view는 자체적으로 데이터가 없는 numpy 배열</strong> 입니다. 반면에 <strong>copy는 원본 배열의 요소를 새 배열에 복사하여 전체 복사본의 데이터</strong>를 가지고 있습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1k84OBHC_yWsft7SawKk8SlGbomNsbRMC\" alt=\"view-copy\"></p>\n<p>이처럼 view, copy에 따라 원본 객체인지 아닌지 달라지며 이는 일관된 동작을 보장하지 못하게 됩니다.<br>\n결국 <code class=\"language-text\">SettingWithCopyWarning</code>은 코드에서 사용자가 의도하지 않은 동작이 발생할 가능성이 있음을 경고하는 warning 입니다. 이 문제를 해결하기 위해 Pandas 2.0에 <code class=\"language-text\">Copy-on-Write</code>가 추가되었습니다.</p>\n<p><br><br></p>\n<h2 id=\"pandas-copy-on-write\" style=\"position:relative;\"><a href=\"#pandas-copy-on-write\" aria-label=\"pandas copy on write permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pandas Copy-on-Write</h2>\n<p>Pandas Copy-on-Write는 <strong>다른 DataFrame으로부터 생성된 모든 DataFrame이 항상 복사본으로 동작하도록 보장</strong>합니다. 다시 말해, 더 이상 단일 연산으로 두 가지 이상의 객체가 수정될 수 없습니다. (ex. 처음 예시에서 grade만 변경되고 df는 변경되지 않음)</p>\n<p>이를 구현하기 위한 가장 쉬운 방법은 항상 데이터를 복사하는 방법입니다.<br>\n하지만 적용 시 성능이 크게 떨어지기 때문에 다른 방식을 적용해야 했습니다.</p>\n<p><strong>BlockValuesRefs</strong><br>\n불필요한 복사를 방지하려면 복사를 트리거할 시기를 정확히 알아야 합니다.<br>\n결국 DataFrame 데이터가 다른 DataFrame과 공유되는 경우에만 복사를 트리거해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df <span class=\"token operator\">=</span> pd<span class=\"token punctuation\">.</span>DataFrame<span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\ndf2 <span class=\"token operator\">=</span> df<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>위 코드에서는 <code class=\"language-text\">df</code>와 df의 view 객체인 <code class=\"language-text\">df2</code>를 생성합니다.<br>\n현재 <code class=\"language-text\">df</code>와 <code class=\"language-text\">df2</code>는 동일한 numpy 배열을 참조하고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df<span class=\"token punctuation\">.</span>iloc<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span></code></pre></div>\n<p>코드를 통해 둘 중 하나가 수정되는 경우, 복사가 트리거됩니다.<br>\n이 때 다른 Pandas 객체가 참조하고 있는지를 추적해야 합니다.<br>\n이를 위해 <code class=\"language-text\">BlockValuesRefs</code>가 추가되었습니다.</p>\n<p><span\n        class=\"gatsby-resp-image-wrapper\"\n        style=\"position: relative; display: block; ; max-width: 650px; margin-left: auto; margin-right: auto;\"\n      >\n        <span\n          class=\"gatsby-resp-image-background-image\"\n          style=\"padding-bottom: 29.48453608247423%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAMCAAAAAA1qKCRAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAB3RJTUUH6AEUBzIcKObEjAAAAJBJREFUGNOd0UELgjAch2G///eJTkEgHcVL1mjIZNOWazq11GDNtekxldV7+jEe+B/mace8fyEGjlA8neBjbB2SYxAOGHJ+xtNDz0y5+oItb4QGMSHoZAWDoW4GpfP501GAfHgZZ3e973dAsnmIaI3TJO5ttNhsD90CpNJE07ctk+JWvRZgWZjKaSu7q99/5gMaJ9RINcOn7wAAABJ0RVh0ZXhpZjpFeGlmT2Zmc2V0ADc4ydR7JwAAABh0RVh0ZXhpZjpQaXhlbFhEaW1lbnNpb24AOTcwB2CHEgAAABh0RVh0ZXhpZjpQaXhlbFlEaW1lbnNpb24AMjg2+MEwfwAAAFx0RVh0ZXhpZjpVc2VyQ29tbWVudAA2NSwgODMsIDY3LCA3MywgNzMsIDAsIDAsIDAsIDgzLCA5OSwgMTE0LCAxMDEsIDEwMSwgMTEwLCAxMTUsIDEwNCwgMTExLCAxMTZAuB9yAAAAKHRFWHRpY2M6Y29weXJpZ2h0AENvcHlyaWdodCBBcHBsZSBJbmMuLCAyMDIzk7OPCgAAABd0RVh0aWNjOmRlc2NyaXB0aW9uAERpc3BsYXkXG5W4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n        >\n          <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"ref1\"\n        title=\"\"\n        src=\"https://images.ctfassets.net/tushy4jlcik7/2D9OCQfiqBrPnFVvYCKhpd/dc7eedf889af33d58efa757176b0e380/ref1.png\"\n        srcset=\"https://images.ctfassets.net/tushy4jlcik7/2D9OCQfiqBrPnFVvYCKhpd/dc7eedf889af33d58efa757176b0e380/ref1.png?w=243 243w,\nhttps://images.ctfassets.net/tushy4jlcik7/2D9OCQfiqBrPnFVvYCKhpd/dc7eedf889af33d58efa757176b0e380/ref1.png?w=485 485w,\nhttps://images.ctfassets.net/tushy4jlcik7/2D9OCQfiqBrPnFVvYCKhpd/dc7eedf889af33d58efa757176b0e380/ref1.png?w=970 970w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        loading=\"lazy\"\n      />\n        </span>\n      </span></p>\n<p><code class=\"language-text\">BlockValuesRefs</code>는 numpy 배열을 감싸고 이 참조를 내부적으로 저장하는 블록을 가리키는 <code class=\"language-text\">weakref</code>를 생성합니다.\n위의 예시와 같이 동일한 타입의 <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code> 컬럼은 BlockManager를 통해 하나의 블록에 존재합니다.\n그리고 블록에 대해 <code class=\"language-text\">weakref</code>를 가지는 Block Reference Tracker가 추가됩니다.<br>\n이제 다음 예시에서 새로운 블록을 추가해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df2 <span class=\"token operator\">=</span> df<span class=\"token punctuation\">.</span>reset_index<span class=\"token punctuation\">(</span>drop<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=17yEuS5fK1OIsepinstkOMpxkbx36Wi3L\" alt=\"ref2\"></p>\n<p><code class=\"language-text\">BlockValuesRefs</code>는 이제 <code class=\"language-text\">df</code>를 위한 블록과 <code class=\"language-text\">df2</code>를 위해 새로 생성된 블록을 가리킵니다.\n이를 통해 동일한 메모리를 가리키는 모든 DataFrame을 항상 인식할 수 있습니다.\n동일한 numpy 배열을 가리키는 블록이 몇 개 남아 있는지 참조 추적 객체를 통해 알아낼 수 있습니다.\n이러한 과정을 통해 <strong>둘 중 하나가 내부에서 수정되면 내부적으로 복사본을 트리거</strong>할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df2<span class=\"token punctuation\">.</span>iloc<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span></code></pre></div>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1kzXavfld6ZqUbCiY0BTMDDqXVG01A5Rc\" alt=\"ref3\"></p>\n<p>이제 <code class=\"language-text\">df2</code>의 블록은 전체 복사를 통해 복사되어 자체 데이터와 <code class=\"language-text\">BlockValuesRefs</code>가 있는 새로운 블록을 생성합니다. <code class=\"language-text\">df</code>와 <code class=\"language-text\">df2</code>는 더 이상 메모리를 공유하지 않습니다.<br>\n이해를 위해 몇 가지 상황을 더 살펴보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\ndf2<span class=\"token punctuation\">.</span>iloc<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span></code></pre></div>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1ovkD6IBlBw-yYhmcrvvLy3p6bvyipIPZ\" alt=\"ref4\"></p>\n<p>이 경우에는 <code class=\"language-text\">df2</code>를 수정하기 전 <code class=\"language-text\">df</code>가 <code class=\"language-text\">None</code>이 됩니다.\n결국 <code class=\"language-text\">df</code> <code class=\"language-text\">BlockValuesRefs</code>의 <code class=\"language-text\">weakref</code>는 None으로 평가되며, 이를 통해 복사를 실행하지 않아도 <code class=\"language-text\">df2</code>를 수정할 수 있습니다.\n마지막으로 <code class=\"language-text\">BlockValuesRefs</code> 객체는 복사를 트리거하지 않고 하나의 DataFrame만 가리키면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df2 <span class=\"token operator\">=</span> df<span class=\"token punctuation\">.</span>copy<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1_YPv-Y5ovBA4DN526bCnrZ9nptWRi2Ia\" alt=\"ref5\"></p>\n<p><code class=\"language-text\">copy</code>를 실행하는 경우는 간단합니다. DataFrame <code class=\"language-text\">df2</code>에 대한 새로운 <code class=\"language-text\">BlockValuesRefs</code>가 즉시 생성되며 데이터를 공유하지 않습니다.</p>\n<br>\n<p><strong>Optimizing inplace copies</strong><br>\n앞서 복사를 트리거하는 시점에 대해 알아보았습니다.<br>\n이번에는 복사본을 최대한 효율적으로 생성하는 방법에 대해 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df<span class=\"token punctuation\">.</span>iloc<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">100</span></code></pre></div>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1tCBFUcgljXx7Qmw-7r1w6XyYOtJljhdg\" alt=\"ref6\"></p>\n<p>위 예시는 DataFrame에 n개의 정수 컬럼이 있으며 모두 하나의 블록으로 통합되어 있습니다.\n다른 블록에서도 DataFrame을 참조하고 있기 때문에 하나의 값을 수정하기 위해 전체 블록을 복사해야 하는 상황입니다.\n이 방식은 위 그림과 같이 복사할 필요가 없는 n-1개의 컬럼을 복사해야 합니다.\nCoW에서는 이러한 상황을 최적화하기 위해 <code class=\"language-text\">Block Splitting</code>을 추가했습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1DEWdc4QgzGydTtopihYCiqSpfK63y0LU\" alt=\"\"></p>\n<p>위 그림과 같이 <code class=\"language-text\">Block Splitting</code>을 통해 분할되어 내부적으로 첫 번째 컬럼만 복사됩니다.\n다른 모든 컬럼은 이전 배열의 view로 간주되며 새로운 블록은 다른 열과 참조를 공유하지 않습니다.\n이전 블록은 view일 뿐이므로 그대로 다른 객체와 참조를 공유합니다.\n<strong>이 방식은 불필요한 복사를 방지할 수 있지만 이전 블록에 대한 정보에 새로운 블록까지 추가하므로 더 많은 메모리를 사용한다는 단점</strong>이 있습니다.</p>\n<p><br><br></p>\n<h2 id=\"pandas-copy-on-write-mode\" style=\"position:relative;\"><a href=\"#pandas-copy-on-write-mode\" aria-label=\"pandas copy on write mode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pandas Copy-on-Write Mode</h2>\n<p>Pandas CoW를 통해 <strong>복사에 대한 지연, 최적화를 통해 빠른 성능</strong>을 얻을 수 있으며\n<strong>DataFrame의 일관된 동작을 보장</strong>할 수 있습니다.\n2.0 버전의 경우, 간단한 설정만 추가하면 <code class=\"language-text\">Copy-on-Write</code> 모드를 사용할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">pd<span class=\"token punctuation\">.</span>options<span class=\"token punctuation\">.</span>mode<span class=\"token punctuation\">.</span>copy_on_write <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span></code></pre></div>\n<p>간단한 체이닝 연산을 통해 수행 시간의 차이를 확인해보면 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token operator\">%</span><span class=\"token operator\">%</span>timeit\n<span class=\"token punctuation\">(</span>\n    df<span class=\"token punctuation\">.</span>rename<span class=\"token punctuation\">(</span>columns<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"col_1\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"new_index\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>assign<span class=\"token punctuation\">(</span>sum_val<span class=\"token operator\">=</span>df<span class=\"token punctuation\">[</span><span class=\"token string\">\"col_1\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> df<span class=\"token punctuation\">[</span><span class=\"token string\">\"col_2\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>drop<span class=\"token punctuation\">(</span>columns<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"col_10\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"col_20\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>astype<span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"col_5\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"int32\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>reset_index<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">.</span>set_index<span class=\"token punctuation\">(</span><span class=\"token string\">\"new_index\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># without CoW</span>\n<span class=\"token number\">2.45</span> s ± <span class=\"token number\">293</span> ms per loop <span class=\"token punctuation\">(</span>mean ± std<span class=\"token punctuation\">.</span> dev<span class=\"token punctuation\">.</span> of <span class=\"token number\">7</span> runs<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> loop each<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># with CoW</span>\n<span class=\"token number\">13.7</span> ms ± <span class=\"token number\">286</span> µs per loop <span class=\"token punctuation\">(</span>mean ± std<span class=\"token punctuation\">.</span> dev<span class=\"token punctuation\">.</span> of <span class=\"token number\">7</span> runs<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span> loops each<span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 예시에서는 대략 200배 정도 개선되었지만 연산에 따라 결과는 다를 수 있습니다.<br>\n특히 <code class=\"language-text\">drop(axis=1)</code>, <code class=\"language-text\">rename()</code>과 같은 연산에서 큰 성능 향상을 확인하실 수 있습니다.</p>\n<p><br><br></p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://realpython.com/pandas-settingwithcopywarning/\">https://realpython.com/pandas-settingwithcopywarning/</a></li>\n<li><a href=\"https://pandas.pydata.org/docs/user_guide/copy_on_write.html\">https://pandas.pydata.org/docs/user_guide/copy_on_write.html</a></li>\n<li><a href=\"https://pandas.pydata.org/pdeps/0007-copy-on-write.html\">https://pandas.pydata.org/pdeps/0007-copy-on-write.html</a></li>\n<li><a href=\"https://phofl.github.io/cow-deep-dive.html\">https://phofl.github.io/cow-deep-dive.html</a></li>\n</ul>","excerpt":"Pandas 2.0 버전부터 가 추가되었으며 3.0 버전부터 기본 값이 활성화로 변경됩니다. 이번 글에서는 Pandas Copy-on-Write…"}}}},{"node":{"title":"Spark on Kubernetes: 커스텀 스케줄러 (2)","id":"8d6b9e00-f4f6-5624-b75c-fabb15be093f","slug":"spark-on-kubernetes-scheduler-2","publishDate":"December 10, 2023","heroImage":{"title":"cover-dataengineering","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&q=50&fm=webp 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&q=50&fm=webp 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(min-width: 1600px) 1600px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&fl=progressive&q=50&fm=jpg 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&fl=progressive&q=50&fm=jpg 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"}},"layout":"constrained","width":1800,"height":1200,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgb/xAAcEAACAgMBAQAAAAAAAAAAAAAAAQIREiExYeH/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDK1DF0vgtxW9EylQu8nTotmo+gHfAEP//Z"}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":5,"html":"<p>Spark 3.4 버전부터 Customized K8S Scheduler 기능이 GA 되었습니다 👏🏻<br>\n오늘은 <a href=\"https://swalloow.github.io/spark-on-kubernetes-scheduler/\">지난 글</a>에 이어 가장 많이 사용하는 Volcano, Yunikorn 스케줄러에 대해 알아보겠습니다.</p>\n<br>\n<p>3.4 버전 기준으로 Spark에서는 Volcano, Yunikorn 두 가지 커스텀 스케줄러를 공식적으로 지원합니다. 두 가지 오픈소스 모두 네이티브 환경에서 배치 처리를 지원하기 위한 프로젝트이며 최신 버전 기준으로 모두 유사한 기능을 지원하고 있습니다. 먼저 Volcano 부터 살펴보겠습니다.</p>\n<br>\n<h2 id=\"volcano\" style=\"position:relative;\"><a href=\"#volcano\" aria-label=\"volcano permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Volcano</h2>\n<p>초기의 Volcano는 <a href=\"https://github.com/kubernetes-retired/kube-batch\">kube-batch</a> 프로젝트 기반으로 구성되었으나 <strong>1.8 버전부터 쿠버네티스 스케줄러 플러그인 방식을 지원</strong>하게 되었습니다. 스케줄러 플러그인 기반으로 구성한 커스텀 스케줄러는 기본 스케줄러와 호환 가능하며 버전 업데이트 영향도 적게 받는 장점이 있습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1ok4Vrmy6CJ3pML9-Bw1qIytZ9gFGJtu-\" alt=\"volcano\"></p>\n<p>Volcano의 주요 컴포넌트는 다음과 같습니다.</p>\n<ul>\n<li><strong>Scheduler</strong>: 여러 스케줄링 알고리즘을 거쳐 가장 적합한 노드에 작업을 할당합니다.</li>\n<li><strong>ControllerManager</strong>: CRD (Queue, PodGroup, VCJob)의 lifecycle을 관리합니다.</li>\n<li><strong>Admission</strong>: CRD API에 대한 유효성 검사를 담당합니다.</li>\n</ul>\n<p>PodGroup을 통해 그룹 단위의 스케줄링이 가능하며, 하나의 Queue에는 여러 개의 PodGroup이 할당될 수 있습니다. 각 PodGroup은 status를 가지고 있어 Pending, Running 등의 상태가 관리됩니다.</p>\n<br>\n<p>스케줄링이 실행되는 워크플로우는 다음과 같습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1yLnnef5C-NesyyK66pOxf_c8AItA4k2J\" alt=\"volscheduler\"></p>\n<ul>\n<li>client가 제출한 작업을 watch하고 캐싱합니다.</li>\n<li>session을 새로 생성하고 스케줄링 사이클을 시작합니다.</li>\n<li>캐시에 예약되지 않은 작업은 session의 대기열로 보냅니다.</li>\n<li>필요한 작업을 순회하면서 순서대로 스케줄링 단계를 실행하고 적합한 노드를 찾습니다.</li>\n<li>작업을 노드에 바인딩합니다.</li>\n<li>세션을 종료합니다.</li>\n</ul>\n<br>\n<p><strong>Volcano 적용 과정</strong><br>\nVolcano 적용을 위해 필요한 단계는 다음과 같습니다.</p>\n<ol>\n<li>Volcano 환경 및 리소스 배포</li>\n<li>Spark Volcano 이미지 빌드 및 배포</li>\n<li>Spark configuration 전달</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># Specify volcano scheduler and PodGroup template\n--conf spark.kubernetes.scheduler.name=volcano\n--conf spark.kubernetes.scheduler.volcano.podGroupTemplateFile=/path/to/podgroup-template.yaml\n# Specify driver/executor VolcanoFeatureStep\n--conf spark.kubernetes.driver.pod.featureSteps=org.apache.spark.deploy.k8s.features.VolcanoFeatureStep\n--conf spark.kubernetes.executor.pod.featureSteps=org.apache.spark.deploy.k8s.features.VolcanoFeatureStep</code></pre></div>\n<p><br><br></p>\n<h2 id=\"apache-yunikorn\" style=\"position:relative;\"><a href=\"#apache-yunikorn\" aria-label=\"apache yunikorn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Apache Yunikorn</h2>\n<p>Yunikorn은 Volcano보다 뒤늦게 시작된 Apache 프로젝트입니다.\n컨테이너 오케스트레이션을 위한 경량의 범용 스케줄러를 지향하고 있으며 대부분의 스케줄링 알고리즘도 지원하고 있습니다.\n또한 Volcano와 동일하게 스케줄러 플러그인 방식을 지원합니다. 추가로 Yunikorn은 조직 단위로 리소스 관리가 가능하도록 <strong>계층 구조의 큐를 지원</strong>합니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1ksyjijuS-rcasePNp0pqHwR8XTuF8v0F\" alt=\"yunikorn\"></p>\n<p>Yunikorn의 주요 컴포넌트는 다음과 같습니다.</p>\n<ul>\n<li><strong>Scheduler Interface</strong>: 다른 리소스 플랫폼(K8S, YARN)과 통신을 위한 인터페이스</li>\n<li><strong>Scheduler Core</strong>: 스케줄링 알고리즘 구현, 메트릭 수집, 컨테이너 할당 요청</li>\n<li><strong>Kubernetes Shim</strong>: 쿠버네티스와 통신을 담당, Pod를 특정 노드에 바인딩하는 역할</li>\n<li><strong>Admission Controller</strong>: mutation, validation hook을 담당</li>\n</ul>\n<p>Yunikorn은 Volcano와 달리 추가로 배포되는 CRD가 없습니다.<br>\n큐와 알고리즘 등 관련 설정은 모두 Yunikorn 배포에 포함됩니다.<br>\n간단한 Yunikorn 설정 파일 예시는 다음과 같습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">partitions</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> default\n  <span class=\"token key atrule\">nodesortpolicy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> binpacking\n  <span class=\"token key atrule\">queues</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> root\n      <span class=\"token key atrule\">submitacl</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'*'</span>\n      <span class=\"token key atrule\">properties</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">application.sort.policy</span><span class=\"token punctuation\">:</span> fifo\n        <span class=\"token key atrule\">application.sort.priority</span><span class=\"token punctuation\">:</span> disabled\n      <span class=\"token key atrule\">queues</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> prod\n          <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n            <span class=\"token key atrule\">guaranteed</span><span class=\"token punctuation\">:</span>\n              <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 300G\n              <span class=\"token key atrule\">vcore</span><span class=\"token punctuation\">:</span> <span class=\"token number\">30</span>\n            <span class=\"token key atrule\">max</span><span class=\"token punctuation\">:</span>\n              <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 600G\n              <span class=\"token key atrule\">vcore</span><span class=\"token punctuation\">:</span> <span class=\"token number\">60</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> stage\n          <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n            <span class=\"token key atrule\">guaranteed</span><span class=\"token punctuation\">:</span>\n              <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 100G\n              <span class=\"token key atrule\">vcore</span><span class=\"token punctuation\">:</span> <span class=\"token number\">10</span>\n            <span class=\"token key atrule\">max</span><span class=\"token punctuation\">:</span>\n              <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 200G\n              <span class=\"token key atrule\">vcore</span><span class=\"token punctuation\">:</span> <span class=\"token number\">200</span></code></pre></div>\n<p>위와 같이 prod, stage 등 여러 개의 큐를 계층형으로 생성할 수 있습니다.<br>\n스케줄링 정책은 크게 <strong>node sorting 단계와 application sorting 단계</strong>로 나누어집니다.<br>\ngang scheduling을 사용하는 경우, application sorting은 항상 fifo를 사용해야 합니다.</p>\n<p>Yunikorn에서 Gang Scheduling이 실행되는 단계는 다음과 같습니다.\n<img src=\"https://drive.google.com/uc?export=view&#x26;id=1E81nP3qq2D2IPMuPR13xkPVaBAmLy9u-\" alt=\"yunikorn-gang\"></p>\n<ul>\n<li>TaskGroup이 정의된 application을 submit 합니다.</li>\n<li>Shim이 application을 생성하고 이를 Core(Kube scheduler)에 전달합니다.</li>\n<li>Shim은 TaskGroup의 각 member에 대한 placeholder pod를 생성합니다. spark의 경우, member는 driver, executor가 될 수 있습니다.</li>\n<li>pod가 정상적으로 생성되고 나면 AllocationAsks로 처리되어 Core에 전달됩니다.</li>\n<li>placeholder는 Core를 통해 적절한 노드에 바인딩됩니다.</li>\n<li>이제 실제 pod가 AllocationAsk로 Core에 전달됩니다.</li>\n<li>실제 pod와 모든 placeholder pod가 스케줄링 완료된 이후 Shim은 실제 pod를 바인딩합니다.</li>\n</ul>\n<br>\n<p><strong>Yunikorn 적용 과정</strong><br>\nYunikorn 적용을 위해 필요한 단계는 다음과 같습니다.<br>\nYunikorn의 경우 annotation 설정을 사용합니다.</p>\n<ol>\n<li>Yunikorn 환경 및 설정 배포</li>\n<li>Spark configuration 전달</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">--conf spark.kubernetes.scheduler.name=yunikorn\n--conf spark.kubernetes.driver.label.queue=root.default\n--conf spark.kubernetes.executor.label.queue=root.default\n--conf spark.kubernetes.driver.annotation.yunikorn.apache.org/app-id={{APP_ID}}\n--conf spark.kubernetes.executor.annotation.yunikorn.apache.org/app-id={{APP_ID}}</code></pre></div>\n<p><br><br></p>\n<h2 id=\"volcano-vs-apache-yunikorn\" style=\"position:relative;\"><a href=\"#volcano-vs-apache-yunikorn\" aria-label=\"volcano vs apache yunikorn permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Volcano vs Apache Yunikorn</h2>\n<p>앞서 살펴 본 내용을 통해 각 스케줄러의 장단점을 정리해보면 다음과 같습니다.<br>\n모두 Helm 차트를 지원하므로 쉽게 구성할 수 있습니다.<br></p>\n<p><strong>Volcano</strong><br>\n장점: Kubeflow에 대한 지원<br>\n단점: spark 이미지 빌드, CRD 단위로 관리가 필요</p>\n<br>\n<p><strong>Yunikorn</strong><br>\n장점: 작업 상태를 확인할 수 있는 Web UI 지원<br>\n장점: 경량화되어 있으며 계층 구조의 큐를 지원<br>\n장점: 추가로 필요한 부분이 적어 운영이 편리<br>\n단점: 주요 설정은 모두 있으나 Volcano 대비 적은 옵션 지원</p>\n<p><br><br></p>\n<h2 id=\"운영을-하면서-마주칠-수-있는-부분들\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%9D%84-%ED%95%98%EB%A9%B4%EC%84%9C-%EB%A7%88%EC%A3%BC%EC%B9%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%B6%80%EB%B6%84%EB%93%A4\" aria-label=\"운영을 하면서 마주칠 수 있는 부분들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영을 하면서 마주칠 수 있는 부분들</h2>\n<p>다음은 적용한 이후에 운영을 하다보면 마주칠 수 있는 이슈 또는 고민을 정리해보았습니다.<br></p>\n<p><strong>placeholder 리소스 설정</strong><br>\napplication submit 시 placeholder에 할당할 리소스 사이즈 결정이 필요합니다.\nplaceholder를 작게 설정하면 리소스 확보가 안되어 스케줄링에 영향이 있을 수 있고 지나치게 크게 설정하면 실제로 여유가 있음에도 리소스 부족 현상 발생할 수 있습니다. <a href=\"https://github.com/GoogleCloudPlatform/spark-on-k8s-operator\">spark-on-k8s-operator</a>를 사용한다면 스케줄러에 따라 placeholder 사이즈를 결정하는 로직이 포함되어 있으니 편하게 적용이 가능합니다.</p>\n<p><strong>큐 사이즈 조정</strong><br>\n만약 큐의 리소스 제한보다 요청한 리소스가 크다면 application reject이 발생하여 실행이 불가능합니다. 또한 큐의 크기가 전체적으로 작은 경우, 신규 요청한 어플리케이션이 빈번하게 대기하는 상황도 발생할 수 있습니다. 스케줄러에서 Prometheus 메트릭을 제공하니 Grafana를 통해 모니터링 후 적절한 큐 사이즈로 설정하는 과정이 필요합니다.</p>\n<p><strong>Spark Dynamic Resource Allocation을 사용하는 경우</strong><br>\n큐에서 이미 실행 중인 application은 리소스 확장도 가능합니다.\n따라서 Spark의 Dynamic Resource Allocation을 많이 사용한다면 미리 설정해둔 제한을 크게 넘어갈 수도 있습니다. 이러한 경우, 큐를 사용하는 의미가 사라지게 됩니다.</p>\n<p><strong>Application Cleanup 관련</strong><br>\n상황에 따라 application이 accepted 또는 waiting 상태에서 계속 머무르는 이슈가 발생할 수 있습니다. 이처럼 placeholder가 할당되지 못하는 경우, 스케줄러에서 timeout 설정을 통해 실패 처리되어야 다음 작업이 원활하게 진행될 수 있습니다. 만약 좀비 상태로 placeholder가 남는다면 core에서 확인 후 GC를 통해 정리됩니다.</p>\n<p><br><br></p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>두 가지 스케줄러 모두 범용적으로 많이 사용되고 있어 운영 중인 환경에 따라 선택하시면 좋을 것 같습니다.<br>각 스케줄러에 대한 자세한 내용은 아래의 공식문서에서 찾아보실 수 있습니다!</p>\n<ul>\n<li><a href=\"https://yunikorn.apache.org/docs/\">https://yunikorn.apache.org/docs/</a></li>\n<li><a href=\"https://volcano.sh/en/\">https://volcano.sh/en/</a></li>\n</ul>","excerpt":"Spark 3.4 버전부터 Customized K8S Scheduler 기능이 GA…"}}}},{"node":{"title":"Spark on Kubernetes: 커스텀 스케줄러 (1)","id":"daa589cd-f055-5aef-94ee-0b0b8d1505a0","slug":"spark-on-kubernetes-scheduler","publishDate":"June 08, 2023","heroImage":{"title":"cover-dataengineering","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&q=50&fm=webp 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&q=50&fm=webp 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(min-width: 1600px) 1600px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&fl=progressive&q=50&fm=jpg 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&fl=progressive&q=50&fm=jpg 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"}},"layout":"constrained","width":1800,"height":1200,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgb/xAAcEAACAgMBAQAAAAAAAAAAAAAAAQIREiExYeH/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDK1DF0vgtxW9EylQu8nTotmo+gHfAEP//Z"}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":3,"html":"<p>Spark 3.4 버전부터 Customized K8S Scheduler 기능이 GA 되었습니다 👏🏻<br>\n그래서 오늘은 커스텀 스케줄러가 왜 필요하고 어떻게 적용할 수 있는지 정리해보려고 합니다.</p>\n<p><br><br></p>\n<h2 id=\"spark-kubernetes-scheduling\" style=\"position:relative;\"><a href=\"#spark-kubernetes-scheduling\" aria-label=\"spark kubernetes scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark Kubernetes Scheduling</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1Kwomj5BeazAYa72lEB4PQDcKUe46BizX\" alt=\"spark-k8s\"></p>\n<p>쿠버네티스 환경에서 spark-submit을 실행하면 pod가 실행되는 순서는 다음과 같습니다.</p>\n<ul>\n<li>spark-submit 명령어 실행</li>\n<li>Kube API를 통해 driver pod 생성</li>\n<li>driver pod → API Server에 executor 생성 요청</li>\n<li>Kube API를 통해 executor pod 생성</li>\n</ul>\n<p>위와 같이 driver가 executor를 관리함에 따라 동적으로 리소스를 확장할 수 있지만\ndriver가 생성되기 전까지 전체 executor에 필요한 리소스를 알 수 없다는 단점이 있습니다.\n이러한 이유로 클러스터 내에 리소스가 고갈된 상황에서 성능 문제가 발생할 수 있습니다.</p>\n<br>\n<p><strong>클러스터 내에 리소스가 고갈된 경우</strong><br>\n<img src=\"https://drive.google.com/uc?export=view&#x26;id=1pNKR_jMSjpHgJakbDiyJIETkKBoftIXe\" alt=\"allo1\"></p>\n<p>클러스터의 리소스 풀이 요청 받은 리소스보다 부족한 상황이라고 가정해보겠습니다.\n위 그림에서 녹색은 실제로 노드에 할당되어 running 중인 pod, 빨간색은 리소스가 부족으로 인해 pending 상태의 pod 입니다.</p>\n<p>각 앱은 리소스 경쟁에 의해 driver와 executor 1개씩 정상적으로 생성되어 3개의 앱이 실행 중인 상태입니다. 하지만 3개의 앱은 executor 리소스를 확보하지 못했기 때문에 작업을 완료할 수 없습니다. EKS 환경이라면 노드 리소스를 확보하더라도 VPC IP 고갈 문제로 인해 이러한 상황을 충분히 마주칠 수 있습니다.</p>\n<br>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1ErqVM9uKqc8WZO0-BNIRlBBA5DRsNeYS\" alt=\"allo2\"></p>\n<p>위와 같이 리소스 내에서 가능한 앱이 정상적으로 실행, 종료되고 나머지는 대기하는게 더 효율적이라고 볼 수 있습니다.\n쿠버네티스에서는 기본 스케줄러가 배치 작업에 최적화된 형태가 아니기 때문에 위와 같은 문제가 발생할 수 있습니다. 이를 해결하기 위해 <code class=\"language-text\">kube-batch</code>, <code class=\"language-text\">volcano</code>, <code class=\"language-text\">yunikorn</code> 등의 커스텀 배치 스케줄러가 개발되었습니다.</p>\n<p><br><br></p>\n<h2 id=\"spark-app-aware-scheduling\" style=\"position:relative;\"><a href=\"#spark-app-aware-scheduling\" aria-label=\"spark app aware scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark App-aware Scheduling</h2>\n<p>기본 스케줄러는 <code class=\"language-text\">filtering</code>, <code class=\"language-text\">scoring</code> 과정을 거쳐 pod가 실행될 최적의 노드를 찾습니다. 이 때 스케줄 단위는 pod 입니다. 반면 대용량 배치 작업에서는 동시에 수 백개의 pod가 생성되기도 합니다. 또한 동시에 여러 작업이 실행되기 때문에 우선순위, 조직 별 리소스 제한 등을 고려해서 안정적으로 작업을 마치기 위한 대기열이 필요합니다.</p>\n<p>커스텀 배치 스케줄러에서는 이를 해결하기 위해 <strong>앱 단위로 스케줄을 결정하는 App-aware 방식을 사용</strong>합니다. 뿐만 아니라 대용량 배치 작업을 위해 Job Ordering, Hierarchy Resource Queue, Node Sorting 단계에서 다양한 스케줄링 알고리즘을 지원합니다.</p>\n<p><strong>Bin Packing</strong><br>\n<img src=\"https://drive.google.com/uc?export=view&#x26;id=10yt7Xf1w4pWqLf8Z0cYJQbA5BzUSX_--\" alt=\"binpack\"></p>\n<p>Node Sorting 단계를 예시로 들어보겠습니다.\n기본 스케줄러에서 driver, executor pod가 여러 노드에 고르게 분산하면 앱은 네트워크 지연, 셔플 시 원격에서 데이터를 가져와야 하는 상황이 발생합니다.</p>\n<p>이 때 테트리스처럼 <strong>Bin Packing 방식을 적용한다면 어플리케이션을 최대한 가깝게 할당</strong>할 수 있습니다. 클라우드 환경에서 이를 적용하면 노드 scale-in도 원활하게 수행할 수 있습니다.</p>\n<p><br><br></p>\n<h2 id=\"spark-gang-scheduling\" style=\"position:relative;\"><a href=\"#spark-gang-scheduling\" aria-label=\"spark gang scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark Gang Scheduling</h2>\n<p>앞서 리소스가 고갈된 상황의 경우, Gang Scheduling을 사용한다면 안정적으로 작업을 실행할 수 있습니다. 노드가 0대인 상황에서 앱이 제출되었다고 가정해보겠습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1zT9Y-cjE65n-H-WgVDefQ02oI0ZVCjWH\" alt=\"gang1\"></p>\n<p>위의 그림은 기본 스케줄러를 적용했을 때 모습입니다.<br>\n필요한 최소 리소스가 미리 정해져있으나 노드 생성까지 대기 시간이 발생합니다.</p>\n<ul>\n<li>driver 리소스 요청 → 1대 생성</li>\n<li>executor 리소스 요청 → 2대 생성</li>\n</ul>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1kGf51ivLYDgS8ZsuAIYEdNAAN643ze2r\" alt=\"gang2\"></p>\n<p>위의 그림은 gang 스케줄링을 적용했을 때 모습입니다.<br>\n한번에 필요한 리소스를 확보하여 대기 시간을 최소화합니다.</p>\n<ul>\n<li>driver 리소스 요청 → placeholder 리소스 요청 → 노드 3대 생성</li>\n<li>driver, executor pod 즉시 할당</li>\n</ul>\n<p>여기에서 placeholder pod은 아무 동작도 안하지만 미리 리소스를 확보하기 위해 존재하는 dummy pod 입니다. 만약 리소스를 확보하지 못하는 상황이라면 앱은 대기합니다.\n<strong>Gang Scheduling은 FIFO 큐와 함께 실행하여 리소스 경쟁으로 인한 교착상태에 빠지지 않도록</strong> 할 수 있습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1NwRgb5nl-b4hecA_PYxuNC59M_5irQbq\" alt=\"kubemark\"></p>\n<p>또한 동시 실행 Pod가 많을 수록 스케줄링 성능 향상을 기대할 수 있습니다. 위 그림은 Yunikorn에서 kubemark를 통해 벤치마크한 결과입니다. 회사 환경에서 spark 작업 시간을 기준으로 테스트했을 때도 성능 향상을 확인할 수 있었습니다.</p>\n<p>다음 글에서는 Spark 3.4 버전에서 공식적으로 지원하는 Volcano, Yunikorn에 대해 이어서 정리해보겠습니다.</p>\n<br>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://yunikorn.apache.org/docs/\">https://yunikorn.apache.org/docs/</a></li>\n<li><a href=\"https://blog.cloudera.com/spark-on-kubernetes-gang-scheduling-with-yunikorn/\">https://blog.cloudera.com/spark-on-kubernetes-gang-scheduling-with-yunikorn/</a></li>\n</ul>","excerpt":"Spark 3.4 버전부터 Customized K8S Scheduler 기능이 GA…"}}}},{"node":{"title":"베를린에서 2개월 살아남기","id":"ab300765-6809-53b6-a6cd-952c7dd3c976","slug":"berlin","publishDate":"May 10, 2023","heroImage":{"title":"cover-personal","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=350&h=207&q=50&fm=webp 350w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=700&h=413&q=50&fm=webp 700w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&q=50&fm=webp 1400w","sizes":"(min-width: 1400px) 1400px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=350&h=207&fl=progressive&q=50&fm=jpg 350w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=700&h=413&fl=progressive&q=50&fm=jpg 700w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&fl=progressive&q=50&fm=jpg 1400w","sizes":"(min-width: 1400px) 1400px, 100vw"}},"layout":"constrained","width":1800,"height":1062,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBv/EABoQAAIDAQEAAAAAAAAAAAAAAAMRAAECEiH/xAAVAQEBAAAAAAAAAAAAAAAAAAABA//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oADAMBAAIRAxEAPwDlAjvdNSiD5p35M8m2PbxaVKSQuy296alalC1EiIF//9k="}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":3,"html":"<p>우연히 회사에서 좋은 기회를 얻게 되어 독일에서 2개월 근무한 후기<br>\n베를린 생활부터 유럽의 개발 문화까지 그 동안 겪은 경험을 정리해보려 합니다.</p>\n<br>\n<h2 id=\"베를린-아파트\" style=\"position:relative;\"><a href=\"#%EB%B2%A0%EB%A5%BC%EB%A6%B0-%EC%95%84%ED%8C%8C%ED%8A%B8\" aria-label=\"베를린 아파트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>베를린 아파트</h2>\n<p>숙소가 정말 평이 좋고 실제로 시설도 좋은 아파트인데 엘리베이터가 없었다.\n여기는 그라운드 개념이 있어서 5층이 한국으로 치면 6층인데 다들 아무렇지 않게 걸어올라간다.\n빨래, 건조를 하려면 6층을 왕복 3번 다녀야 하는데 이게 제일 힘들었다.</p>\n<p>그리고 모든 문을 열쇠로 열어야 하는데 이게 정말 난감하다.\n최근에 열쇠를 들고 다녀본 기억이 없다보니 두고 다닐 수 있는데\n열쇠를 두고 오면 한화 약 20만원 정도의 벌금을 내야한다.\n열쇠 분실로 인한 사고 방지를 위해 문을 교체해버리기 때문에 저런 비용이 발생한다.\n개인적인 생각으로는 그냥 도어락을 도입하는게 나아보였다 🙏🏻</p>\n<br>\n<h2 id=\"베를린-교통과-생활\" style=\"position:relative;\"><a href=\"#%EB%B2%A0%EB%A5%BC%EB%A6%B0-%EA%B5%90%ED%86%B5%EA%B3%BC-%EC%83%9D%ED%99%9C\" aria-label=\"베를린 교통과 생활 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>베를린 교통과 생활</h2>\n<p>처음 도착하자마자 놀란건 일요일에 모든 마트, 식료품가게가 문을 닫는다는 것이다.\n만약을 위해 베를린 전체에서 세 군데 정도 대형마트만 문을 연다.\n결국 생활용품을 사기 위해 베를린 중앙역까지 갔는데 뉴스에서만 보던 그림을 볼 수 있었다.\n재난상황마냥 줄이 끝까지 이어져있고 마트 내부 물품은 다 털려있었다.\n그래도 독일은 국가가 통제하기 때문에 마트 물가가 정말 저렴하다.</p>\n<p>베를린 대중교통으로는 트램, 지하철, 버스를 제일 많이 탄다.\n종일권을 끊으면 모든 교통수단을 무제한으로 탈 수 있다.\n근데 이 보다 더 좋은 교통수단은 자전거다.\n자전거 도로가 너무 잘되어 있어서 대중교통 이용하는 것보다 시간이 빠를 때가 많다.\n도시 간 이동으로는 flixbus와 ICE 고속열차를 많이 이용한다.\n독일의 고속철은 워낙 악명 높아서 취소되는 일이 빈번하다 들었는데\n역시나 당일 오전 출발 5분 전에 ICE 열차 취소를 겪었다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1bQ-fcJEpPBuqhW7EMzENYWS_fRnrEbQO\" alt=\"berlin1\"></p>\n<p>오전 ICE 전체 지연으로 베를린 중앙역이 전쟁터가 된 모습, 환불을 받기 위해 전부 줄서있는 모습</p>\n<p>6시간 연착이라고 당당하게 설명하는데 사람들이 너무 당연하게 받아들여서 당황했다.<br>\n근데 더 놀라운 것은 환불 절차다.\n한국은 유럽과 같은 은행코드를 사용하지 않아 앱에서 환불 받을 수 없었다.\n방법은 DB 본사에 우편으로 직접 적어서 보내는 것 밖에 없다. 당연히 이메일도 불가능했다.</p>\n<br>\n<h2 id=\"베를린-음식\" style=\"position:relative;\"><a href=\"#%EB%B2%A0%EB%A5%BC%EB%A6%B0-%EC%9D%8C%EC%8B%9D\" aria-label=\"베를린 음식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>베를린 음식</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1eCZBp1oUw_pM1JPmDB5lNDunKB_VrABJ\" alt=\"berlin2\"></p>\n<p>베를린은 너무 다양한 인종이 살고 있어 전 세계 음식을 다 먹어볼 수 있다.<br>\n그 중에서 독일 음식은 흰색 소세지와 커리부어스트만 먹어보면 된다. 나머지는 별로였다.\n햄버거의 어원이 함부르크에서 나온 만큼 수제버거도 맛있는 곳이 많다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1-be935C_pyhBFXHbl2jPWYy1KPENzfJs\" alt=\"berlin3\"></p>\n<p>보통 해외에서 새벽에 다니면 위험한 경우가 많은데 베를린은 서울보다 더 밤새도록 노는 도시라 정말 안전하다.<br>\n오이스터 바에 가면 비싼 돈을 주고 굴을 먹을 수 있는데 비린내가 안나고 우유 맛이 난다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=19zETeYM4gEsYYv72beliY9ktshklSU27\" alt=\"berlin4\"></p>\n<p>때마침 베를린 빛 축제가 진행 중이어서 관광지에서 다양한 야경을 볼 수 있었다.</p>\n<br>\n<h2 id=\"베를린-개발-문화-스타트업\" style=\"position:relative;\"><a href=\"#%EB%B2%A0%EB%A5%BC%EB%A6%B0-%EA%B0%9C%EB%B0%9C-%EB%AC%B8%ED%99%94-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85\" aria-label=\"베를린 개발 문화 스타트업 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>베를린 개발 문화, 스타트업</h2>\n<p>유럽도 일하는 방식은 비슷했으나 한국과 비교했을 때 일을 디테일하게 한다고 느꼈다.\n예를 들면 RFC 문서를 정말 자세히 작성하고 오픈소스와 같은 플랫폼 운영 방식을 가지고 있었다.</p>\n<p>그리고 정서 상 한국은 정말 겸손한 반면 여기는 잘한 일이 생기면 자랑하고 모두가 축하하는 분위기였다.\n해외 감성으로 네트워킹, 파티도 자주 열린다.\n독일은 아프면 바로 병가를 15일까지 낼 수 있고 휴가가 25일이다.</p>\n<p>금요일에는 모두 일찍 퇴근하고 앞에서 맥주를 마신다.\n모든 과정을 경험해보니 절대 한국만큼의 개발 속도가 나올 수는 없겠다는 생각이 들었지만\n반대로 유럽에서 여유롭게 사는 법을 배운 것 같다.</p>\n<p>데이터 분야에서는 특별한 차이가 있는데 개인정보에 대한 사람들의 인식이다.\n한국에 있을 때도 많이 들어봤던 GDPR이라는 규정에 대해서도 알게 되었다.\n대부분 사용자들은 개인정보를 절대 서비스에 넘기려하지 않는다.</p>\n<p>그러다보니 데이터 기반의 서비스를 만드는 사람들은 정말 난감할 때가 많은데 개인화 추천이 가장 대표적이다.\n일단 사용자를 식별해야 개인화를 할텐데 여기는 개인을 정의하는 것부터가 어려운 문제다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=15fC9nRrxwNR9pGZSp7h3UnoUwUzSXPvD\" alt=\"berlin5\"></p>\n<p>베를린의 옛 건물을 내부만 리모델링해서 사용한 스타트업 공유 오피스도 방문했었다.<br>\n자동차 회사가 많은 나라답게 다양한 모빌리티 스타트업을 만날 수 있었다.<br>\n베를린에는 유럽 내의 스타트업이 많은 편인데 이 도시가 유럽에서 가장 글로벌하기 때문이다.<br>\n시골로 내려가면 기술에 대한 거부반응을 가진 사람이 많은 반면 베를린은 해외에서 온 이민자가 많다.\n그래서 독일어가 있음에도 영어를 정말 많이 사용한다.</p>\n<p>개발자 한정 2년만 근무하면 시민권도 쉽게 얻을 수 있다.\n대신 세금으로 절반을 가져간다 💸<br>\n이 말을 듣고 한국에서 살아야겠다는 생각이 들었다.</p>\n<p>인터넷이 정말 느려서 불편하다고 생각했는데 이 정도면 유럽에서 엄청 빠른 편이라고 한다.<br>\n하지만 스웨덴 스톡홀름에 가보니 독일 인터넷이 느리다는걸 확신할 수 있었다.</p>\n<br>\n<p>어쨋든 무사히 돌아와서 다행이라는 생각이 들었다.\n영어로 일하고 회의하는 것은 정말 많은 노력이 필요했다.<br>\n대신 유럽에서 근무하면 주말 동안 주변 국가 여행할 수 있다는 점이 큰 장점이다.<br>\n요즘 재택이 많아지다보니 해외에서 근무 가능한 회사들도 많이 생기고 있는데<br>\n만약 유럽에서 살고 싶다면 베를린에서 살아보는 것도 괜찮은 것 같다.</p>\n<br>","excerpt":"우연히 회사에서 좋은 기회를 얻게 되어 독일에서…"}}}},{"node":{"title":"MLOps 관련 책, 강의 리뷰 (DMLS, FSDL)","id":"8a70bf4b-6469-516d-9b3f-43f3fa109774","slug":"mlops-dmls-fsdl","publishDate":"September 13, 2022","heroImage":{"title":"cover-personal","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=350&h=207&q=50&fm=webp 350w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=700&h=413&q=50&fm=webp 700w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&q=50&fm=webp 1400w","sizes":"(min-width: 1400px) 1400px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=350&h=207&fl=progressive&q=50&fm=jpg 350w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=700&h=413&fl=progressive&q=50&fm=jpg 700w,\nhttps://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1400&h=826&fl=progressive&q=50&fm=jpg 1400w","sizes":"(min-width: 1400px) 1400px, 100vw"}},"layout":"constrained","width":1800,"height":1062,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAAMABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBv/EABoQAAIDAQEAAAAAAAAAAAAAAAMRAAECEiH/xAAVAQEBAAAAAAAAAAAAAAAAAAABA//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oADAMBAAIRAxEAPwDlAjvdNSiD5p35M8m2PbxaVKSQuy296alalC1EiIF//9k="}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/3ltdJp06NzCExAWz9OF8Ak/d8ca530c80e7c79a7bd7e4c396c0ae00/cover_personal.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":1,"html":"<p>MLOps는 다양한 지식과 컴포넌트를 다루고 있어 따로 공부하다보면 중요한 부분을 놓치고 도구에만 집착하게 되는 경우도 많습니다. 반면 알려진 책이나 강의를 들으니 퍼즐 조각들이 맞춰지는 것처럼 흩어져 있는 지식들이 하나로 정리되는 느낌을 받을 수 있었습니다.</p>\n<p>이 글에서는 MLOps 관련 자료 중 유명한 <strong>Full Stack Deep Learning</strong> 강의와 <strong>Designing Machine Learning Systems</strong> 책을 리뷰해보려 합니다.\nMLOps에 대해 관심있거나 시작하기 위해 자료를 찾는 분들에게 도움이 될 수 있을 것 같습니다.</p>\n<br>\n<h2 id=\"full-stack-deep-learning\" style=\"position:relative;\"><a href=\"#full-stack-deep-learning\" aria-label=\"full stack deep learning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Full Stack Deep Learning</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1zdLxqWwSlLAwxfI_YSvATPgnadHtxg3N\" alt=\"fsdl\"></p>\n<p>FSDL 강의는 MLOps 전반적인 주제를 모두 다루는 온라인 강의입니다.<br>\n아래 사이트 또는 유튜브에서 최신 강의를 볼 수 있습니다.<br>\n링크: <a href=\"https://fullstackdeeplearning.com/\">https://fullstackdeeplearning.com/</a></p>\n<p><strong>좋았던 점</strong><br>\n매년 강의의 내용이 최신 트렌드를 최대한 반영하기 위해 업데이트 되고 있으며 Lab이라는 실습 과정이 준비되어 있습니다. CoLab 환경에서 실습할 수 있도록 자료가 준비되어 있는데 특히 ML 테스트 챕터의 자료가 좋았습니다.<br>\n중간에 다양한 오픈소스나 도구들을 소개해주는데 직접 구축하는 경우에도 아이디어를 얻을 수 있어 유용했습니다.</p>\n<p><strong>아쉬운 점</strong><br>\n많은 내용을 다루다보니 특정 주제는 간단하게 이미지나 링크만 공유하고 넘어가는 경우가 있어 설명이 부족한 경우가 있습니다. 제대로 이해하려면 제공되는 학습 자료들을 모두 찾아서 봐야 했습니다.<br>\n절대 사용할 일이 없을 법한 초기 스타트업들의 SaaS를 소개할때가 있는데 광고를 받은게 아닌가 싶은 생각이 들었습니다.</p>\n<br>\n<h2 id=\"designing-machine-learning-systems\" style=\"position:relative;\"><a href=\"#designing-machine-learning-systems\" aria-label=\"designing machine learning systems permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Designing Machine Learning Systems</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1dgiLa6nKVdS_CzevNlvYxuvss45yWHIV\" alt=\"dmls\"></p>\n<p>DMLS 책은 스탠포드 MLOps 강의로 유명한 Chip Huyen 교수님이 최근에 출판한 책입니다.<br>\n아직 한글판은 없어 Oreilly Learning 또는 Amazon에서 받아볼 수 있습니다.</p>\n<p><strong>좋았던 점</strong><br>\nFSDL보다 더 구체적인 사례를 들어 전반적인 내용을 이해하기 쉽게 설명한다고 느꼈습니다. 특히 구조적으로 설명해주고 바로 실무에 적용할 수 있도록 여러 가이드라인을 제시해주는 부분이 많습니다.<br>\n여러 오픈소스나 도구에 대해서도 기능을 구체적으로 다루기보다 어떤 기준으로 선택해야 하는지를 설명합니다. 실제 프로덕션 환경에서 마주치는 문제들을 소개하고 어떻게 해결하는지에 대한 내용을 미국 빅테크 기업들의 사례를 통해 설명하는 부분이 좋았습니다.</p>\n<p><strong>아쉬운 점</strong><br>\nMLOps와 데이터플랫폼의 역할을 완전히 나누어 두고 이건 우리의 역할이 아니라고 단정 짓는 부분들이 있습니다. 맞는 말이지만 어느 정도 같이 보고 싶은 분들에게는 아쉬울 수 있을 것 같습니다.</p>\n<br>\n<p>처음 시작한다면 접근성이 좋은 FSDL 강의를 보고 이후에 DMLS 책을 보는걸 추천드립니다.<br>\n특히 Data Distribution Shifts and Monitoring 목차는 FSDL을 먼저 확인한 다음 책을 보는게 이해하는데 도움이 되었습니다.</p>","excerpt":"MLOps…"}}}},{"node":{"title":"Spark on Kubernetes: 스팟 인스턴스 사용을 위한 기능들","id":"1b2de017-d945-522e-be73-569bf48aea40","slug":"spark-on-kubernetes-spot-instance","publishDate":"July 23, 2022","heroImage":{"title":"cover-dataengineering","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&q=50&fm=webp 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&q=50&fm=webp 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(min-width: 1600px) 1600px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=400&h=267&fl=progressive&q=50&fm=jpg 400w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=800&h=533&fl=progressive&q=50&fm=jpg 800w,\nhttps://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&fl=progressive&q=50&fm=jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"}},"layout":"constrained","width":1800,"height":1200,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAlgCWAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBAgb/xAAcEAACAgMBAQAAAAAAAAAAAAAAAQIREiExYeH/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDK1DF0vgtxW9EylQu8nTotmo+gHfAEP//Z"}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":3,"html":"<p>스팟 인스턴스 유형을 사용하면 온디맨드에 비해 70~90%의 비용을 절감할 수 있습니다.\n하지만 스팟 인스턴스는 가격 입찰, 가용성 등 여러 이유로 중단될 수 있습니다.\n따라서 스팟 인스턴스를 사용한다면 노드가 중단되는 상황에 대비할 수 있어야 합니다.\n이 글에서는 Spark on Kubernetes를 스팟 인스턴스 위에서 안정적으로 운영하기 위해 필요한 설정들을 정리해보려 합니다.</p>\n<p><br><br></p>\n<h2 id=\"driver는-on-demand에-할당하기\" style=\"position:relative;\"><a href=\"#driver%EB%8A%94-on-demand%EC%97%90-%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0\" aria-label=\"driver는 on demand에 할당하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>driver는 on-demand에 할당하기</h2>\n<p>중단된 노드에 있던 <code class=\"language-text\">driver pod</code>가 종료되는 경우, Spark 작업은 실패하게 됩니다. <code class=\"language-text\">executor pod</code>가 종료되는 경우, 캐시된 데이터 또는 셔플 파일을 잃게 되지만 새로운 executor를 통해 이를 다시 계산하기 때문에 전체 작업이 실패하지는 않습니다.</p>\n<p>위와 같은 이유로 <strong>driver는 온디맨드 인스턴스에 할당</strong>하는 것이 안전합니다.\n노드 그룹을 분리하고 <code class=\"language-text\">nodeSelector</code>를 활용한다면 driver는 온디맨드에서, executor는 스팟에서 실행하도록 설정할 수 있습니다.</p>\n<p><br><br></p>\n<h2 id=\"적절한-인스턴스-유형-선택하기\" style=\"position:relative;\"><a href=\"#%EC%A0%81%EC%A0%88%ED%95%9C-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%9C%A0%ED%98%95-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0\" aria-label=\"적절한 인스턴스 유형 선택하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>적절한 인스턴스 유형 선택하기</h2>\n<p>일부 인스턴스 유형은 해당 시점의 spot market 상황에 따라 안정적으로 확보하지 못할 수도 있습니다. 확보를 못하게 되면 executor는 계속 pending 상태에 머무르게 되고 전체 수행시간도 지연됩니다.</p>\n<p>사용량에 비해 크기가 큰 인스턴스 유형을 선택했다면, 여러 <code class=\"language-text\">executor pod</code>가 하나의 노드에 할당됩니다. 이 때 해당 노드가 중단된다면 여러 executor가 종료되므로 재계산에 더 많은 시간이 소요됩니다.</p>\n<p>위와 같은 이유로 적절한 인스턴스 유형을 선택하는 것이 spot kill을 줄이는데 도움이 됩니다.\nKarpenter를 사용한다면, 여러 인스턴스 유형을 지정하여 Pod의 리소스 요청량에 가장 적합한 노드를 프로비저닝 할 수 있습니다. 또한 <code class=\"language-text\">Instance Fleet</code>의 <code class=\"language-text\">Allocation Strategy</code>에 따라 가장 안정적으로 확보 가능한 인스턴스 유형을 선택할 수 있습니다.</p>\n<p><br><br></p>\n<h2 id=\"spark-31-graceful-executor-decommissioning\" style=\"position:relative;\"><a href=\"#spark-31-graceful-executor-decommissioning\" aria-label=\"spark 31 graceful executor decommissioning permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark 3.1: Graceful Executor Decommissioning</h2>\n<p><code class=\"language-text\">Graceful Executor Decommissioning</code>은 Spark 3.1 버전에 추가된 기능입니다.\n이 기능을 통해 <strong>노드가 중단되더라도 최소한의 손실로 Spark 작업이 지속되도록 설정</strong>할 수 있습니다. 이를 사용하려면 먼저 클러스터에 <code class=\"language-text\">Node Termination Handler</code>가 설치되어 있어야 합니다. <code class=\"language-text\">Node Termination Handler</code>는 클라우드에 따라 다르게 설치할 수 있도록 지원하고 있습니다.</p>\n<p>이제 노드가 중단되었을 때 과정을 아래 그림을 통해 확인해보겠습니다.</p>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1AWx29kv1p1V3MHI6gPqfvXwQWcLhkGGV\" alt=\"spark-decom\"></p>\n<ol>\n<li>스팟 인스턴스가 중단되기 약 120초 전에 <code class=\"language-text\">Termination Handler</code>의 notice 발생</li>\n<li>driver가 해당 executor를 blacklist에 추가하고 신규 task의 스케줄링을 차단</li>\n<li>중단되는 노드에 있던 캐시된 데이터, 셔플 파일을 다른 노드로 복제</li>\n<li>실패 처리된 task를 이어서 수행 (복제한 파일을 그대로 활용)</li>\n</ol>\n<br>\n<p>위의 과정을 통해 노드가 중단되었을 때 재계산을 최소화 할 수 있습니다.<br>\n이 기능에는 다음과 같이 일부 제한 사항도 존재합니다.</p>\n<p>120초의 시간 제한이 있기 때문에 <strong>옮겨야할 파일이 아주 큰 경우, 일부 파일 손실이 발생</strong>할 수 있습니다. 일반적으로 non-SSD 볼륨은 분당 최대 15GB, SSD 볼륨은 35~40GB 까지 가능합니다. 동시에 많은 executor가 spot kill 당하는 경우, 동일한 이유로 파일 손실이 발생할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">spark.decommission.enabled\nspark.storage.decommission.enabled\nspark.storage.decommission.rddBlocks.enabled\nspark.storage.decommission.shuffleBlocks.enabled</code></pre></div>\n<p><code class=\"language-text\">Graceful Executor Decommissioning</code>은 위의 설정을 통해 활성화 할 수 있습니다.</p>\n<p><br><br></p>\n<h2 id=\"spark-32-executor-pvc-reuse\" style=\"position:relative;\"><a href=\"#spark-32-executor-pvc-reuse\" aria-label=\"spark 32 executor pvc reuse permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spark 3.2: Executor PVC Reuse</h2>\n<p><img src=\"https://drive.google.com/uc?export=view&#x26;id=1X7Ud-SEi0jwoZjuWtaqCrXTsK-5X97Zd\" alt=\"spark-reuse\"></p>\n<p><code class=\"language-text\">Executor PVC Reuse</code>는 Spark 3.2 버전에 추가된 기능입니다.\n이 기능을 통해 spot kill 이후에도 <strong>동일한 PVC 연결을 통해 셔플 파일을 재사용</strong>할 수 있습니다. 이를 사용하려면 먼저 클러스터에 <code class=\"language-text\">Dynamic PVC</code>에 대한 설정이 필요합니다.</p>\n<p>현재는 NVMe 기반의 SSD에서 사용이 어렵다는 제한 사항이 있습니다.<br>\n또한 PVC가 즉시 재사용 불가능한 상황이라면 race condition이 발생할 수도 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">spark.kubernetes.driver.reusePersistentVolumeClaim\nspark.kubernetes.driver.ownPersistentVolumeClaim\nspark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.*\nspark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.*</code></pre></div>\n<p>Executor PVC Reuse는 위의 설정을 통해 활성화 할 수 있습니다.</p>\n<br>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://databricks.com/it/dataaisummit/session/how-make-apache-spark-kubernetes-run-reliably-spot-instances/\">https://databricks.com/it/dataaisummit/session/how-make-apache-spark-kubernetes-run-reliably-spot-instances/</a></li>\n<li><a href=\"https://issues.apache.org/jira/browse/SPARK-20624\">https://issues.apache.org/jira/browse/SPARK-20624</a></li>\n<li><a href=\"https://issues.apache.org/jira/browse/SPARK-35593\">https://issues.apache.org/jira/browse/SPARK-35593</a></li>\n</ul>","excerpt":"스팟 인스턴스 유형을 사용하면 온디맨드에 비해 70~9…"}}}},{"node":{"title":"쿠버네티스에서 GPU 리소스를 효율적으로 활용하는 방법","id":"c5510818-773d-5ec0-8047-6f2c4c31d67f","slug":"gpu-utilization","publishDate":"July 08, 2022","heroImage":{"title":"cover-devops","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=270&h=180&q=50&fm=webp 270w,\nhttps://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=540&h=360&q=50&fm=webp 540w,\nhttps://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50&fm=webp 1080w","sizes":"(min-width: 1080px) 1080px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=270&h=180&fl=progressive&q=50&fm=jpg 270w,\nhttps://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=540&h=360&fl=progressive&q=50&fm=jpg 540w,\nhttps://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&fl=progressive&q=50&fm=jpg 1080w","sizes":"(min-width: 1080px) 1080px, 100vw"}},"layout":"constrained","width":1800,"height":1200,"placeholder":{"fallback":"data:image/jpeg;base64,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"}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":3,"html":"<p>GPU는 강력한 연산 기능을 제공하지만 비용이 많이 들기 때문에 제한된 리소스를 효율적으로 활용하는 것이 중요합니다. 이번 글에서는 NVIDIA GPU의 리소스 공유를 지원하기 위한 방법으로 <strong>Time Slicing</strong>과 <strong>MIG</strong>에 대해 정리해보려 합니다.</p>\n<br>\n<h2 id=\"gpu-리소스가-낭비되고-있다\" style=\"position:relative;\"><a href=\"#gpu-%EB%A6%AC%EC%86%8C%EC%8A%A4%EA%B0%80-%EB%82%AD%EB%B9%84%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4\" aria-label=\"gpu 리소스가 낭비되고 있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GPU 리소스가 낭비되고 있다?</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1OJV0IVyYU3NjbRYFbM2ZueKAMVZi5_4y\" alt=\"utilization\"></p>\n<p>여러 아키텍쳐(암페어, 파스칼 등)로 구성된 GPU들을 모아 쿠버네티스 노드 풀을 구성하고 사용자들은 GPU 리소스를 할당받아 사용하는 환경이라고 가정해보겠습니다. 사용자들은 GPU 할당을 못 받는 상황임에도 실제 GPU 사용량을 측정해보면 생각보다 낮게 유지되고 있는 경우가 있습니다. 워크로드에 따라 필요한 리소스가 다르기 때문입니다.</p>\n<p>노트북 환경은 항상 개발을 하는게 아니기 때문에 idle 상태로 대기하는 시간이 많습니다. 작은 배치 사이즈로 운영되는 인퍼런스의 경우, 트래픽에 따라 사용량이 달라질 수 있습니다.\n따라서 이런 상황에서는 <strong>항상 리소스를 점유하기 보다 필요할 때 bursting 가능한 방식으로 운영</strong>하는 것이 효율적입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Pod\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> cuda<span class=\"token punctuation\">-</span>vector<span class=\"token punctuation\">-</span>add\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">restartPolicy</span><span class=\"token punctuation\">:</span> OnFailure\n  <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> cuda<span class=\"token punctuation\">-</span>vector<span class=\"token punctuation\">-</span>add\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"k8s.gcr.io/cuda-vector-add:v0.1\"</span>\n      <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">limits</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span> <span class=\"token comment\"># GPU 1개 요청하기</span></code></pre></div>\n<p>쿠버네티스에서는 디바이스 플러그인을 통해 Pod가 GPU 리소스를 요청할 수 있습니다.\n하지만 <strong>Pod는 하나 이상의 GPU만 요청할 수 있으며 CPU와 달리 GPU의 일부(fraction)를 요청하는 것은 불가능</strong>합니다. 예를 들어 간단한 실험에 최신 버전의 고성능 GPU 1개를 온전히 할당 받는 것은 낭비입니다. NVIDIA 문서에서는 SW/HW 관점에서 GPU 리소스를 효율적으로 사용하기 위해 다양한 방법을 소개합니다. 그 중 <strong>Time Slicing</strong>과 <strong>MIG</strong>에 대해 알아보겠습니다.</p>\n<br>\n<h2 id=\"time-slicing\" style=\"position:relative;\"><a href=\"#time-slicing\" aria-label=\"time slicing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Time Slicing</h2>\n<p>Time Slicing은 GPU의 <strong>시간 분할 스케줄러</strong>입니다.\n파스칼 아키텍쳐부터 지원하는 <strong>compute preemption</strong> 기능을 활용한 방법입니다.\n각 컨테이너는 공평하게 <code class=\"language-text\">timeslice</code>를 할당받게 되지만 전환할 때 <code class=\"language-text\">context switching</code> 비용이 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ConfigMap\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> time<span class=\"token punctuation\">-</span>slicing<span class=\"token punctuation\">-</span>config\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> gpu<span class=\"token punctuation\">-</span>operator\n<span class=\"token key atrule\">data</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">a100-40gb</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token punctuation\">-</span>\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> v1\n    <span class=\"token key atrule\">sharing</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">timeSlicing</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nvidia.com/gpu\n          <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nvidia.com/mig<span class=\"token punctuation\">-</span>1g.5gb\n          <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n  <span class=\"token key atrule\">tesla-t4</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token punctuation\">-</span>\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> v1\n    <span class=\"token key atrule\">sharing</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">timeSlicing</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nvidia.com/gpu\n          <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">4</span></code></pre></div>\n<p><strong>NVIDIA GPU Operator</strong>에서는 위와 같이 <code class=\"language-text\">ConfigMap</code>을 사용하거나 <code class=\"language-text\">node label</code>을 통해 설정할 수 있습니다. 설정한 이후에 노드를 확인해보면 아래와 같이 리소스에 값이 추가된 것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">$ kubectl describe node $NODE\n\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n  <span class=\"token key atrule\">allocatable</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span></code></pre></div>\n<p>최대 8개 컨테이너까지 <code class=\"language-text\">timeslice</code> 방식으로 shared GPU를 사용할 수 있다는 것을 의미합니다. 이 방법은 <strong>GPU 메모리 limit 설정을 강제하는 것이 아니기 때문에 OOM이 발생</strong>할 수도 있습니다. 이를 방지하려면 GPU를 사용하는 컨테이너 수를 모니터링하고 <code class=\"language-text\">Tensorflow</code>나 <code class=\"language-text\">PyTorch</code> 같은 프레임워크에서 총 GPU 메모리 제한 설정이 필요합니다.</p>\n<br>\n<h2 id=\"multi-instance-gpu-mig\" style=\"position:relative;\"><a href=\"#multi-instance-gpu-mig\" aria-label=\"multi instance gpu mig permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi instance GPU (MIG)</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1bJYen4Q33jEa9yHcp4LR3NOPNNzTMZCR\" alt=\"mig\"></p>\n<p>MIG는 A100과 같은 <strong>암페어 아키텍처 기반 GPU를 최대 7개의 개별 GPU 인스턴스로 분할해서 사용</strong>할 수 있는 기능입니다.\n분할된 인스턴스를 <strong>파티션</strong>이라고 부르는데, 각 파티션은 물리적으로 격리되어 있기 때문에 안전하게 병렬로 사용할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=12kdw7KZWuph3ADBsJO4FMD4m1fIxufAj\" alt=\"partition\"></p>\n<p>위의 표와 같이 설정을 통해 파티션 크기를 조정할 수 있습니다. 표에서 unit은 하나의 파티션에 몇 개가 할당되는지를 의미합니다.\nA100의 경우, 최대 7개의 <code class=\"language-text\">compute unit</code>과 8개의 <code class=\"language-text\">memory unit</code>을 가질 수 있습니다 (각 5GB 메모리). 파티션은 <code class=\"language-text\">&lt;compute>g.&lt;memory>gb</code> 형식을 따르고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">$ kubectl label nodes $NODE nvidia.com/mig.config=all<span class=\"token punctuation\">-</span>1g.5gb\n$ kubectl describe node $NODE\n\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7</span>\n  <span class=\"token key atrule\">allocatable</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7</span></code></pre></div>\n<p>이번에도 노드 설정 후, 값을 확인해보면 7이 들어가 있습니다.<br>\n<code class=\"language-text\">1g.5gb</code> 크기의 파티션을 7개까지 사용할 수 있다는 의미입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> cuda<span class=\"token punctuation\">-</span>vectoradd\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7</span>\n  <span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">nodeSelector</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">nvidia.com/gpu.product</span><span class=\"token punctuation\">:</span> A100<span class=\"token punctuation\">-</span>SXM4<span class=\"token punctuation\">-</span>40GB<span class=\"token punctuation\">-</span>MIG<span class=\"token punctuation\">-</span>1g.5gb\n    <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> vectoradd\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nvidia/samples<span class=\"token punctuation\">:</span>vectoradd<span class=\"token punctuation\">-</span>cuda11.2.1\n      <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">limits</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></code></pre></div>\n<p>위와 같이 MIG를 통해 Pod 마다 1개의 파티션을 갖도록 설정해서 7개의 replica 구성하는 것도 가능합니다. 이처럼 사용자는 <strong>MIG를 통해 GPU를 최대로 활용</strong>할 수 있습니다.</p>\n<br>\n<h2 id=\"time-slicing-vs-mig\" style=\"position:relative;\"><a href=\"#time-slicing-vs-mig\" aria-label=\"time slicing vs mig permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Time Slicing vs MIG</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1NYVmMl0RyQVEnL5toybX8DH-AwpF1Bw2\" alt=\"compare\"></p>\n<p>두 방식을 비교해보면 위의 표와 같습니다.\nTime Slicing 방식은 7개 이상의 컨테이너를 사용할 수 있습니다. 따라서 <strong>bursting 워크로드에 적합한 방식</strong>이라고 볼 수 있습니다. 반면 <strong>MIG는 적은 양의 고정된 사용량을 가지는 워크로드에 적합</strong>합니다.\nA100은 MIG를 통해 분할하고 그 외의 GPU는 Time Slicing을 사용하는 방식으로 함께 사용할 수 있으니 워크로드에 맞는 방식을 선택하는 것이 중요합니다.</p>\n<br>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=X876kr-LkPA\">Kubecon 2022 - Improving GPU Utilization using Kubernetes</a></li>\n<li><a href=\"https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/overview.html\">https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/overview.html</a></li>\n</ul>","excerpt":"GPU는 강력한 연산 기능을 제공하지만 비용이 많이 들기 때문에 제한된 리소스를 효율적으로 활용하는 것이 중요합니다. 이번 글에서는 NVIDIA…"}}}}]}},"pageContext":{"basePath":"","paginationPath":"","pageNumber":0,"humanPageNumber":1,"skip":0,"limit":7,"numberOfPages":17,"previousPagePath":"","nextPagePath":"/2"}},"staticQueryHashes":["1946181227","2744905544","3732430097"]}