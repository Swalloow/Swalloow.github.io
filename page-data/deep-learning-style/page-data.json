{"componentChunkName":"component---src-templates-post-js","path":"/deep-learning-style/","result":{"data":{"contentfulPost":{"title":"Deep Learning Programming Style: Symbolic, Imperative","slug":"deep-learning-style","metaDescription":null,"publishDate":"January 05, 2018","publishDateISO":"2018-01-05","tags":[{"title":"DataScience","id":"82931dd3-d22b-528e-8a9b-ddbb200bb401","slug":"datascience"}],"heroImage":{"title":"cover-datascience","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=450&h=300&q=50&fm=webp 450w,\nhttps://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=900&h=600&q=50&fm=webp 900w,\nhttps://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=1800&h=1200&q=50&fm=webp 1800w","sizes":"(min-width: 1800px) 1800px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=1800&h=1200&fl=progressive&q=50&fm=jpg","srcSet":"https://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=450&h=300&fl=progressive&q=50&fm=jpg 450w,\nhttps://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=900&h=600&fl=progressive&q=50&fm=jpg 900w,\nhttps://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=1800&h=1200&fl=progressive&q=50&fm=jpg 1800w","sizes":"(min-width: 1800px) 1800px, 100vw"}},"layout":"constrained","width":1800,"height":1200,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wAARCAANABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAQBAwUG/8QAHxAAAgEEAgMAAAAAAAAAAAAAAQIAAwQRIQVCExSR/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oADAMBAAIRAxEAPwCthE7ioFIBOznEy05C8uWI8wpjHVZCF3uFSpUd99m18kpIXSYyTqES96ouiFMJnScb/9k="}},"ogimg":{"src":"https://images.ctfassets.net/tushy4jlcik7/5l0PQJpz5C5IDFjHYigWJI/389fe4852b9cb39e9ada4938db33e6ca/cover_datascience.jpg?w=1800&q=50"}},"body":{"childMarkdownRemark":{"timeToRead":5,"html":"<p>TensorFlow 1.5 버전부터 <a href=\"https://github.com/tensorflow/tensorflow/tree/r1.5/tensorflow/contrib/eager\">Eager Execution</a> 이라는 기능이 추가되었습니다.\n다시 말해서 <code class=\"language-text\">imperative programming style</code>을 지원한다고 적혀있는데, 기존의 방식과 어떤 차이가 있는지 알아보겠습니다.\nMXNet의 <a href=\"https://mxnet.incubator.apache.org/architecture/program_model.html\">Deep Learning Programming Style</a> 문서를 번역한 내용입니다.</p>\n<br>\n<h2 id=\"deep-learning-programming-style\" style=\"position:relative;\"><a href=\"#deep-learning-programming-style\" aria-label=\"deep learning programming style permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deep Learning Programming Style</h2>\n<p>우리는 항상 <strong>성능과 최적화</strong>에 대한 고민을 합니다. 하지만 그 이전에 잘 동작하는 코드인지 여부가 중요합니다. 이제는 다양한 딥러닝 라이브러리들이 존재하지만 각자 프로그래밍 방식에 대해 다른 접근 방식을 가지고 있기 때문에 학습하는 것도 힘들며, 이를 이용하여 명확하고 직관적인 deep learning 코드를 작성하는 것도 어렵습니다.</p>\n<p>이 문서에서는 가장 중요한 두 가지 디자인 패턴에 집중하려고 합니다.</p>\n<ol>\n<li>\n<p>Whether to embrace the symbolic or imperative paradigm for mathematical computation.</p>\n</li>\n<li>\n<p>Whether to build networks with bigger (more abstract) or more atomic operations.</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"symbolic-vs-imperative-programs\" style=\"position:relative;\"><a href=\"#symbolic-vs-imperative-programs\" aria-label=\"symbolic vs imperative programs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbolic vs. Imperative Programs</h2>\n<p>만일 당신이 파이썬 또는 C++ 개발자라면, 이미 <code class=\"language-text\">Imperative program</code>과 친숙할 것 입니다.\nImperative style program들은 바로 연산을 수행합니다. 대부분의 파이썬 코드들이 imperative 한 형태를 보여주는데, 예를 들면 아래와 같은 Numpy 코드를 말합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\na <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\nb <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\nc <span class=\"token operator\">=</span> b <span class=\"token operator\">*</span> a\nd <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span></code></pre></div>\n<p>프로그램이 <code class=\"language-text\">c = b * a</code>를 수행하도록 명령을 내리면, 실제로 연산이 실행됩니다.</p>\n<p>반면에 <code class=\"language-text\">Symbolic program</code>은 조금 다릅니다. Symbolic-style program에서는 먼저 function (potentially complex) 을 정의합니다. <strong>function을 정의했다고 해서 실제 연산이 수행되는 것은 아닙니다.</strong> 우리는 그저 placeholder 값에 function을 정의한 것 뿐 입니다. 이 과정 이후에 function을 컴파일 할 수 있으며, 실제 입력 값을 통해 이를 평가하게 됩니다. 아래는 위에서 언급했던 imperative 코드를 symbolic style로 변환한 예제입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">A <span class=\"token operator\">=</span> Variable<span class=\"token punctuation\">(</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span>\nB <span class=\"token operator\">=</span> Variable<span class=\"token punctuation\">(</span><span class=\"token string\">'B'</span><span class=\"token punctuation\">)</span>\nC <span class=\"token operator\">=</span> B <span class=\"token operator\">*</span> A\nD <span class=\"token operator\">=</span> C <span class=\"token operator\">+</span> Constant<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># compiles the function</span>\nf <span class=\"token operator\">=</span> <span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span>D<span class=\"token punctuation\">)</span>\nd <span class=\"token operator\">=</span> f<span class=\"token punctuation\">(</span>A<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> B<span class=\"token operator\">=</span>np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>보시다시피 symbolic 버전에서는 <code class=\"language-text\">C = B * A</code>가 수행되는 시점에 실제로 연산이 일어나지 않습니다. 대신에 이 operation은 연산 과정을 표현하는 <strong>computation graph (aka. symbolic graph)</strong> 를 생성합니다. 예를 들면, D의 연산을 위해 아래와 같은 computation graph가 생성됩니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1hjs2EOtub_KjPqj4nflGGR1Rjcaklp7M\" alt=\"comp_graph\"></p>\n<p>대부분의 symbolic-style 프로그램들은 명시적으로든 암시적으로든 컴파일 단계를 포함합니다. 이를 통해 computation graph를 언제든 호출할 수 있는 함수로 변환시켜줍니다. 위의 예제에서도 실제 연산은 코드의 마지막 줄에서만 수행됩니다. 이를 통해 얻을 수 있는 점은 computation graph를 작성하는 단계와 실행하는 단계를 명확히 분리할 수 있다는 것 입니다. Neural Network에서도 우리는 전체 모델을 단일 computation graph로 정의합니다.</p>\n<p><code class=\"language-text\">Torch</code>, <code class=\"language-text\">Chiner</code> 그리고 <code class=\"language-text\">Minerva</code>와 같은 딥러닝 라이브러리들은 imperative style을 사용하고 있습니다. symbolic-style을 사용하는 딥러닝 라이브러리로는 <code class=\"language-text\">Theano</code>, <code class=\"language-text\">CGT</code> 그리고 <code class=\"language-text\">TensorFlow</code>가 있습니다. 그리고 <code class=\"language-text\">CXXNet</code> 이나 <code class=\"language-text\">Caffe</code>와 같은 라이브러리들은 설정파일에 의존하는 방식으로 symbolic style을 지원합니다. (ex. Caffe의 prototxt)\n이제 두 가지 딥러닝 프로그래밍 방식에 대해 이해했으니, 각 방식의 장점에 대해 알아보겠습니다.</p>\n<hr>\n<h2 id=\"imperative-programs-tend-to-be-more-flexible\" style=\"position:relative;\"><a href=\"#imperative-programs-tend-to-be-more-flexible\" aria-label=\"imperative programs tend to be more flexible permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Imperative Programs Tend to be More Flexible</h2>\n<p>imperative program은 프로그래밍 언어의 flow와 상당히 잘 맞아들어가며 유연하게 동작하는 것 처럼 보입니다. 그렇다면 왜 수 많은 딥러닝 라이브러리들이 symbolic 패러다임을 선택할까요? 가장 큰 이유는 <strong>메모리 사용량과 속도 측면에서의 효율성</strong> 때문입니다. 위에서 언급했던 예제로 돌아가 천천히 설명드리겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">a <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\nb <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>ones<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\nc <span class=\"token operator\">=</span> b <span class=\"token operator\">*</span> a\nd <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1hjs2EOtub_KjPqj4nflGGR1Rjcaklp7M\" alt=\"comp_graph\"></p>\n<p>주어진 array의 각 셀이 8 바이트의 메모리를 소모한다고 가정해보겠습니다. 콘솔에서 위의 프로그램을 실행하면 메모리가 얼마나 소모될까요?</p>\n<p>imperative program에서는 각 라인마다 메모리 할당이 요구됩니다. 사이즈가 10인 array가 4개 할당되므로 <code class=\"language-text\">4 * 10 * 8 = 320 bytes</code>의 메모리가 요구됩니다.\n반면 computation graph에서는 궁극적으로 d가 필요하다는 것을 알고 있기 때문에, 즉시 값을 메모리에 할당하는 대신에 <strong>메모리를 재사용</strong>할 수 있습니다. 예를 들어 b를 위해 할당된 공간에 c를 저장하도록 재사용하고, c를 위해 할당된 공간에 다시 d를 저장하도록 한다면 결국 요구되는 메모리는 <code class=\"language-text\">2 * 10 * 8 = 160 bytes</code> 절반으로 줄어들게 됩니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1L42AX9v9qyDYbx2qkw_rGlubWOm-NzJD\" alt=\"comp_graph_fold\"></p>\n<p>Symbolic program은 사실 이보다 더 엄격합니다. 우리가 D에 대한 컴파일을 호출하면, 시스템은 오직 d 값이 필요하다는 사실만 인지합니다. 따라서 위와 같은 경우, 즉시 연산에 의해 c는 존재하지 않는 값으로 취급합니다.</p>\n<p>symbolic program이 안전하게 메모리를 재사용함으로 인해 우리가 얻는 장점은 분명 있습니다. 하지만, 나중에 우리가 c에 대해 접근해야하는 경우가 생긴다면 난감해집니다. 따라서 imperative program은 모든 가능한 경우의 수에 접근해야 할 때 더 좋은 대안이 될 수 있습니다. 대표적으로 파이썬 콘솔에서 imperative 버전의 코드를 실행시킨다면, 미래에 발생할 수 있는 변수를 중간 과정을 통해 미리 검사할 수 있습니다.</p>\n<p>Symbolic program은 <code class=\"language-text\">operation folding</code> 최적화도 수행해줍니다. 다시 위의 예시를 살펴보면 곱셈과 합 연산이 하나의 operation으로 합쳐지는 것을 그래프를 통해 확인할 수 있습니다. 만일 연산이 GPU 프로세서에 의해 실행된다면, 두 개가 아닌 하나의 GPU 커널만 실행될 것 입니다. 실제로 이는 CXXNet, Caffe와 같은 라이브러리에서 연산을 수행하는 방식입니다. Operation folding 방식은 계산 효율을 향상시켜줍니다.</p>\n<p>아시다시피 imperative program에서는 중간 값이 나중에 참조될 수 있기 때문에 operation folding 방식을 수행할 수 없습니다. 반면, computation graph에서는 전체 계산 그래프를 얻을 수 있고 어떤 값을 필요로하는지 알 수 있기 때문에 operation folding이 가능합니다.</p>\n<hr>\n<h2 id=\"case-study-backprop-and-autodiff\" style=\"position:relative;\"><a href=\"#case-study-backprop-and-autodiff\" aria-label=\"case study backprop and autodiff permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Case Study: Backprop and AutoDiff</h2>\n<p>이제 <code class=\"language-text\">auto differentiation</code>이나 <code class=\"language-text\">backpropagation</code>과 같은 문제를 통해 두 가지 프로그래밍 모델을 비교해보겠습니다. (chaining rule이 어떻게 동작하는지 보여주겠다)\n미분은 모델을 훈련시키는 메커니즘이기 때문에 딥러닝에 있어 정말 중요합니다. 우선 대부분의 딥러닝 모델에서 loss function을 정의하는데 이는 모델이 예측한 값이 실제 값과 얼마나 멀리 떨어져 있는지를 말합니다. 그리고 나서 훈련 데이터를 모델에게 전달하고, 각 step에서 모델의 parameter를 업데이트하여 loss를 최소화합니다. 즉, parameter가 업데이트 하는 방향은 loss function 결과에 의해 결정됩니다.</p>\n<p>imperative와 symbolic 방식 모두 <code class=\"language-text\">gradient</code> 계산을 수행할 수 있습니다. 먼저 아래의 파이썬 코드를 통해 imperative program이 어떻게 automatic differentiation을 수행하는지 알아보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">array</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">object</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">\"\"\"\n    Simple Array object that support autodiff.\n    \"\"\"</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> name<span class=\"token operator\">=</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value\n        <span class=\"token keyword\">if</span> name<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>grad <span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span> g <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>name <span class=\"token punctuation\">:</span> g<span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__add__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">assert</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>other<span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n        ret <span class=\"token operator\">=</span> array<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>value <span class=\"token operator\">+</span> other<span class=\"token punctuation\">)</span>\n        ret<span class=\"token punctuation\">.</span>grad <span class=\"token operator\">=</span> <span class=\"token keyword\">lambda</span> g <span class=\"token punctuation\">:</span> self<span class=\"token punctuation\">.</span>grad<span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> ret\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__mul__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> other<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">assert</span> <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>other<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">)</span>\n        ret <span class=\"token operator\">=</span> array<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>value <span class=\"token operator\">*</span> other<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">def</span> <span class=\"token function\">grad</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>grad<span class=\"token punctuation\">(</span>g <span class=\"token operator\">*</span> other<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n            x<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">(</span>other<span class=\"token punctuation\">.</span>grad<span class=\"token punctuation\">(</span>g <span class=\"token operator\">*</span> self<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> x\n        ret<span class=\"token punctuation\">.</span>grad <span class=\"token operator\">=</span> grad\n        <span class=\"token keyword\">return</span> ret\n\n<span class=\"token comment\"># some examples</span>\na <span class=\"token operator\">=</span> array<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span>\nb <span class=\"token operator\">=</span> array<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span>\nc <span class=\"token operator\">=</span> b <span class=\"token operator\">*</span> a\nd <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">print</span> d<span class=\"token punctuation\">.</span>value\n<span class=\"token keyword\">print</span> d<span class=\"token punctuation\">.</span>grad<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># Results</span>\n<span class=\"token comment\"># 3</span>\n<span class=\"token comment\"># {'a': 2, 'b': 1}</span></code></pre></div>\n<hr>\n<h2 id=\"model-checkpoints\" style=\"position:relative;\"><a href=\"#model-checkpoints\" aria-label=\"model checkpoints permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Model Checkpoints</h2>\n<p>모델을 저장하고 다시 불러오는 일 또한 중요합니다. 보통 Neural Network 모델을 저장한다는 것은 네트워크의 구조, 설정 값 그리고 weight 값의 저장을 의미합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">A <span class=\"token operator\">=</span> Variable<span class=\"token punctuation\">(</span><span class=\"token string\">'A'</span><span class=\"token punctuation\">)</span>\nB <span class=\"token operator\">=</span> Variable<span class=\"token punctuation\">(</span><span class=\"token string\">'B'</span><span class=\"token punctuation\">)</span>\nC <span class=\"token operator\">=</span> B <span class=\"token operator\">*</span> A\nD <span class=\"token operator\">=</span> C <span class=\"token operator\">+</span> Constant<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\nD<span class=\"token punctuation\">.</span>save<span class=\"token punctuation\">(</span><span class=\"token string\">'mygraph'</span><span class=\"token punctuation\">)</span>\nD2 <span class=\"token operator\">=</span> load<span class=\"token punctuation\">(</span><span class=\"token string\">'mygraph'</span><span class=\"token punctuation\">)</span>\nf <span class=\"token operator\">=</span> <span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>D2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># more operations</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>설정 값을 체크하는 일은 symbolic program이 더 유리 합니다. symbolic 구조에서는 실제 연산을 수행할 필요가 없기 때문에 computation graph를 그대로 serialize 하면 됩니다.\n반면에 Imperative program은 연산 할 때 실행되기 때문에 코드 자체를 설정 파일로 저장하거나 그 위에 또 다른 레이어를 구성해야합니다.</p>\n<hr>\n<h2 id=\"parameter-updates\" style=\"position:relative;\"><a href=\"#parameter-updates\" aria-label=\"parameter updates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Parameter Updates</h2>\n<p>computation graph의 경우 연산과정은 쉽게 설명할 수 있지만 parameter 업데이트에 대해서는 명확하지 못합니다. parameter update는 기본적으로 값의 변경(mutation)을 요구하기 때문에 computation graph의 개념과 맞지 않습니다. 따라서 대부분의 symbolic program들은 persistent state를 갱신하기 위해 special update 구문을 사용하고 있습니다.</p>\n<p>반면에 imperative style에서는 parameter 업데이트를 작성하는 것이 쉽습니다. 특히 서로 연관된 여러 업데이트가 필요할 때 더욱 그렇습니다. Symbolic program의 경우 업데이트 문은 사용자가 호출 할 때 실행됩니다. 이런 점에서 대부분의 symbolic deep learning 라이브러리는 parameter 업데이트에 대해 gradient 연산을 수행하면서 업데이트를 수행하는 imperative style로 다시 돌아갑니다.</p>\n<hr>\n<h2 id=\"there-is-no-strict-boundary\" style=\"position:relative;\"><a href=\"#there-is-no-strict-boundary\" aria-label=\"there is no strict boundary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>There Is No Strict Boundary</h2>\n<p>두 가지 프로그래밍 스타일을 비교해서, 하나만 사용하라는 말이 아닙니다. 명령형 프로그램을 상징형 프로그램처럼 만들거나 그 반대도 가능합니다. 예를 들면, Python으로 JIT (just-in-time) 컴파일러를 작성하여 명령형 Python 프로그램을 컴파일 할 수 있습니다. 하지만 두 가지 아키텍쳐를 이해하는 것은 수 많은 딥러닝 라이브러리의 추상화와 그 차이를 이해하는데 도움이 됩니다. <strong>결국, 우리는 프로그래밍 스타일 간에 명확한 경계선이 없다고 결론을 내릴 수 있습니다.</strong></p>\n<br>","excerpt":"TensorFlow 1.5 버전부터 Eager Execution 이라는 기능이 추가되었습니다.\n다시 말해서 을 지원한다고 적혀있는데, 기존의 방식과 어떤 차이가 있는지 알아보겠습니다.\nMXNet의 Deep Learning Programming Style 문서를 번역한 내용입니다. Deep Learning Programming Style…"}}}},"pageContext":{"slug":"deep-learning-style","basePath":"","prev":{"slug":"data-science-inconvenient-truth","publishDate":"2018-04-01"},"next":{"slug":"zeppelin-bootstrap","publishDate":"2017-09-13"}}},"staticQueryHashes":["1946181227","2744905544","3732430097"]}