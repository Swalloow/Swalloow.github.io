{"componentChunkName":"component---src-templates-post-js","path":"/pandas-parallel/","result":{"data":{"contentfulPost":{"id":"c83a7091-0a01-5886-876f-6a7e9d8cb6ca","title":"Pandas DataFrame을 병렬처리 하는 방법","slug":"pandas-parallel","metaDescription":null,"publishDate":"February 27, 2017","publishDateISO":"2017-02-27","tags":[{"title":"DataEngineering","id":"6d3fb203-7cdf-53d7-be6f-12ba3e82d74d","slug":"dataengineering"}],"heroImage":{"id":"dab22ea8-d54d-52a6-852a-278ba3b19a2b","title":"cover-dataengineering","fluid":{"aspectRatio":1.499531396438613,"src":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50 1600w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1600&h=1067&q=50&fm=webp 1600w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7uo9TsqFN9EBsDBqDJ5vXl/4c58a9f94babb15d8fd996c247737656/cover_dataengineering.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"3a929e46-2df8-5ebb-a912-ab2e8ac6706f","childMarkdownRemark":{"id":"7f693de6-6997-5fe5-8cfc-b165faa35db3","timeToRead":1,"html":"<p>Scikit-learn의 모델들은 cython과 joblib으로 최적화 및 자동 병렬처리 되도록 설계되어 있지만,\nPandas는 여전히 내부적으로 병렬처리 기능을 지원하지 않습니다.</p>\n<p>하지만, 큰 규모의 DataFrame을 돌리다보면 전처리에도 시간이 많이 걸리게 됩니다.\n그런 경우에 병렬처리를 통해 속도를 개선할 수 있습니다.</p>\n<p>이 포스팅에서는 가장 간단한 CPU 프로세스 병렬처리를 다루도록 하겠습니다. 방법은 간단합니다.\n거대한 DataFrame을 CPU 코어 수 만큼 분할하고, 전처리 기능을 수행한 다음 다시 합치면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> pandas <span class=\"token keyword\">as</span> pd\n<span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n<span class=\"token keyword\">import</span> seaborn <span class=\"token keyword\">as</span> sns\n<span class=\"token keyword\">from</span> multiprocessing <span class=\"token keyword\">import</span> Pool\n\nnum_cores <span class=\"token operator\">=</span> <span class=\"token number\">4</span>\niris <span class=\"token operator\">=</span> pd<span class=\"token punctuation\">.</span>DataFrame<span class=\"token punctuation\">(</span>sns<span class=\"token punctuation\">.</span>load_dataset<span class=\"token punctuation\">(</span><span class=\"token string\">'iris'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>예시로 iris 데이터를 사용하겠습니다.\ncpu 코어의 수는 <code class=\"language-text\">multiprocessing.cpu_count()</code> 함수를 통해서 얻으실 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">parallelize_dataframe</span><span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">,</span> func<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    df_split <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array_split<span class=\"token punctuation\">(</span>df<span class=\"token punctuation\">,</span> num_cores<span class=\"token punctuation\">)</span>\n    pool <span class=\"token operator\">=</span> Pool<span class=\"token punctuation\">(</span>num_cores<span class=\"token punctuation\">)</span>\n    df <span class=\"token operator\">=</span> pd<span class=\"token punctuation\">.</span>concat<span class=\"token punctuation\">(</span>pool<span class=\"token punctuation\">.</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span>func<span class=\"token punctuation\">,</span> df_split<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    pool<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    pool<span class=\"token punctuation\">.</span>join<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> df</code></pre></div>\n<p>parallelize_dataframe은 어떤 전처리 함수가 들어왔을 때 CPU 병렬처리를 도와주는 함수입니다.\nmultiprocessing.Pool을 이용하여 분할된 DataFrame에 함수를 적용시키고,\npd.concat()으로 다시 합치는 과정입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">multiply_columns</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    data<span class=\"token punctuation\">[</span><span class=\"token string\">'length_of_word'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span><span class=\"token string\">'species'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">lambda</span> x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> data</code></pre></div>\n<p>각 종 이름의 글자 수를 세는 전처리 함수를 예로 들어 속도차이를 확인해보겠습니다.\n결과는 아래와 같습니다.</p>\n<br>\n<p><img src=\"/assets/images/pandas-parallel.png\" alt=\"pandas-parrallel\"></p>\n<p>다른 방법으로 Pandas의 engine에 Dask를 사용하는 방법도 있습니다.\n<a href=\"http://dask.readthedocs.io/en/latest/\">http://dask.readthedocs.io/en/latest/</a></p>","excerpt":"Scikit-learn의 모델들은 cython과 joblib으로 최적화 및 자동 병렬처리 되도록 설계되어 있지만,\nPandas는 여전히 내부적으로 병렬처리 기능을 지원하지 않습니다. 하지만, 큰 규모의 DataFrame을 돌리다보면 전처리에도 시간이 많이 걸리게 됩니다.\n그런 경우에 병렬처리를 통해 속도를 개선할 수 있습니다. 이 포스팅에서는 가장 간단한 CPU 프로세스 병렬처리를 다루도록 하겠습니다. 방법은 간단합니다.\n거대한 DataFrame을 CPU 코어 수 만큼 분할하고, 전처리 기능을 수행한 다음 다시 합치면 됩니다. 예시로 iris…"}}}},"pageContext":{"slug":"pandas-parallel","basePath":"","prev":{"slug":"https-ssl","publishDate":"2017-03-01"},"next":{"slug":"dataframe-to-mysql","publishDate":"2017-02-26"}}}}