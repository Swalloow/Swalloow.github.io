{"componentChunkName":"component---src-templates-post-js","path":"/gpu-utilization/","result":{"data":{"contentfulPost":{"id":"4f44d330-2a1d-5f91-a35c-744c2ed60fc7","title":"쿠버네티스에서 GPU 리소스를 효율적으로 활용하는 방법","slug":"gpu-utilization","metaDescription":null,"publishDate":"July 08, 2022","publishDateISO":"2022-07-08","tags":[{"title":"DevOps","id":"701ee587-d6e3-5391-af93-e295765b6f45","slug":"devops"}],"heroImage":{"id":"f36c235f-3e3e-517d-bd80-697bc6183072","title":"cover-devops","fluid":{"aspectRatio":1.5,"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50 1080w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50&fm=webp 1080w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"3bdf2497-323d-5fe7-900e-cda640c9fff6","childMarkdownRemark":{"id":"d6c114d7-5f57-51d4-ab3c-80b0d5b4125c","timeToRead":4,"html":"<p>GPU는 강력한 연산 기능을 제공하지만 비용이 많이 들기 때문에 제한된 리소스를 효율적으로 활용하는 것 이 중요합니다. 이는 온프레미스, 클라우드 환경 모두 해당합니다. 이번 글에서는 NVIDIA GPU의 리소스 공유를 지원하기 위한 방법으로 <strong>Time Slicing</strong>과 <strong>MIG</strong>에 대해 정리해보려 합니다.</p>\n<br>\n<h2 id=\"gpu-리소스가-낭비되고-있다\" style=\"position:relative;\"><a href=\"#gpu-%EB%A6%AC%EC%86%8C%EC%8A%A4%EA%B0%80-%EB%82%AD%EB%B9%84%EB%90%98%EA%B3%A0-%EC%9E%88%EB%8B%A4\" aria-label=\"gpu 리소스가 낭비되고 있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GPU 리소스가 낭비되고 있다?</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1OJV0IVyYU3NjbRYFbM2ZueKAMVZi5_4y\" alt=\"utilization\"></p>\n<p>여러 아키텍쳐(암페어, 파스칼 등)로 구성된 GPU들을 모아 쿠버네티스 노드 풀을 구성하고 사용자들은 GPU 리소스를 할당받아 사용하는 환경이라고 가정해보겠습니다. 사용자들은 GPU 할당을 못 받는 상황임에도 실제 GPU 사용량을 측정해보면 생각보다 낮게 유지되고 있는 경우가 있습니다. 워크로드에 따라 필요한 리소스가 다르기 때문입니다. 노트북 환경은 항상 개발을 하는게 아니기 때문에 idle 상태로 대기하는 시간이 많습니다. 작은 배치 사이즈로 운영되는 인퍼런스의 경우, 트래픽에 따라 사용량이 달라질 수 있습니다.\n따라서 이런 상황에서는 항상 리소스를 점유하기 보다 필요할 때 busting 가능한 방식으로 운영하는 것이 효율적입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: cuda-vector-add\nspec:\n  restartPolicy: OnFailure\n  containers:\n    - name: cuda-vector-add\n      image: &quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;\n      resources:\n        limits:\n          nvidia.com/gpu: 1 # GPU 1개 요청하기</code></pre></div>\n<p>쿠버네티스에서는 디바이스 플러그인을 통해 Pod가 GPU 리소스를 요청할 수 있습니다.\n하지만 <strong>Pod는 하나 이상의 GPU만 요청할 수 있으며 CPU와 달리 GPU의 일부(fraction)를 요청하는 것은 불가능</strong>합니다. 예를 들어 간단한 실험에 최신 버전의 고성능 GPU 1개를 온전히 할당 받는 것은 낭비입니다. NVIDIA 문서에서는 SW/HW 관점에서 GPU 리소스를 효율적으로 사용하기 위해 다양한 방법을 소개합니다. 그 중 <strong>Time Slicing</strong>과 <strong>MIG</strong>에 대해 알아보겠습니다.</p>\n<br>\n<h2 id=\"time-slicing\" style=\"position:relative;\"><a href=\"#time-slicing\" aria-label=\"time slicing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Time Slicing</h2>\n<p>Time Slicing은 GPU의 <strong>시간 분할 스케줄러</strong>입니다.\n파스칼 아키텍쳐부터 지원하는 <strong>compute preemption</strong> 기능을 활용한 방법입니다.\n각 컨테이너는 공평하게 <code class=\"language-text\">timeslice</code>를 할당받게 되지만 전환할 때 <code class=\"language-text\">context switching</code> 비용이 발생할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> ConfigMap\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> time<span class=\"token punctuation\">-</span>slicing<span class=\"token punctuation\">-</span>config\n  <span class=\"token key atrule\">namespace</span><span class=\"token punctuation\">:</span> gpu<span class=\"token punctuation\">-</span>operator\n<span class=\"token key atrule\">data</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">a100-40gb</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token punctuation\">-</span>\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> v1\n    <span class=\"token key atrule\">sharing</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">timeSlicing</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nvidia.com/gpu\n          <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nvidia.com/mig<span class=\"token punctuation\">-</span>1g.5gb\n          <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span>\n  <span class=\"token key atrule\">tesla-t4</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token punctuation\">-</span>\n    <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> v1\n    <span class=\"token key atrule\">sharing</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">timeSlicing</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> nvidia.com/gpu\n          <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">4</span></code></pre></div>\n<p><strong>NVIDIA GPU Operator</strong>에서는 위와 같이 <code class=\"language-text\">ConfigMap</code>을 사용하거나 <code class=\"language-text\">node label</code>을 통해 설정할 수 있습니다. 설정한 이후에 노드를 확인해보면 아래와 같이 리소스에 값이 추가된 것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">$ kubectl describe node $NODE\n\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n  <span class=\"token key atrule\">allocatable</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span></code></pre></div>\n<p>최대 8개 컨테이너까지 <code class=\"language-text\">timeslice</code> 방식으로 shared GPU를 사용할 수 있다는 것을 의미합니다. 이 방법은 <strong>GPU 메모리의 limit 설정을 강제하는 것이 아니기 때문에 OOM이 발생</strong>할 수도 있습니다. 이를 방지하려면 GPU를 사용하는 컨테이너 수를 모니터링하고 <code class=\"language-text\">Tensorflow</code>나 <code class=\"language-text\">PyTorch</code> 같은 프레임워크에서 총 GPU 메모리 제한 설정이 필요합니다.</p>\n<br>\n<h2 id=\"multi-instance-gpu-mig\" style=\"position:relative;\"><a href=\"#multi-instance-gpu-mig\" aria-label=\"multi instance gpu mig permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Multi instance GPU (MIG)</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1bJYen4Q33jEa9yHcp4LR3NOPNNzTMZCR\" alt=\"mig\"></p>\n<p>MIG는 A100과 같은 <strong>암페어 아키텍처 기반 GPU를 최대 7개의 개별 GPU 인스턴스로 분할해서 사용</strong>할 수 있는 기능입니다.\n분할된 인스턴스를 <strong>파티션</strong>이라고 부르는데, 각 파티션은 물리적으로 격리되어 있기 때문에 안전하게 병렬로 사용할 수 있습니다.</p>\n<table>\n<thead>\n<tr>\n<th>partition size</th>\n<th>GPU instances</th>\n<th>Compute units</th>\n<th>Memory units</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1g.5gb</td>\n<td>7</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2g.10gb</td>\n<td>3</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3g.20gb</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>위의 표와 같이 설정을 통해 파티션 크기를 조정할 수 있습니다. 표에서 unit은 하나의 파티션에 몇 개가 할당되는지를 의미합니다.\nA100의 경우, 최대 7개의 <code class=\"language-text\">compute unit</code>과 8개의 <code class=\"language-text\">memory unit</code>을 가질 수 있습니다 (각 5GB 메모리). 파티션은 <code class=\"language-text\">&lt;compute&gt;g.&lt;memory&gt;gb</code> 형식을 따르고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\">$ kubectl label nodes $NODE nvidia.com/mig.config=all<span class=\"token punctuation\">-</span>1g.5gb\n$ kubectl describe node $NODE\n\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">capacity</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7</span>\n  <span class=\"token key atrule\">allocatable</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7</span></code></pre></div>\n<p>이번에도 노드 설정 후, 값을 확인해보면 7이 들어가 있습니다.\n<code class=\"language-text\">1g.5gb</code> 크기의 파티션을 7개까지 사용할 수 있다는 의미입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">apiVersion</span><span class=\"token punctuation\">:</span> v1\n<span class=\"token key atrule\">kind</span><span class=\"token punctuation\">:</span> Deployment\n<span class=\"token key atrule\">metadata</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> cuda<span class=\"token punctuation\">-</span>vectoradd\n<span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">replicas</span><span class=\"token punctuation\">:</span> <span class=\"token number\">7</span>\n  <span class=\"token key atrule\">template</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">spec</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">nodeSelector</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">nvidia.com/gpu.product</span><span class=\"token punctuation\">:</span> A100<span class=\"token punctuation\">-</span>SXM4<span class=\"token punctuation\">-</span>40GB<span class=\"token punctuation\">-</span>MIG<span class=\"token punctuation\">-</span>1g.5gb\n    <span class=\"token key atrule\">containers</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> vectoradd\n      <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> nvidia/samples<span class=\"token punctuation\">:</span>vectoradd<span class=\"token punctuation\">-</span>cuda11.2.1\n      <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">limits</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">nvidia.com/gpu</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1</span></code></pre></div>\n<p>위와 같이 MIG를 통해 Pod 마다 1개의 파티션을 갖도록 설정해서 7개의 replica 구성하는 것도 가능합니다. 이처럼 사용자는 <strong>MIG를 통해 GPU를 최대로 활용</strong>할 수 있습니다.</p>\n<br>\n<h2 id=\"time-slicing-vs-mig\" style=\"position:relative;\"><a href=\"#time-slicing-vs-mig\" aria-label=\"time slicing vs mig permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Time Slicing vs MIG</h2>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>MIG</th>\n<th>Time Slicing</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Partition Type</td>\n<td>Physical</td>\n<td>Logical</td>\n</tr>\n<tr>\n<td>Max Partitions</td>\n<td>7</td>\n<td>Unlimited</td>\n</tr>\n<tr>\n<td>Memory Protection</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Error Isolation</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Reconfigure</td>\n<td>When idle</td>\n<td>Dynamic</td>\n</tr>\n</tbody>\n</table>\n<p>두 방식을 비교해보면 위의 표와 같습니다.\nTime Slicing 방식은 7개 이상의 컨테이너를 사용할 수 있습니다. 따라서 <strong>bursting 워크로드에 적합한 방식</strong>이라고 볼 수 있습니다. 반면 <strong>MIG는 적은 양의 고정된 사용량을 가지는 워크로드에 적합</strong>합니다.\nA100은 MIG를 통해 분할하고 그 외의 GPU는 Time Slicing을 사용하는 방식으로 함께 사용할 수 있으니 워크로드에 맞는 방식을 선택하는 것이 중요합니다.</p>\n<br>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=X876kr-LkPA\">Kubecon 2022 - Improving GPU Utilization using Kubernetes</a></li>\n<li><a href=\"https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/overview.html\">https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/overview.html</a></li>\n</ul>","excerpt":"GPU는 강력한 연산 기능을 제공하지만 비용이 많이 들기 때문에 제한된 리소스를 효율적으로 활용하는 것 이 중요합니다. 이는 온프레미스, 클라우드 환경 모두 해당합니다. 이번 글에서는 NVIDIA GPU의 리소스 공유를 지원하기 위한 방법으로 Time Slicing과 MIG에 대해 정리해보려 합니다. GPU 리소스가 낭비되고 있다? utilization 여러 아키텍쳐(암페어, 파스칼 등)로 구성된 GPU들을 모아 쿠버네티스 노드 풀을 구성하고 사용자들은 GPU 리소스를 할당받아 사용하는 환경이라고 가정해보겠습니다. 사용자들은 GPU…"}}}},"pageContext":{"slug":"gpu-utilization","basePath":"","prev":null,"next":{"slug":"airflow-worker-keda-autoscaler","publishDate":"2022-06-24"}}}}