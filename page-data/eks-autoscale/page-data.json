{"componentChunkName":"component---src-templates-post-js","path":"/eks-autoscale/","result":{"data":{"contentfulPost":{"id":"777ba93e-b22c-5e74-9f0f-03d3290551b1","title":"EKS의 AutoScaling 이해하기","slug":"eks-autoscale","metaDescription":null,"publishDate":"November 23, 2019","publishDateISO":"2019-11-23","tags":[{"title":"DevOps","id":"701ee587-d6e3-5391-af93-e295765b6f45","slug":"devops"}],"heroImage":{"id":"f36c235f-3e3e-517d-bd80-697bc6183072","title":"cover-devops","fluid":{"aspectRatio":1.5,"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50 1080w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1080&h=720&q=50&fm=webp 1080w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/7KaSTt3mdmrYq2ZK1RiJku/dafd981ff3686217ac151b562e8b1412/cover_devops.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"93814292-477d-5d50-b6f9-361473d42214","childMarkdownRemark":{"id":"2d86dba3-5c08-57c1-b59b-1a0ef1266b99","timeToRead":2,"html":"<p>오늘은 Kubernetes의 Cluster AutoScaling에 대해 정리해보려 합니다.\n그 다음 EKS에서는 어떻게 적용할 수 있는지, 어떤 효과를 볼 수 있는지 알아보겠습니다.</p>\n<br>\n<h2 id=\"kubernetes-cluster-autoscaling\" style=\"position:relative;\"><a href=\"#kubernetes-cluster-autoscaling\" aria-label=\"kubernetes cluster autoscaling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Kubernetes Cluster AutoScaling</h2>\n<p>Kubernetes는 Cluster AutoScaler를 통해 동적으로 인프라를 확장할 수 있습니다.\nCluster AutoScaler는 Pod의 리소스 요청에 따라 클러스터의 노드를 추가하거나 제거합니다.\n만약 리소스 부족으로 인해 스케줄링 대기 상태의 Pod가 존재하는 경우 Cluster AutoScaler가 노드를 추가합니다.\n추가 시 설정한 Min, Max 값을 넘어가지 않도록 구성 할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1XDum_t6J_lEt88o0X776XUxCHB-Ry_rW\"></p>\n<p>먼저 AutoScaler를 설정하면 대기 상태의 Pod을 주기적으로 확인합니다.\n클러스터 리소스가 부족하면서 사용자가 정의한 최대 노드 수에 도달하지 않은 경우 노드 프로비저닝을 요청합니다.\n노드가 추가되면 스케줄러에 의해 대기 상태의 Pod들이 새로운 노드로 할당됩니다.</p>\n<p>노드를 축소하는 프로세스는 사용자가 정의한 메트릭에 의해 시작됩니다.\n예를 들어 CPU Utilization이 50% 이하로 설정했다고 가정해보겠습니다.\nCluster AutoScaler는 삭제할 노드에서 실행 중인 Pod를 다른 노드로 안전하게 이동시킬 수 있는지 확인합니다.\n이때 Pod가 로컬 스토리지를 사용하고 있었다면 데이터 유실이 발생할 수 있으니 <strong>PV 사용</strong>을 권장합니다.\n이러한 확인 프로세스를 노드 또는 Pod 단위로 수행하고 Pod이 모두 이동하게 되면 노드를 제거합니다.</p>\n<br>\n<h2 id=\"eks-autoscaler\" style=\"position:relative;\"><a href=\"#eks-autoscaler\" aria-label=\"eks autoscaler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EKS AutoScaler</h2>\n<p>EKS의 AutoScaler는 AWS의 Auto Scaling Group을 활용하고 있습니다.\nASG는 주기적으로 현재 상태를 확인하고 <strong>Desired State</strong>로 변화하는 방식으로 동작합니다.\n사용자는 클러스터 노드 수를 제한하는 Min, Max 값을 지정할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1qZRhnghSiYRTzKTFJat2594-mv3hdPKS\"></p>\n<p>위와 같이 목적에 따라 여러 종류의 ASG를 설정하고 서로 다른 <strong>AutoScaling Policy</strong>를 적용할 수 있습니다.\n<strong>Spot Instance Group</strong>을 설정하면 저렴하지만 입찰 가격에 의해 언제든지 인스턴스가 내려갈 수 있습니다.\n하지만 EKS의 <strong>Spot Interrupt Handler (DeamonSet)</strong> 에 의해 정상적으로 실행 중인 Pod들을 재배치할 수 있습니다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1jErnWXOdrtMQU0o1Aa504yZGMqSy8dbf\"></p>\n<p>그리고 위 그림과 같이 앞서 설정한 Cluster AutoScaler에 의해 새로운 Spot Instance가 추가됩니다.\n분석용 클러스터 같은 경우, 주말과 야간 시간에 사용량이 낮다는 사실을 이미 알고 있기 때문에\n<strong>CloudWatch Scheduled Policy</strong>를 통해 노드를 축소하면 비용을 절감할 수 있습니다.</p>\n<br>\n<h2 id=\"eks-autoscaler-설정\" style=\"position:relative;\"><a href=\"#eks-autoscaler-%EC%84%A4%EC%A0%95\" aria-label=\"eks autoscaler 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EKS AutoScaler 설정</h2>\n<p>먼저 EKS에 ASG 권한을 가지는 IAM Role을 만들어서 Worker Node 보안 그룹에 추가합니다.\n다음으로 ASG 그룹 태그를 설정하고 yaml 파일을 클러스터에 배포합니다.\n자세한 내용은 <a href=\"https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/cluster-autoscaler.html\">공식 문서</a>를 통해 진행하실 수 있습니다.\n만약 Policy로 메모리 지표를 사용하고 싶다면 각 노드에 <strong>CloudWatch Agent</strong>를 배포해야 합니다.</p>\n<br>","excerpt":"오늘은 Kubernetes의 Cluster AutoScaling에 대해 정리해보려 합니다.\n그 다음 EKS에서는 어떻게 적용할 수 있는지, 어떤 효과를 볼 수 있는지 알아보겠습니다. Kubernetes Cluster AutoScaling Kubernetes는 Cluster AutoScaler를 통해 동적으로 인프라를 확장할 수 있습니다.\nCluster AutoScaler는 Pod의 리소스 요청에 따라 클러스터의 노드를 추가하거나 제거합니다.\n만약 리소스 부족으로 인해 스케줄링 대기 상태의 Pod가 존재하는 경우 Cluster AutoScaler…"}}}},"pageContext":{"slug":"eks-autoscale","basePath":"","prev":{"slug":"aws-cert","publishDate":"2019-11-30"},"next":{"slug":"eks-vpc-cni","publishDate":"2019-11-04"}}}}