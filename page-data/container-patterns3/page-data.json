{"componentChunkName":"component---src-templates-post-js","path":"/container-patterns3/","result":{"data":{"contentfulPost":{"id":"ef37ff49-0dda-5d61-af33-46098b19d6ab","title":"분산 컨테이너 환경에서의 디자인 패턴 (3)","slug":"container-patterns3","metaDescription":null,"publishDate":"April 06, 2019","publishDateISO":"2019-04-06","tags":[{"title":"Develop","id":"59312ab7-0dd9-5837-a3ba-024abd83a225","slug":"develop"}],"heroImage":{"id":"1563c3af-a4e8-5db4-acb2-9bfd9fdb294d","title":"cover-develop","fluid":{"aspectRatio":1.5,"src":"//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=1800&q=50","srcSet":"//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=450&h=300&q=50 450w,\n//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=900&h=600&q=50 900w,\n//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=1800&h=1200&q=50 1800w","srcWebp":"//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=1800&q=50&fm=webp","srcSetWebp":"//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=450&h=300&q=50&fm=webp 450w,\n//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=900&h=600&q=50&fm=webp 900w,\n//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=1800&h=1200&q=50&fm=webp 1800w","sizes":"(max-width: 1800px) 100vw, 1800px"},"ogimg":{"src":"//images.ctfassets.net/tushy4jlcik7/4W9SzEIJpHuwsUBnxSSypH/3a18765095ea5756c742b7adb83a0518/cover_develop.jpg?w=1800&fl=progressive&q=50"}},"body":{"id":"31e2a29c-b7e9-5f6f-8198-cba9bbc26501","childMarkdownRemark":{"id":"64d104f3-19d3-5384-b65c-d6a20e35d9ef","timeToRead":3,"html":"<p>구글 클라우드 팀이 Kubernetes와 같은 Container Orchestration 기술을 개발하면서 겪은\n분산 컨테이너 환경에서의 디자인 패턴에 대해 정리한 내용입니다.\n지난 글에 이어서 배치 작업에 관련된 디자인 패턴에 대한 내용입니다.</p>\n<ul>\n<li><a href=\"http://swalloow.github.io/container-patterns\">분산 컨테이너 환경에서의 디자인 패턴 1. Single-Node Patterns</a></li>\n<li><a href=\"http://swalloow.github.io/container-patterns2\">분산 컨테이너 환경에서의 디자인 패턴 2. Multi-Node Serving Patterns</a></li>\n<li><a href=\"http://swalloow.github.io/container-patterns3\">분산 컨테이너 환경에서의 디자인 패턴 3. Batch Computational Patterns</a></li>\n</ul>\n<br>\n<h2 id=\"batch-computational-patterns\" style=\"position:relative;\"><a href=\"#batch-computational-patterns\" aria-label=\"batch computational patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Batch Computational Patterns</h2>\n<p>앞서 설명했던 long-running computation 패턴과 달리 이번에는 일시적으로 돌아가는 Batch Computational 패턴에 대한 내용이다.\n배치 프로세스는 사용자 로그 데이터의 수집, 데이터 분석 또는 미디어 파일의 변환 등에 자주 사용된다.\n일반적으로 대용량 데이터의 처리 속도를 높이기 위해 병렬 처리를 사용한다는 특징이 있다.\n이에 대해 가장 유명한 패턴은 MapReduce 패턴이며 이미 많이 사용하고 있다.</p>\n<br>\n<h2 id=\"work-queue-systems\" style=\"position:relative;\"><a href=\"#work-queue-systems\" aria-label=\"work queue systems permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Work Queue Systems</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1lgFxyQ5EfZ5IXTf4SPxZ1liOLuSq6-Z5\"></p>\n<p>배치 프로세싱의 가장 간단한 형태가 바로 Work Queue System 이다.\nQueue 형태의 작업 대기열이 있고 이를 관리해주는 컨테이너가 Worker에 작업을 분배해주는 형태이다.\n일반적으로 작업 대기열에서 각 작업은 일정 시간 내에 수행되어야 하며 처리량에 따라 Worker는 Scale-out 할 수 있어야 한다.\n작업이 지속적으로 지연된다면 큐에 작업이 계속 쌓이게 되고 이는 장애로 이어질 수 있다.</p>\n<br>\n<h2 id=\"source-worker-container-interface\" style=\"position:relative;\"><a href=\"#source-worker-container-interface\" aria-label=\"source worker container interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Source, Worker Container Interface</h2>\n<ul>\n<li>Source 컨테이너와 Worker 컨테이너에 대한 인터페이스가 필요</li>\n<li>작업 대기열 스트림을 제공하는 컨테이너와 실제로 작업을 처리하는 컨테이너를 분리</li>\n<li>Source 컨테이너가 Ambassador 역할을 수행 (Storage, Network, Kafka/Redis Queue에 대한 통신을 맡음)</li>\n<li>현재 대기열에 쌓인 작업 리스트, 작업에 대한 구체적인 정보를 알려주는 Work Queue API 구현 필요</li>\n<li>작업에 대한 설정 정보는 Kubernetes의 ConfigMap과 ConfigMapVolume을 활용해서 구현</li>\n<li>Worker 컨테이너는 Rolling Update, Dynamic Scaling 기능이 필요</li>\n<li>Work Queue, Worker Process에 대한 모니터링이 필요</li>\n</ul>\n<br>\n<h2 id=\"event-driven-batch-processing\" style=\"position:relative;\"><a href=\"#event-driven-batch-processing\" aria-label=\"event driven batch processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Event-Driven Batch Processing</h2>\n<p>앞서 설명한 작업 대기열 처리는 하나의 입력을 하나의 출력으로 변환할 때 많이 사용한다.\n하지만 단일 작업 이상을 처리해야 한다거나 단일 입력에서 여러 출력을 생성해야 하는 경우도 있다.\n이러한 경우 여러 작업 대기열을 연결하는 이벤트 스트림 방식을 통해 작업을 수행한다.\n이전 단계의 작업이 완료되면 이벤트가 발생하고 이벤트를 통해 다음 단계의 대기열로 이동하는 형태이다.</p>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1fOMS2fS1bVaKHobo225bRPD-2z8Zaoz0\"></p>\n<p>스트림 처리에 대한 여러 패턴이 존재하지만 위 그림은 그 중 하나인 Sharder에 대한 내용이다.\nSharder는 작업 큐 2개를 두고 만일 두 개의 큐가 모두 healthy 하다면, id 기준으로 작업을 분배한다.\n만일 어느 하나가 unhealthy 하다면, 새로운 큐를 생성해서 다른 한쪽으로 작업을 분배한다.\n이를 통해 단일 큐를 사용하는 것보다 안정적이고 작업을 분산처리할 수 있다.</p>\n<p>이외에도 Publisher/Subscriber, Merger, Splitter 등의 패턴이 있다.\nSpark의 DAG와 같은 그림을 떠올린다면 어떤 내용인지 바로 이해할 수 있을 것이다.\n처리 시간이 비교적 짧은 이벤트 기반의 배치 프로세싱은 앞서 소개했던 FaaS 패턴으로 구현할 수도 있다.\nAWS의 Lambda, Stream, Kinesis Firehose를 떠올리면 된다.</p>\n<br>\n<h2 id=\"coordinated-batch-processing\" style=\"position:relative;\"><a href=\"#coordinated-batch-processing\" aria-label=\"coordinated batch processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Coordinated Batch Processing</h2>\n<p><img src=\"http://drive.google.com/uc?export=view&#x26;id=1o4P4CyxS-V3ZMHQc5J0M7BwCdp937Q0H\"></p>\n<p>처음에는 단일 대기열로 처리했지만 더 복잡한 배치 작업을 처리하기 위해 대기열을 분할하고 연결했다.\n하지만 최종 단계에서는 결국 원하는 결과를 생성하기 위해 여러 출력을 하나로 합쳐야 한다.\n합치는 작업은 여러 개의 작업 큐가 모두 종료되고 난 이후에 수행되어야 한다.\n이와 관련된 패턴으로 Join과 Reduce가 있다.\nJoin과 달리 Reducer의 경우 parallel 하게 시작할 수 있다는 차이가 있다.\ncount, sum, histogram을 추출하는 작업이 이에 해당한다.</p>\n<br>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>책을 마무리할 무렵 Kubernetes Korea Group 세미나에서 책 저자의 발표를 들을 수 있었다.\n다른 컨퍼런스에서 진행했던 발표들과 내용이 유사했고 Azure Kuberentes Service에 대한 홍보가 짙었지만\n클라우드 네이티브와 최근 개발 환경의 변화에 대한 생각을 들을 수 있는 시간이었다.</p>\n<p>그동안 개발할 때 정형화 된 패턴을 공부하지 않았음에도 비슷한 형태로 설계된 경우를 많이 볼 수 있었다.\n하지만 패턴을 한번 정리하고 나면 더 명확하게 이해되고 현재 상황에 맞는 패턴을 적용할 수 있게 되는 것 같다.\n마틴 파울러의 리팩토링 책도 그렇고 이번 책 또한 그런 부분을 느낄 수 있었다.</p>\n<ul>\n<li><a href=\"https://static.googleusercontent.com/media/research.google.com/ko//pubs/archive/45406.pdf\">GooglePaper - Design patterns for container-based distributed systems</a></li>\n<li>Designing Distributed Systems: Brendan Burns</li>\n</ul>\n<br>","excerpt":"구글 클라우드 팀이 Kubernetes와 같은 Container Orchestration 기술을 개발하면서 겪은\n분산 컨테이너 환경에서의 디자인 패턴에 대해 정리한 내용입니다.\n지난 글에 이어서 배치 작업에 관련된 디자인 패턴에 대한 내용입니다. 분산 컨테이너 환경에서의 디자인 패턴 1. Single-Node Patterns 분산 컨테이너 환경에서의 디자인 패턴 2. Multi-Node Serving Patterns 분산 컨테이너 환경에서의 디자인 패턴 3. Batch Computational Patterns Batch Computational Patterns…"}}}},"pageContext":{"slug":"container-patterns3","basePath":"","prev":{"slug":"openinfra","publishDate":"2019-07-20"},"next":{"slug":"container-patterns2","publishDate":"2019-03-23"}}}}