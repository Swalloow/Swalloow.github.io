<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>swalloow.github.io/</title>
   
   <link>http://swalloow.github.io/</link>
   <description>About Data Science, Data Engineering</description>
   <language>ko-KO</language>
   <managingEditor> Swalloow</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Pandas DataFrame을 병렬처리 하는 방법</title>
	  <link>//pandas-parallel</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-27T19:18:00+09:00</pubDate>
	  <guid>//pandas-parallel</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>Scikit-learn의 모델들은 cython과 joblib으로 최적화 및 자동 병렬처리 되도록 설계되어 있지만,
Pandas는 여전히 내부적으로 병렬처리 기능을 지원하지 않습니다.</p>

<p>하지만, 큰 규모의 DataFrame을 돌리다보면 전처리에도 시간이 많이 걸리게 됩니다.
그런 경우에 병렬처리를 통해 속도를 개선할 수 있습니다.</p>

<p>이 포스팅에서는 가장 간단한 CPU 프로세스 병렬처리를 다루도록 하겠습니다. 방법은 간단합니다.
거대한 DataFrame을 CPU 코어 수 만큼 분할하고, 전처리 기능을 수행한 다음 다시 합치면 됩니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="kn">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>

<span class="n">num_cores</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">iris</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sns</span><span class="o">.</span><span class="n">load_dataset</span><span class="p">(</span><span class="s">'iris'</span><span class="p">))</span></code></pre></figure>

<p>예시로 iris 데이터를 사용하겠습니다.
cpu 코어의 수는 <code class="highlighter-rouge">multiprocessing.cpu_count()</code> 함수를 통해서 얻으실 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">parallelize_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="n">df_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">num_cores</span><span class="p">)</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">num_cores</span><span class="p">)</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">df_split</span><span class="p">))</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">df</span></code></pre></figure>

<p>parallelize_dataframe은 어떤 전처리 함수가 들어왔을 때 CPU 병렬처리를 도와주는 함수입니다.
multiprocessing.Pool을 이용하여 분할된 DataFrame에 함수를 적용시키고,
pd.concat()으로 다시 합치는 과정입니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">multiply_columns</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">data</span><span class="p">[</span><span class="s">'length_of_word'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'species'</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span></code></pre></figure>

<p>각 종 이름의 글자 수를 세는 전처리 함수를 예로 들어 속도차이를 확인해보겠습니다.
결과는 아래와 같습니다.</p>

<p>​   ​</p>

<p><img src="/assets/images/pandas-parallel.png" alt="pandas-parrallel" /></p>

<p>다른 방법으로 Pandas의 engine에 Dask를 사용하는 방법도 있습니다.
<a href="http://dask.readthedocs.io/en/latest/">http://dask.readthedocs.io/en/latest/</a></p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>DataFrame을 MySQL에 저장하는 방법</title>
	  <link>//dataframe-to-mysql</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-26T19:18:00+09:00</pubDate>
	  <guid>//dataframe-to-mysql</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>DataFrame을 MySQL에 저장하기 위해 먼저 커넥터가 필요합니다.
파이썬3에서는 <code class="highlighter-rouge">MySQLdb</code>를 지원하지 않기 때문에, <code class="highlighter-rouge">pymysql</code>로 불러와야 합니다.
꼭 pymysql이 아니어도 상관없지만, 사용해보면 <code class="highlighter-rouge">mysql-connector</code> 보다 빠르다는걸 체감할 수 있습니다.
먼저, 필요한 패키지를 설치해줍니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># python3</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">pymysql</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">sqlalchemy</span></code></pre></figure>

<p>​</p>

<h2 id="sqlalchemy-pymysql-mysqldb">SQLAlchemy, pymysql, MySQLdb</h2>

<p><code class="highlighter-rouge">install_as_MySQLdb()</code> 함수를 통해 MySQLdb와 호환 가능합니다.
이제 sqlalchemy를 통해 DB에 연결할 수 있습니다.
주소에서 root, password, table은 DB에 맞게 변경해야 합니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="c"># MySQL Connector using pymysql</span>
<span class="n">pymysql</span><span class="o">.</span><span class="n">install_as_MySQLdb</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">MySQLdb</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">"mysql+mysqldb://root:"</span><span class="o">+</span><span class="s">"password"</span><span class="o">+</span><span class="s">"@localhost/table_name"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span></code></pre></figure>

<p>​</p>

<h2 id="mysql-">MySQL에 저장하기</h2>

<p>이제 DataFrame을 MySQL에 테이블 형태로 저장할 차례입니다.
아래와 같이 pandas의 <code class="highlighter-rouge">to_sql()</code> 함수를 사용하여 저장하면 됩니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">df</span><span class="o">.</span><span class="n">to_sql</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">table</span><span class="p">,</span> <span class="n">con</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s">'append'</span><span class="p">)</span></code></pre></figure>

<p>자주 사용할 수 있으니 함수로 따로 설정해주면 편합니다.</p>

<script src="https://gist.github.com/Swalloow/9dbbba9579b87548c71af68337f95299.js"></script>

<p>​</p>

	  ]]></description>
	</item>

	<item>
	  <title>DB 테이블을 DataFrame으로 읽어오는 방법</title>
	  <link>//db-to-dataframe</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-14T19:18:00+09:00</pubDate>
	  <guid>//db-to-dataframe</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>본 포스팅에서는 예시를 MySQL로 들지만 sqlalchemy의 커넥터만 변경해주면,
MySQL 뿐만 아니라 모든 데이터베이스에 적용가능합니다.</p>

<p>먼저 sqlalchemy가 설치되어 있지 않다면 설치해줍니다.
sqlalchemy와 mysql을 연결하는 패키지가 필요합니다.</p>

<p>파이썬2를 사용한다면 <code class="highlighter-rouge">mysql-python</code>,
3을 사용한다면 <code class="highlighter-rouge">pymysql</code>을 설치해주면 됩니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># python2</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">mysql</span><span class="o">-</span><span class="n">python</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">sqlalchemy</span>

<span class="c"># python3</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">pymysql</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">sqlalchemy</span></code></pre></figure>

<p>​</p>

<p>이제 sqlalchemy를 통해 DB에 연결해보겠습니다.
주소에서 root, password, table은 DB에 맞게 변경해야 합니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sqlalchemy</span> <span class="kn">import</span> <span class="n">create_engine</span>

<span class="n">engine</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">'mysql://root:password@localhost/table'</span><span class="p">,</span> <span class="n">convert_unicode</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span></code></pre></figure>

<p>​</p>

<p>마지막으로 pandas를 통해 table을 읽어들일 차례다.
pandas의 read_sql 은 0.19 버전부터 생겨났으며, sqlalchemy를 필수로 사용하도록 되어 있다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_table</span><span class="p">(</span><span class="s">'table_name'</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span></code></pre></figure>

<p>이게 전부이다. pandas는 강력하다.</p>

<p>​</p>

<h2 id="mysql-dump---">MySQL dump 파일을 읽어오는 방법</h2>

<p>추가로 외부로부터 데이터를 넘겨받을 때 DB dump 파일 (.sql) 을 넘겨받는 경우가 있다.
데이터베이스 전체를 받은 dump 파일이라면, 커멘드에 다음과 같이 입력한다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># root, database, data.sql은 알아서 수정</span>
<span class="err">$</span> <span class="n">mysqldump</span> <span class="o">-</span><span class="n">u</span> <span class="n">root</span> <span class="o">-</span><span class="n">p</span> <span class="n">database</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">sql</span></code></pre></figure>

<p>​</p>

<p>특정 테이블만 받고 싶다면, 커멘드에 다음과 같이 입력한다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># root, table, database, data.sql은 알아서 수정</span>
<span class="err">$</span> <span class="n">mysqldump</span> <span class="o">-</span><span class="n">u</span> <span class="n">root</span> <span class="o">-</span><span class="n">p</span> <span class="n">database</span> <span class="n">table</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">sql</span></code></pre></figure>

<p>​</p>

<p>위와 같은 과정이 끝나면, 나의 MySQL 계정에 데이터가 저장된 것을 확인할 수 있다.
이후에는 앞에서 설명한대로 pandas를 통해 DataFrame으로 변환하면 된다.</p>

<p>​</p>

	  ]]></description>
	</item>


</channel>
</rss>
