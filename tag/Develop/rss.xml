<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>swalloow.github.io/</title>
   
   <link>http://swalloow.github.io/</link>
   <description>About Data Science, Data Engineering</description>
   <language>ko-KO</language>
   <managingEditor> Swalloow</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Docker 간편한 설치부터 실행까지</title>
	  <link>//docker-install</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-21T19:18:00+09:00</pubDate>
	  <guid>//docker-install</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>Docker는 오픈소스 컨테이너입니다. 기존의 가상머신과 비슷하면서도 훨씬 가벼운 형태라고 볼 수 있습니다. 그렇다면 VMWare, VirtualBox와 같은 기존의 가상머신과 Docker Container가 어떻게 다른지 살펴보겠습니다.</p>

<p><img src="/assets/images/vm-docker.png" alt="vm-docker" /></p>

<p>먼저 기존의 가상머신(Virtual Machine)을 보면 Hypervisor(VMWare, VirtualBox…) 위에 GuestOS가 올라간 형태임을 알 수 있습니다. OS가 올라갔다는 것은 말 그대로 x86 하드웨어가 그대로 가상화 된 것입니다. 가상머신을 설치하고 메모리 영역을 확인해보면 호스트 메모리와 게스트 메모리를 볼 수 있는데, 게스트 메모리를 얼마나 할당할 것인지에 따라 가상머신의 성능이 변하기도 합니다.</p>

<p>반면에 Docker는 Docker Engine 위에 Application이 올라간 것을 볼 수 있습니다. 즉, Docker Engine을 통해 Host OS 위에서 컨테이너가 생성되는 것입니다. 여기서 컨테이너는 리눅스 커널의 <code class="highlighter-rouge">cgroups, namespaces</code> 등의 기능을 사용해 가상공간을 생성할 수 있도록 하는 기능입니다.</p>

<p>​   ​</p>

<h4 id="section">컨테이너가 가상머신보다 뛰어난 점은?</h4>

<p>기본적으로 가상머신을 사용하게 되면 상세 설정을 해주지 않는 한 메모리, CPU 코어, 프로세스 등 각종 성능 손실이 발생합니다. 반면에 컨테이너는 Host OS의 커널은 그대로 사용하고 일부분만 패키징 되기 때문에 용량이 크게 줄어들 뿐만 아니라, 프로세스 영역도 기존의 OS와 공유해서 사용합니다. 정리하자면, <u>컨테이너는 하드웨어를 가상화하는 계층이 없기 때문에 메모리 접근, 파일시스템, 네트워크 속도가 가상 머신에 비해 월등히 빠릅니다</u>.</p>

<p>​   ​</p>

<h4 id="boot2docker">Boot2Docker</h4>

<p>앞서 말했던 것 처럼 Docker는 리눅스 커널의 컨테이너 기능을 기반으로 하기 때문에 Windows나 OS X 환경에서 실행할 수 없습니다. 그래서 이를 지원하기 위해 나온 것이 <strong>Boot2Docker</strong> 입니다. Boot2Docker는 가상머신 안에 리눅스를 설치하고 Docker를 실행하는 방식으로 이를 해결했습니다.</p>

<p>하지만 15년 9월쯤 부터 <strong>boot2docker-cil이 deprecated</strong> 되었습니다. 이제 공식 레퍼런스를 보면 toolbox를 이용하여 설치하는 방법을 권장하고 있으며 기존의 boot2docker에서 이전하는 방법에 대해서도 설명하고 있습니다.</p>

<p>​   ​</p>

<h2 id="os-x-docker-">OS X에서 Docker 설치</h2>

<p>Docker를 설치하는 방법으로는 크게 2가지가 있습니다. 첫번째는 Docker for Mac으로 설치하는 방법이고, 두번째는 Docker Toolbox로 설치하는 방법입니다.</p>

<p>​   ​</p>

<h4 id="docker-for-mac-docker-toolbox-">Docker for Mac과 Docker Toolbox의 차이점은?</h4>

<p>가장 큰 차이점은 사용하는 가상머신이 다르다는 점입니다. Docker Toolbox 같은 경우에는 Boot2Docker에서 사용해왔던 VirtualBox를 그대로 사용합니다. 반면에 Docker for Mac은 <strong>HyperKit</strong> 이라는 macOS를 위한 경량화 가상머신을 사용합니다.</p>

<p><img src="/assets/images/docker-formac.png" alt="docker-formac" /></p>

<p>Docker Toolbox를 사용하는 경우, 위와 같이 <code class="highlighter-rouge">/usr/local/bin</code> 폴더에 docker, docker-compose, docker-machine이 설치됩니다. 그리고 가상화는 VirtualBox를 통해 이루어지게 됩니다.</p>

<p><img src="/assets/images/docker-toolbox.png" alt="docker-toolbox" /></p>

<p>반면에 Docker for Mac은 <code class="highlighter-rouge">Applications</code> 폴더 내에 app으로 관리할 수 있게 됩니다. 그리고 가상화는 오라클의 <strong>VirtualBox</strong> 을 통해 이루어집니다. 따라서, 둘다 설치할 필요가 없습니다.</p>

<p>만일 전부터 Docker를 써왔고, VirtualBox를 꼭 써야한다면, Docker Toolbox를 설치하시면 됩니다. 또는 “나는 App으로 관리하는게 편하다” 라고 한다면 Docker for Mac을 사용하시면 됩니다. 자세한 내용은 다음을 참고하시면 됩니다. <a href="https://docs.docker.com/docker-for-mac/docker-toolbox/">https://docs.docker.com/docker-for-mac/docker-toolbox/</a></p>

<p>만일 둘 다 설치했고, Docker toolbox를 제거하고 싶다면 다음 링크를 참고하시면 됩니다.
<a href="https://docs.docker.com/toolbox/toolbox_install_mac/#how-to-uninstall-toolbox">https://docs.docker.com/toolbox/toolbox_install_mac/#how-to-uninstall-toolbox</a></p>

<p>​   ​</p>

<h2 id="docker-">Docker 실행</h2>

<p>저는 Docker for Mac을 사용하여 설치했습니다.</p>

<p><img src="/assets/images/docker-run.png" alt="docker-run" /></p>

<p>어플리케이션 데몬을 실행시키면 이제 docker 명령어를 사용할 수 있게 됩니다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker version
docker info</code></pre></figure>

<p>이제 한번 테스트 해볼 시간입니다.
아래의 명령어를 통해 nginx 이미지를 만들고 80번 포트에 웹 서버를 띄워 보겠습니다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker run -d -p 80:80 --name webserver nginx</code></pre></figure>

<p><img src="/assets/images/docker-test.png" alt="docker-test" /></p>

<p>실행되고 있는 웹 서버를 중지하고 컨테이너를 삭제해보겠습니다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker ps
docker stop webserver
docker rm -f webserver</code></pre></figure>

<p>아직 이미지는 남아있는 상태입니다. 이미지까지 삭제해줍니다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">docker images
docker rmi nginx</code></pre></figure>

<p>자세한 Docker 사용법이나 명령어는 다음에 정리하도록 하겠습니다.</p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>자주 사용하는 리눅스 명령어 정리 (3) - Screen</title>
	  <link>//linux3</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-18T19:18:00+09:00</pubDate>
	  <guid>//linux3</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>Screen은 여러 프로세스 간에 물리적 콘솔을 다중화하는데 사용할 수있는 전체 화면 소프트웨어 프로그램이다.
하나의 단일 터미널 창 관리자에서 여러 개의 개별 터미널 인스턴스를 열 수 있는 사용자를 제공한다.</p>

<p>사실 다중 터미널이 필요한거라면 tmux나 iTerm이 더 편하다고 생각한다.
하지만, 스크린은 서버에서 백드라운드 데몬을 돌려야 할 때 아주 유용하다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">screen -S pingsession -d -m -L ping localhost</code></pre></figure>

<p>이 명령은 화면에 새로운 세션 (-m)을 만들고, 출력 (-L)을 기록하고, 즉시 분리 (-d) 명령이 실행되도록 지시한다.
로그는 현재 디렉토리의 screenlog.n 에 기록된다.</p>

<p>여기서 n은 화면 세션의 “창” 번호이다. 로깅은 정기적으로 버퍼링되고 플러시되며 로그 파일을 기록 할 수 있다.
화면 세션은 프로세스 제어, 즉 실행중인 데몬 중지 등을 지원한다.
이를 수행하기 위해 화면 세션은 세션 이름 (-S 세션 이름)으로 시작되어야하며 나중에 이름과 함께 종료 될 수 있다.</p>

<p>​   ​</p>

<h2 id="screen--">Screen 명령어 정리</h2>

<ul>
  <li>ctrl + a / d : screen 나갈 때</li>
  <li>ctrl + a / k : screen 죽일 때</li>
  <li>screen -ls : screen 목록 확인</li>
  <li>screen -r “name” : screen 재접속</li>
  <li>screen -S “name” : screen 생성</li>
  <li>~/.screenrc : 설정파일을 확인</li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>자주 사용하는 리눅스 명령어 정리 (2) - 쉘 스크립트</title>
	  <link>//linux2</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-16T19:18:00+09:00</pubDate>
	  <guid>//linux2</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>맥북을 사용하면서 가장 좋았던 점은 기본 운영체제가 유닉스 계열이다보니,
모든 것이 커멘드라인으로 해결된다는 점이었다. 특히 쉘 스크립트를 활용하면 간단한 자동화도 구현할 수 있다.
따라서, 이번 포스팅에서는 자동화를 위한 쉘 스크립트 문법을 정리해보려 한다.</p>

<p>​   ​</p>

<h2 id="section">쉘 스크립트란?</h2>

<p>문법에 대해 알기 이전에 쉘 스크립트가 어떤 역할을 하는지 알아야 한다.
기본적으로 우리가 사용하는 운영체제는 하드웨어 제어, CPU 스케줄링 등 많은 역할을 수행한다.
쉘은 운영체제 위에서 다양한 운영 체제 기능과 서비스를 구현하는 인터페이스를 제공하는 프로그램이다.
즉, 사용자와 맞닿아 있기 때문에 우리는 쉘의 명령어를 통해 직접 조작할 수 있는 것이다.</p>

<p>아래는 쉘 스크립트와 관련된 기본 명령어이다.</p>

<ul>
  <li>스크립트 실행 : sh {script.sh}</li>
  <li>스크립트 실행가능 지정 : chmod +x {script.sh}</li>
</ul>

<p>​   ​</p>

<h4 id="section-1">변수의 기본</h4>

<ul>
  <li>변수에 넣는 모든 값은 문자열로 취급한다.</li>
  <li>변수이름은 대소문자 구분, ‘=’ 좌우에는 공백 유지</li>
</ul>

<p>​   ​</p>

<h4 id="section-2">연산자</h4>

<ul>
  <li>OR : <code class="highlighter-rouge">||</code></li>
  <li>AND : <code class="highlighter-rouge">&amp;&amp;</code></li>
  <li>문자열 비교 : “string1”=”string2”</li>
</ul>

<p>​   ​</p>

<h4 id="if-else-">if-else 문</h4>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="k">if</span> <span class="o">[</span> <span class="k">case</span> <span class="o">]</span>; <span class="k">then
  </span><span class="nb">true
</span><span class="k">else
  </span><span class="nb">false
</span><span class="k">fi</span></code></pre></figure>

<p>​   ​</p>

<h4 id="case-">case 문</h4>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="k">case</span> <span class="nv">$answer</span> <span class="k">in
  </span>yes<span class="p">)</span>
  	<span class="nb">echo</span> <span class="s2">"yes"</span>
  no<span class="o">)</span>
  	<span class="nb">echo</span> <span class="s2">"no"</span>
<span class="k">esac</span></code></pre></figure>

<p>​   ​</p>

<h4 id="for-in-">for-in 문</h4>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="k">for </span>fname <span class="k">in</span> <span class="k">$(</span>ls .sh<span class="k">)</span>; <span class="k">do
  </span><span class="nb">echo</span> <span class="s2">"fname"</span>
<span class="k">done</span></code></pre></figure>

<p>​   ​</p>

<h4 id="while-">while 문</h4>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="k">while</span> <span class="o">[</span> 1 <span class="o">]</span>; <span class="k">do
  </span><span class="nb">echo</span> <span class="s2">"fname"</span>
<span class="k">done</span></code></pre></figure>

<p>​</p>

	  ]]></description>
	</item>

	<item>
	  <title>자주 사용하는 리눅스 명령어 정리 (1) - 기본 명령어</title>
	  <link>//linux1</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-15T19:18:00+09:00</pubDate>
	  <guid>//linux1</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>리눅스는 리누스 토발즈가 1991년 처음 개발을 시작한 오픈소스 소프트웨어이다.
보통 윈도우를 오래 사용하다보면 터미널보다 GUI에 익숙해지기 마련이다.
하지만 최근 맥북으로 갈아타면서 커멘드라인이 편하다는 걸 알게 되었고,
앞으로 좀 더 생산성을 높이기 위해 몇 가지 유용한 명령어들을 정리해보려 한다.</p>

<p>생활코딩에 리눅스에 대해 잘 정리한 강의가 있어 참고하면 좋다.
<a href="https://opentutorials.org/course/2598">https://opentutorials.org/course/2598</a></p>

<p>​   ​</p>

<h2 id="section">패키지 매니저</h2>

<p>리눅스는 패키지 매니저를 통해 설치되어 있지 않은 프로그램을 설치한다.
맥에서 사용하는 Brew를 떠올리면 이해하기 쉽다.</p>

<ul>
  <li>Ubuntu : apt-get</li>
  <li>CentOS : yum</li>
  <li>OS X : brew</li>
</ul>

<p>위와 같이 리눅스 배포판에 따라 패키지 매니저가 조금씩 다르지만, 사용법은 대체로 비슷한 편이다.
예를 들어 패키지를 설치할 때는 <code class="highlighter-rouge">apt-get install "package name"</code> 이런 식이다.
모든 패키지 매니저가 설치/업데이트/삭제 명령어를 가지고 있으며,
설치된 패키지를 관리하기 위한 명령어도 존재한다.</p>

<p>​   ​</p>

<h2 id="alias-">alias 명령어</h2>

<p>한번 설정해놓으면 이것만큼 편한게 없다.
바로 예시를 드는게 더 이해하기 편할거 같다.</p>

<p>예를 들어, 서버의 원격주소로 매일 접속해야 하는 상황이라고 가정해보자.
보통은 매번 <code class="highlighter-rouge">ssh username@address -p port</code> 이런식으로 입력해야 할 것이다.
하지만, alias를 설정해놓으면 커스텀 명령어로 지정하여 간단히 접속할 수 있다.</p>

<ol>
  <li>먼저 ~/.bashrc로 들어간다. (zsh를 사용한다면, ~/.zshrc로 들어가자)</li>
  <li><code class="highlighter-rouge">alias login = 'ssh username@address -p port'</code> 한 줄을 추가한다.</li>
  <li>source ~/.bashrc로 업데이트 해준다.</li>
</ol>

<p>이후에는 접속할 때 <code class="highlighter-rouge">login</code> 이라는 명령어만 입력하면 된다.
​</p>

<p>​   ​</p>

<h2 id="section-1">명령어 순차실행과 파이프라인</h2>

<p>사용하다보면 여러 명령어를 연속적으로 실행해야하는 경우가 많다.</p>

<p>이럴 때는 Sequence와 Pipeline 개념을 알아두면 편하다.
예를 들어, commit과 push 명령어를 연속적으로 실행하고 싶다고 가정해보자.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">git add -A;git push</code></pre></figure>

<p>위와 같이 중간에 세미콜론만 추가하면 된다.</p>

<p>이번에는 실행중인 특정 프로세스 번호를 찾아야 한다고 가정해보자.
처음이라면 <code class="highlighter-rouge">ps -ef</code> 로 프로세스를 직접 확인할 것이다.
하지만 파이프라인과 grep 명령어를 사용한다면 다음과 같이 한줄로 끝난다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">ps -ef | grep process_name</code></pre></figure>

<p>​
​   ​</p>

<h2 id="nohup">백그라운드 실행 - nohup</h2>

<p>어떤 작업을 백그라운드로 실행을 하면 별도의 창으로 켜놓지 않아도
하나의 프로세스로 계속 돌아가는 것을 확인할 수 있다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">nohup name &amp;</code></pre></figure>

<p>리눅스에서는 <code class="highlighter-rouge">nohup</code> 이라는 명령어로 실행할 수 있다.
실행하고 나면 <code class="highlighter-rouge">nohup.out</code> 이라는 파일이 생기는데
cat 명령어로 확인해보면 로그가 찍혀있는 것을 볼 수 있다.
실행중지 시킬 때는 <code class="highlighter-rouge">kill</code> 명령어로 프로세스를 죽이면 된다.</p>

<p>​   ​</p>

<h2 id="cron-crontab">스케줄링을 통한 주기적인 실행 - cron, crontab</h2>

<p>crontab은 일종의 리눅스 작업 스케줄러이다.
이 명령어를 사용하면 특정 시간에 내가 원하는 특정 명령어나 스크립트를 실행시킬 수 있다.
보통 주기적인 크롤링에 사용하기도 한다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> <span class="k">*</span> /root/script.sh</code></pre></figure>

<p>이렇게 설정하면 1분마다 script.sh를 실행한다.
앞의 별 다섯개는 순서대로 <code class="highlighter-rouge">"분,시,일,월,요일"</code>을 뜻한다.
내가 실행중인 스케줄러를 관리하기 위한 명령어는 다음과 같다.</p>

<ul>
  <li>crontab -l : 실행중인 cron 확인</li>
  <li>crontab -r : 사용자의 예약작업을 모두 삭제</li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>OS X에서 Jenkins 설치하기</title>
	  <link>//jenkins-install</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-13T19:18:00+09:00</pubDate>
	  <guid>//jenkins-install</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>이번 포스팅에서는 CI 도구인 Jenkins를 설치하고 실행하는 방법에 대해 정리해보겠습니다.</p>

<p>​</p>

<h2 id="jenkins-">Jenkins 설치하기</h2>

<p>홈페이지에서 패키지 파일로 설치해도 되지만 관리를 편하게 하기 위해 brew로 설치하겠습니다.</p>

<p><code class="highlighter-rouge">brew install jenkins</code> 설치가 되었다면, <code class="highlighter-rouge">brew services start jenkins</code> 명령어로 실행시킵니다.</p>

<p><img src="https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/wRr/image/7QdE6zFXW0HQurosFv56loRGGpY.JPG" alt="jenkins" /></p>

<p>처음에 사용자 등록을 진행하고 필요한 플러그인을 설치하면 홈 화면으로 이동합니다.</p>

<p>서버를 종료시킬때는 <code class="highlighter-rouge">brew services stop jenkins</code> 명령어를 실행시키면 됩니다.</p>

<p>​</p>

	  ]]></description>
	</item>

	<item>
	  <title>Jupyter Notebook 외부접속 설정하기</title>
	  <link>//jupyter-config</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-12T19:18:00+09:00</pubDate>
	  <guid>//jupyter-config</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>이번 포스팅에서는 Jupyter Notebook을 환경구축하고 난 이후에 외부접속을 설정하는 과정에 대해 알아보겠습니다. 환경구축하는 방법에 대해서는 이전의 포스팅 <a href="https://swalloow.github.io/jupyter-notebook-kernel">https://swalloow.github.io/jupyter-notebook-kernel</a> 을 참고해주시기 바랍니다.</p>

<p>​</p>

<h2 id="section">외부접속 허용하기</h2>

<p>우선 <code class="highlighter-rouge">~/.jupyter/jupyter_notebook_config.py</code> 에 있는 Jupyter Notebook의 설정파일을 열어줍니다. 아마 모두 주석이 걸려있을텐데 필요한 부분만 수정해주시면 됩니다.</p>

<ul>
  <li>실행경로 변경 : <code class="highlighter-rouge">c.NotebookApp.default_url = '/tree'</code></li>
  <li>외부접속 허용 : <code class="highlighter-rouge">c.NotebookApp.ip = '0.0.0.0'</code></li>
  <li>
    <p>포트변경: <code class="highlighter-rouge">c.NotebookApp.port = 8888</code></p>

    <p>​</p>
  </li>
</ul>

<h2 id="section-1">비밀번호 설정하기</h2>

<p>비밀번호를 설정하면 url에 접속했을 때, 암호를 입력하는 화면이 나타나게 됩니다. Jupyter Notebook에서는 HASH 값을 통해 암호화된 비밀번호를 적용할 수 있습니다.</p>

<p>먼저, 새로운 노트를 생성하고 다음의 스크립트를 작성합니다. 암호를 설정하는 칸이 나오고 결과 값이 주어지면 그대로 복사해서 <code class="highlighter-rouge">c.NotebookApp.password = u''</code> 여기에 붙여넣기 하시면 됩니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">notebook.auth</span> <span class="kn">import</span> <span class="n">passwd</span><span class="p">;</span>
<span class="n">passwd</span><span class="p">()</span></code></pre></figure>

<p>​</p>

	  ]]></description>
	</item>

	<item>
	  <title>다양한 소셜 API를 연동하기 전에 고려할 것들 (AWS Cognito)</title>
	  <link>//social-api-cognito</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-28T19:18:00+09:00</pubDate>
	  <guid>//social-api-cognito</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>최근에 대부분의 웹, 모바일 어플리케이션에서 카카오, 네이버 등 다양한 소셜 로그인 기능을 제공하고 있다.
만약 우리가 만들어야 할 어플리케이션이 다양한 소셜 로그인 API와 연동하여 사용자를 관리해야한다면, OAuth 인증, 보안 등 개발할 때 고려해야할 요소가 많을 것이다.</p>

<p>따라서, 이 글을 통해 최근 유행하는 클라우드 기반 웹 어플리케이션 설계 방식을 아주 간단히 보고 적합한 설계 방식을 선택하는데 도움이 되었으면 좋겠다.</p>

<p>OAuth2.0에 대해서는 이전에 쓴 글을 참조하길 바란다. <a href="http://swalloow.github.io/about-oauth2/">http://swalloow.github.io/about-oauth2/</a></p>

<p>​</p>

<h2 id="oauth-20-grant-flow">1. OAuth 2.0 Grant Flow</h2>

<p><img src="assets/images/OAuth2 Grant Flow1.png" alt="OAuth2 Grant Flow1" /></p>

<p>주로 자바스크립트 기반 웹 어플리케이션에서 많이 사용하는 방식이다. (스크립트 보안 유출 고려)
최근에는 모바일에서도 많이 사용한다고 한다.</p>

<p>​</p>

<p><img src="assets/images/OAuth2 Grant Flow2.png" alt="OAuth2 Grant Flow2" /></p>

<p>이 방식은 직접 ID, PW 보내는 방식으로 파트너나 자사 시스템에 사용한다.
기존의 HTTP 방식을 그대로 사용하기 용이하다.</p>

<p>위와 같은 방식을 사용했을 때의 장점은 OAuth 2.0을 몸소 체험할 수 있다는 것이다.
반면에, 단점은 다음과 같다.</p>

<ul>
  <li>사용자 데이터에 대한 보안을 고려해야 한다.</li>
  <li>Facebook, Twitter 모두 각자에게 최적화 되어 있어 확장성을 고려한 인증 인터페이스를 만들기 힘들다.</li>
  <li>Token만 존재하기 때문에 사용자 관리, 사용자를 구분하기가 힘들다.</li>
  <li>모바일과 웹 어플리케이션이 모두 존재한다면, 인증 및 디바이스 간 동기화 처리 문제가 있다.</li>
  <li>
    <p>시스템 충돌과 네트워크 연결 문제 또한 감당해야 한다.</p>

    <p>​</p>
  </li>
</ul>

<h2 id="aws-ec2--cognito-baas">2. AWS EC2 + Cognito (BaaS)</h2>

<p><img src="assets/images/AWS Authentication process.png" alt="AWS Authentication process" /></p>

<p>사용자 로그인, 인증 처리에 대해 AWS Cognito를 사용한 방법이다.
기본적인 EC2 인스턴스에 Cognito만 추가해서 사용하면 된다.</p>

<p>이러한 방법을 적용했을 때의 단점은 일단 클라우드에 요금을 내야 한다는 것이다.
또한, AWS Cognito에서 지원하지 않는 카카오 로그인 같은 경우 복잡한 과정이 필요하다.
반면에 장점은 다음과 같다.</p>

<ul>
  <li>SAML을 통한 보안 문제 해결.</li>
  <li>놀라운 확장성. (SOCIAL IDENTITY를 추가하기만 하면 끝, 모바일 앱까지 확장 가능)</li>
  <li>편리한 사용자 관리. (USER POOL 기능 제공)</li>
  <li>인증 및 디바이스간 동기화 처리. (Cognito Sync가 알아서 해준다)</li>
  <li>시스템 충돌과 네트워크 연결 문제. (Cognito Sync가 알아서 해준다)</li>
  <li>
    <p>위와 같은 문제를 신경 안쓰므로 로직에 집중해서 빠른 개발이 가능하다.</p>

    <p>​</p>
  </li>
</ul>

<h2 id="aws-serverless-architecture-baas--faas">3. AWS Serverless Architecture (BaaS + FaaS)</h2>

<p><img src="assets/images/AWS WebApp Application Architecture.png" alt="AWS WebApp Application Architecture" /></p>

<p>AWS API Gateway와 Lambda를 통한 서버리스 아키텍쳐에 대해서는 아래 링크를 참고하자.
서버리스 아키텍쳐는 서버를 관리할 필요 없이 특정 이벤트에 반응하는 함수를 등록하고, 해당 이벤트가 발생하면 함수가 실행되는 구조이다.
장점은 다음과 같다.</p>

<ul>
  <li>서버에 고성능이 필요할 시에는 비용이 절감된다.</li>
  <li>서비스 지향적인 설계가 가능하다. (마이크로 아키텍쳐)</li>
  <li>자동 스케일링</li>
  <li>코드 생산에 집중할 수 있고, 유연한 배포 및 테스트가 가능하다.</li>
</ul>

<p>반면에 단점은 다음과 같다.</p>

<ul>
  <li>AWS 과금이 많이 나올 수 있다. (쓸데없이 많이 고려한 설계일수도)</li>
  <li>
    <p>API Gateway, Lambda에 대한 러닝 커브가 상당하다. (많은 스터디 필요)</p>

    <p>​</p>
  </li>
</ul>

<h2 id="section">결론</h2>

<p>최근에 유행하는 서버리스 아키텍쳐나 마이크로 아키텍쳐를 무조건 도입해야하는 것은 절대 아니다.
각자 프로젝트의 상황에 맞는 방법을 선택하는게 답인듯하다.</p>

<p>​​</p>

<h2 id="section-1">참고하면 좋은 문서들</h2>

<ul>
  <li><a href="https://medium.com/@parkgeunhack/%EC%95%8C%EB%A0%89%EC%8A%A4%EC%9D%98-%EC%9D%B4%EC%95%BC%EA%B8%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-c3aa12baaa75#.kkskaeaqa">박근핵닷컴 서버 개발일지</a></li>
  <li><a href="https://aws.amazon.com/ko/cognito/?nc2=h_m1">AWS Cognito</a></li>
  <li><a href="https://aws.amazon.com/ko/blogs/korea/category/amazon-cognito/">AWS Cognito Blog</a></li>
  <li><a href="http://blog.aliencube.org/ko/2016/06/23/serverless-architectures/">Serverless-Architecture</a></li>
  <li><a href="http://www.popit.kr/why-microservice/">Popit - 마이크로서비스 아키텍쳐의 장단점</a></li>
  <li>
    <p><a href="http://bcho.tistory.com/942">조대협 블로그 - OAuth 2.0 Architecture</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Jupyter Notebook 다중커널 설정하기</title>
	  <link>//jupyter-notebook-kernel</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-28T19:18:00+09:00</pubDate>
	  <guid>//jupyter-notebook-kernel</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>Jupyer Notebook은 웹 기반의 대화형 노트북 지원으로 수식, 표, 그림 등을 표현하기 쉬운 개발 환경입니다.
코딩과 문서화(Markdown)까지 한 화면에서 가능하며 커널 확장을 통해 다양한 파이썬 버전 뿐만 아니라 여러 언어를 지원합니다.</p>

<p>이제 파이썬을 처음 설치한다고 가정하고 맥 OS에서 간단하게 jupyter 환경설정하는 방법을 소개해드리고자 합니다.</p>

<p>​</p>

<h3 id="pyenv-">pyenv 설치하기</h3>

<h5 id="homebrew--pyenv-">1. Homebrew를 통해 pyenv를 설치</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">brew</span> <span class="n">install</span> <span class="n">pyenv</span></code></pre></figure>

<p>​</p>

<h5 id="pyenv-init-bashrc--zsh---zshrc">2. pyenv init을 ~/.bashrc에 추가 (zsh를 사용하는 경우 ~/.zshrc)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">echo</span> <span class="s">'eval "$(pyenv init -)"'</span> <span class="o">&gt;&gt;</span> <span class="o">~/.</span><span class="n">bashrc</span></code></pre></figure>

<p>​</p>

<h5 id="pyenv--1">3. pyenv 사용해보기</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">pyenv</span> <span class="n">versions</span>
<span class="n">system</span> <span class="p">(</span><span class="nb">set</span> <span class="n">by</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">USERNAME</span><span class="o">/.</span><span class="n">pyenv</span><span class="o">/</span><span class="n">version</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="pyenv--">4. pyenv 명령어 정리</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">pyenv</span> <span class="n">install</span> <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">uninstall</span> <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">install</span> <span class="o">-</span><span class="nb">list</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">shell</span> <span class="o">&lt;</span><span class="n">version</span><span class="o">&gt;</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">activate</span> <span class="o">&lt;</span><span class="n">environment</span><span class="o">&gt;</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">deactivate</span> <span class="o">&lt;</span><span class="n">environment</span><span class="o">&gt;</span></code></pre></figure>

<p>​</p>

<h3 id="pyenv-virtualenv-">pyenv-virtualenv 설치하기</h3>

<h5 id="homebrew--pyenv-virtualenv-">1. Homebrew를 통해 pyenv-virtualenv를 설치</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">brew</span> <span class="n">install</span> <span class="n">pyenv</span><span class="o">-</span><span class="n">virtualenv</span></code></pre></figure>

<p>​</p>

<h5 id="virtualenv-init-bashrc--zsh---zshrc">2. virtualenv init을 ~/.bashrc에 추가 (zsh를 사용하는 경우 ~/.zshrc)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">echo</span> <span class="s">'eval "$(pyenv virtualenv-init -)"'</span> <span class="o">&gt;&gt;</span> <span class="o">~/.</span><span class="n">bashrc</span></code></pre></figure>

<p>​</p>

<h5 id="pyenv-virtualenv--1">2. pyenv-virtualenv 사용해보기</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># pyenv virtualenv [python version] [myname]</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">virtualenv</span> <span class="mf">2.7</span><span class="o">.</span><span class="mi">11</span> <span class="n">python2</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">virtualenv</span> <span class="mf">3.5</span><span class="o">.</span><span class="mi">1</span> <span class="n">python3</span></code></pre></figure>

<p>​</p>

<h5 id="virtualenv--">2. virtualenv 명령어 정리</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">pyenv</span> <span class="n">virtualenv</span> <span class="n">versions</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">virtualenv</span> <span class="p">[</span><span class="n">python</span> <span class="n">version</span><span class="p">]</span> <span class="p">[</span><span class="n">myname</span><span class="p">]</span>
<span class="err">$</span> <span class="n">pyenv</span> <span class="n">shell</span> <span class="p">[</span><span class="n">myname</span><span class="p">]</span></code></pre></figure>

<p>​</p>

<h3 id="jupyter-notebook-">Jupyter Notebook 설치</h3>

<p>이제 방금 설치했던 파이썬 2와 3 버전의 환경에 python, notebook, jupyter를 설치할 차례입니다.
따라서 방금 설치한 환경을 각각 activate한 다음에 아래와 같은 명령어를 실행시켜야 합니다.</p>

<p>​</p>

<h5 id="pip-install-python2-python3--">1. pip install (python2, python3 각각 실행)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">ipython</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">notebook</span>
<span class="err">$</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">jupyter</span></code></pre></figure>

<p>​</p>

<h5 id="jupyter-configuration-----">2. 초기 Jupyter configuration 파일 생성 (마찬가지로 각각 실행)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">jupyter</span> <span class="n">notebook</span> <span class="o">--</span><span class="n">generate</span><span class="o">-</span><span class="n">config</span>
<span class="n">Installed</span> <span class="n">kernelspec</span> <span class="n">python3</span> <span class="ow">in</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">username</span><span class="o">/</span><span class="n">Library</span><span class="o">/</span><span class="n">Jupyter</span><span class="o">/</span><span class="n">kernels</span><span class="o">/</span><span class="n">python3</span></code></pre></figure>

<p>​</p>

<h5 id="jupyternotebookconfigpy-----">3. 생성된 jupyter_notebook_config.py 설정 (원하는 경우에만 커스텀 설정)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">vi</span> <span class="o">/</span><span class="n">Users</span><span class="o">/</span><span class="n">username</span><span class="o">/</span><span class="n">Library</span><span class="o">/</span><span class="n">Jupyter</span><span class="o">/</span><span class="n">kernels</span><span class="o">/</span><span class="n">python3</span><span class="o">/</span><span class="n">jupyter_notebook_config</span><span class="o">.</span><span class="n">py</span>

<span class="err">$</span> <span class="n">c</span><span class="o">.</span><span class="n">NotebookApp</span><span class="o">.</span><span class="n">ip</span> <span class="o">=</span> <span class="s">'127.0.0.1'</span>
<span class="err">$</span> <span class="n">c</span><span class="o">.</span><span class="n">NotebookApp</span><span class="o">.</span><span class="n">open_browser</span> <span class="o">=</span> <span class="bp">False</span>
<span class="err">$</span> <span class="n">c</span><span class="o">.</span><span class="n">NotebookApp</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="mi">8888</span>
<span class="err">$</span> <span class="n">c</span><span class="o">.</span><span class="n">NotebookApp</span><span class="o">.</span><span class="n">password</span> <span class="o">=</span> <span class="p">[</span><span class="n">SHA</span> <span class="n">password</span><span class="p">]</span></code></pre></figure>

<p>​</p>

<h5 id="ipykernel----">4. ipykernel 설정 (마찬가지로 각각 실행)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">pyenv</span> <span class="n">shell</span> <span class="n">python2</span>
<span class="err">$</span> <span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">ipykernel</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span>
<span class="n">Installed</span> <span class="n">kernelspec</span> <span class="n">python2</span> <span class="ow">in</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">seen</span><span class="o">/.</span><span class="n">local</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">jupyter</span><span class="o">/</span><span class="n">kernels</span><span class="o">/</span><span class="n">python2</span></code></pre></figure>

<p>​</p>

<h5 id="kerneljson-----">5. kernel.json 확인 (원하는 경우에만 커스텀 설정)</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">vi</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">seen</span><span class="o">/.</span><span class="n">local</span><span class="o">/</span><span class="n">share</span><span class="o">/</span><span class="n">jupyter</span><span class="o">/</span><span class="n">kernels</span><span class="o">/</span><span class="n">python2</span><span class="o">/</span><span class="n">kernel</span><span class="o">.</span><span class="n">json</span>
<span class="p">{</span>
  <span class="s">"display_name"</span><span class="p">:</span> <span class="s">"Python 2"</span><span class="p">,</span>
  <span class="s">"language"</span><span class="p">:</span> <span class="s">"python"</span><span class="p">,</span>
  <span class="s">"argv"</span><span class="p">:</span> <span class="p">[</span>
    <span class="s">"/home/seen/.pyenv/versions/py27/bin/python"</span><span class="p">,</span>
    <span class="s">"-m"</span><span class="p">,</span>
    <span class="s">"ipykernel"</span><span class="p">,</span>
    <span class="s">"-f"</span><span class="p">,</span>
    <span class="s">"{connection_file}"</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="jupyter-notebook--1">6. jupyter notebook을 실행</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">jupyter</span> <span class="n">notebook</span>

<span class="c"># background running</span>
<span class="err">$</span> <span class="n">nohup</span> <span class="n">jupyter</span> <span class="n">notebook</span> <span class="o">&amp;</span>

<span class="c"># kill process</span>
<span class="err">$</span> <span class="n">ps</span> <span class="o">-</span><span class="n">a</span>
<span class="mi">37788</span> <span class="n">ttys000</span> <span class="mi">0</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span> <span class="o">...</span><span class="n">python</span> <span class="p">(</span><span class="err">노트북을</span> <span class="err">실행한</span> <span class="err">프로세스</span><span class="p">)</span>
<span class="err">$</span> <span class="n">kill</span> <span class="mi">37788</span></code></pre></figure>

<p>​</p>

<h3 id="section">정리</h3>

<p>윈도우10 에서 아주 고생했던 환경설정이 맥 OS에서는 아주 간편하게 됩니다…
잘 안되거나 오류가 생기시면 댓글로 알려주시면 감사하겠습니다!</p>

<p>​</p>

<h3 id="section-1">참고링크</h3>

<ul>
  <li><a href="https://github.com/yyuu/pyenv">https://github.com/yyuu/pyenv</a></li>
  <li>
    <p><a href="https://github.com/yyuu/pyenv-virtualenv">https://github.com/yyuu/pyenv-virtualenv</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>OAuth2에 대해 알아보자</title>
	  <link>//about-oauth2</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-05T19:18:00+09:00</pubDate>
	  <guid>//about-oauth2</guid>
	  <description><![CDATA[
	     <p>먼저 OAuth 인증을 이해하기 위해 필요한 몇 가지 개념들에 대해 알아보자. OAuth 인증을 진행할 때 해당 서비스 제공자는 ‘제 3자가 어떤 정보나 서비스에 사용자의 권한으로 접근하려 하는데 허용하겠느냐’라는 안내 메시지를 보여 주는 것이다.</p>

<p>​   ​</p>

<h3 id="section">인증과 허가</h3>

<ol>
  <li>Authentication : 인증</li>
  <li>
    <p>Authorization : 허가</p>

    <p>​   ​</p>
  </li>
</ol>

<p>일반 로그인은 사원이 63빌딩에 출입하는 것이라면, (사원증이 있어야 출입가능)</p>

<p>OAuth는 1층에서 방문증을 수령한 후 63빌딩에 출입하는 것이다. (방문증만 있어도 출입가능)</p>

<p>​   ​</p>

<h2 id="oauth-10-">OAuth 1.0의 특징</h2>

<p>기존의 다른 인증방식(OpenID)과 구분되는 특징은 크게 두 가지이다.</p>

<ol>
  <li>API 인증 시, 써드파티 어플리케이션에게 사용자의 비번을 노출하지 않고 인증할 수 있다는 점</li>
  <li>
    <p>인증(Authentication)과 API 권한(Authorization) 부여를 동시에 할 수 있다는 점</p>

    <p>​</p>
  </li>
</ol>

<h2 id="oauth-10--1">OAuth 1.0의 동작방식</h2>

<p>OAuth 1.0은 기본적으로 user / consumer / service provider가 있어야 한다.</p>

<p>OAuth 1.0 인증을 3-legged OAuth 라고도 하는데 결국 주체가 셋 이라는 말이다.</p>

<p><img src="assets/images/oauth1_triangle.png" alt="oauth1_triangle" /></p>

<p>우리의 서비스에서 트위터 로그인을 연동한다고 가정해보자. 사용자 입장에서는 아이디 / 비밀번호를 통해 가입하면 그 정보를 이용해서 무슨 짓을 할지 모르기 때문에 꺼려한다. OAuth 1.0은 우리의 서비스(Consumer)에게 인증토큰 (Access Token)만을 전달하고 서비스에서 인증토큰으로 트위터 API(Service Provider)를 사용할 수 있도록 해준다.</p>

<p>​</p>

<h3 id="outh-10-">Outh 1.0 프로세스</h3>

<ol>
  <li>사용자(User)가 트위터 로그인 요청</li>
  <li>사용자를 트위터(Service Provider) 로그인 화면으로 리다이렉트</li>
  <li>트위터 로그인 진행</li>
  <li>
    <p>서비스(Consumer)로 인증토큰(Access Token)이 전달</p>

    <p>​</p>
  </li>
</ol>

<h3 id="section-1">인증토큰의 장점</h3>

<ul>
  <li>사용자의 아이디 / 패스워드를 몰라도 토큰을 통해 허가 받은 API에 접근 가능</li>
  <li>필요한 API에만 제한적으로 접근할 수 있도록 권한 제어 가능</li>
  <li>저장되어 있는 인증토큰이 유출되더라도 트위터의 관리자 화면에서 인증토큰의 권한 취소 가능</li>
  <li>
    <p>사용자가 트위터(Service Provider)의 패스워드를 변경해도 인증토큰은 계속 유효</p>

    <p>​</p>
  </li>
</ul>

<h2 id="oauth-20-">OAuth 2.0의 개선사항</h2>

<p>일단 OAuth 2.0은 1.0과 호환되지 않으며 용어부터 많은 것이 다르다. 모바일에서의 사용성 문제나 서명과 같은 개발이 복잡하고 기능과 규모의 확장성 등을 지원하기 위해 만들어진 표준이다. 표준이 매우 크고 복잡해서 이름도 “OAuth 인증 프레임워크(OAuth 2.0 Authorization Framework)” 이다. <a href="http://tools.ietf.org/wg/oauth/">http://tools.ietf.org/wg/oauth/</a> 에서 확인 가능</p>

<p>​</p>

<h3 id="oauth-10--">OAuth 1.0에서 개선된 사항</h3>

<ol>
  <li>용어 변경
    <ul>
      <li>Resource Owner : 사용자</li>
      <li>Resource Server : REST API 서버</li>
      <li>Authorization Server : 인증서버 (API 서버와 같을 수도 있음)</li>
      <li>Client : 써드파티 어플리케이션 (서비스)</li>
    </ul>

    <p>​</p>
  </li>
  <li>간단하고 직관적
    <ul>
      <li>OAuth 1.0에서는 HTTPS가 필수</li>
      <li>Signature 없이 생성, 호출 가능</li>
      <li>URL 인코딩이 필요없음</li>
    </ul>

    <p>​</p>
  </li>
  <li>더 많은 인증 방법을 지원
    <ul>
      <li>이전에는 HMAC을 이용한 암호화 인증만 지원</li>
      <li>OAuth 2.0은 여러 인증 방식을 통해 웹 / 모바일 등 다양한 시나리오에 대응 가능</li>
      <li>Access Token의 Life-time을 지정하여 만료일 설정 가능</li>
    </ul>

    <p>​</p>
  </li>
  <li>대형 서비스로의 확장성 지원
    <ul>
      <li>커다란 서비스는 인증 서버를 분리하거나 다중화 할 수 있어야 함</li>
      <li>Authorization Server의 역할을 명확히 하여 이에 대한 고려가 되었음</li>
    </ul>

    <p>​</p>
  </li>
</ol>

<h2 id="oauth-20--">OAuth 2.0 사용 서비스</h2>

<p>2013년까지만 해도 1.0만 지원하거나 2.0으로 개선하는 인터넷 서비스 기업이 많았지만,</p>

<p>현재는 대부분 2.0만 지원한다고 봐도 무방하다. (1.0은 자체 로그인에만 사용하는 기업이 많음)</p>

<ul>
  <li>
    <p>Facebook, Instagram, Google, LinkedIn, Twitter…</p>

    <p>​</p>
  </li>
</ul>

<h2 id="section-2">참고하면 좋은 자료</h2>

<ul>
  <li>Naver D2 : <a href="http://d2.naver.com/helloworld/24942">http://d2.naver.com/helloworld/24942</a></li>
  <li>정리 잘 된 블로그 : <a href="http://earlybird.kr/1584">http://earlybird.kr/1584</a></li>
  <li>
    <p>조대협의 블로그 : <a href="http://bcho.tistory.com/942">http://bcho.tistory.com/942</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Open API를 설계할 때 알아야 하는 것들</title>
	  <link>//open-api-guide</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-05T19:18:00+09:00</pubDate>
	  <guid>//open-api-guide</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>오픈 API를 사용하다보면 공통의 패턴을 발견할 수 있을 것이다.
이처럼, API를 설계할 때도 개발자들이 쉽게 사용할 수 있도록 만든 규칙이라는게 존재한다.
오늘은 RESTful한 Open API를 설계하기 위해 알아야 하는 것들에 대해 정리해보았다.</p>

<p>​</p>

<h2 id="open-api-">Open API 디자인</h2>

<p>​</p>

<h3 id="api-">API 란?</h3>

<blockquote>
  <p>운영체제, 시스템, 애플리케이션, 라이브러리 등을 개발자들이 프로그래밍 작업을 통해 응용 프로그램을 작성할 수 있는 다양한 인터페이스들을 총칭한다. (예: Window API, Java API, HTML5 API, Android API…) - 네이버 개발자센터 인용</p>
</blockquote>

<p>​</p>

<h3 id="api--1">오픈 API 란?</h3>

<blockquote>
  <p>API 중에서 플랫폼의 기능 또는 컨텐츠를 외부에서 쓸 수 있도록 웹 프로토콜(HTTP)로 호출할 수 있도록 개방(open)한 API를 의미한다. 네이버 개발자센터에서 제공하고 있는 지도, 검색을 비롯 기계번역, 캡차, 단축 URL 등 대부분 API 들은 HTTP로 호출할 수 있는 오픈 API에 해당한다. - 네이버 개발자센터 인용</p>
</blockquote>

<p>​</p>

<p>이제 기업 또는 사용자에게 제공할 RESTful Open API를 어떻게 설계할지 고민해보자.
기업에게 전문적으로 API를 공급하는 Apigee 사의 <strong>Web API Design</strong> 을 레퍼런스로 삼았다.</p>

<p>​</p>

<h2 id="best-web-api-design-rules">Best Web API Design Rules</h2>

<p>​</p>

<h5 id="url------2--url-">1. 기본 URL에는 동사가 아닌 명사를 사용, 리소스마다 2개의 기본 URL을 유지하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">/</span><span class="n">dogs</span> <span class="p">(</span><span class="n">Collection</span><span class="p">),</span> <span class="o">/</span><span class="n">dogs</span><span class="o">/</span><span class="mi">1234</span> <span class="p">(</span><span class="n">Element</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="http-post-get-put-delete-">2. 올바른 HTTP 메서드(POST, GET, PUT, DELETE)를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">POST</span><span class="p">(</span><span class="n">create</span><span class="p">),</span> <span class="n">GET</span><span class="p">(</span><span class="n">read</span><span class="p">),</span> <span class="n">PUT</span><span class="p">(</span><span class="n">update</span><span class="p">),</span> <span class="n">DELETE</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="section">3. 복수형 명사와 구체적인 이름을 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">/</span><span class="n">animals</span><span class="p">,</span> <span class="o">/</span><span class="n">dogs</span></code></pre></figure>

<p>​</p>

<h5 id="url----">4. 자원 간의 관계를 간단히 하여 URL 계층이 깊어지는 것을 피하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span>	<span class="o">/</span><span class="n">owners</span><span class="o">/</span><span class="mi">5678</span><span class="o">/</span><span class="n">dogs</span><span class="err">?</span><span class="n">color</span><span class="o">=</span><span class="n">red</span></code></pre></figure>

<p>​</p>

<h5 id="section-1">5. 오류 처리를 명확하게 하고 에러 스택은 절대 비공개 해야 한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">200</span> <span class="o">-</span> <span class="n">OK</span>
<span class="mi">400</span> <span class="o">-</span> <span class="n">Bad</span> <span class="n">Request</span>
<span class="mi">500</span> <span class="o">-</span> <span class="n">Internal</span> <span class="n">Server</span> <span class="n">Error</span>
<span class="mi">201</span> <span class="o">-</span> <span class="n">Created</span>
<span class="mi">304</span> <span class="o">-</span> <span class="n">Not</span> <span class="n">Modified</span>
<span class="mi">404</span> <span class="o">-</span> <span class="n">Not</span> <span class="n">Found</span>
<span class="mi">401</span> <span class="o">-</span> <span class="n">Unauthorized</span>
<span class="mi">403</span> <span class="o">-</span> <span class="n">Forbidden</span></code></pre></figure>

<p>​</p>

<h5 id="v------">6. 접두사 “v”로 버전을 지정하고 지속적인 버전 관리를 하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span>	<span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">dogs</span></code></pre></figure>

<p>​</p>

<h5 id="section-2">7. 데이터베이스에 없는 자원에 대한 응답일 경우 동사를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">ex</span><span class="p">)</span> <span class="n">Caculate</span><span class="p">,</span> <span class="n">Translate</span><span class="p">,</span> <span class="n">Convert</span> <span class="o">...</span></code></pre></figure>

<p>​</p>

<h5 id="javascript-----">8. 속성의 네이밍은 Javascript의 관습을 따르고 카멜 케이스를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="s">"createdAt"</span><span class="p">:</span> <span class="mi">123415125</span></code></pre></figure>

<p>​</p>

<h5 id="api---">9. 하위 도메인의 독립적인 API 요청 처리는 통일하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">company</span><span class="o">.</span><span class="n">com</span>
<span class="n">api</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">com</span>	<span class="p">(</span><span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">,</span> <span class="n">redirect</span><span class="p">)</span>
<span class="n">developers</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">com</span></code></pre></figure>

<p>​</p>

<h5 id="section-3">10. 기타</h5>

<ul>
  <li>권한 관리(OAuth)는 2.0을 사용하자.</li>
  <li>필요한 경우, SDK로 API를 보완하자.</li>
  <li>
    <p>API Facade Pattern을 API 설계에 고려해라.</p>

    <p>​</p>
  </li>
</ul>

<h3 id="naver-open-api">NAVER Open API</h3>

<p>실제 네이버와 카카오의 오픈 API는 어떻게 디자인되어 있는지 간단히 살펴보자.
<a href="https://developers.naver.com">https://developers.naver.com</a> 참조</p>

<blockquote>
  <p>이전(2015년 쯤)에는 네이버에서 제공하는 API를 사용하기 위해 ‘API 키’라는 유니크한 텍스트 문자열을 발급받고, 이를 API 호출시 같이 API 게이트웨이 서버로 전송함으로써 인증된 사용자임을 입증했다. 새로운 개발자센터에서는 API 키 방식은 더 이상 사용하지 않고 애플리케이션마다 일종의 유니크한 아이디와 비밀번호(클라이언트 아이디, 시크릿)값을 이용해서 인증하고 있다.</p>
</blockquote>

<p>​</p>

<h4 id="api--url--">1. API 호출 URL과 요청 변수</h4>

<ul>
  <li>https://openapi.naver.com/버전/서비스구분/API 구분 형태</li>
  <li>예시) 기계번역 API : https://openapi.naver.com/v1/language/translate</li>
  <li>요청변수란, 오픈 API를 호출할 때 함께 서버로 전송해야 하는 값이다.</li>
  <li>
    <p>요청변수에 한글이나 특수문자가 요청 변수값에 포함되어 있을 경우, 서버 전송 시 값이 깨지기 때문에 인코딩/디코딩 과정이 필요하다.</p>

    <p>​</p>
  </li>
</ul>

<h4 id="http-status-code">2. 에러 코드 정의 - HTTP status code</h4>

<ul>
  <li>400 (요청변수) : 필수 요청 변수가 빠졌거나 요청변수 이름이 잘못되었을 경우나 요청 변수 값을 URL 인코딩하지 않고 전송하였을 경우</li>
  <li>401 (인증실패) : 애플리케이션 클라이언트 아이디와 시크릿 값이 없거나 잘못되었을 경우</li>
  <li>401 (인증실패) : 클라이언트 아이디와 시크릿 값을 HTTP 헤더에 정확히 설정하지 않고 호출했을 경우</li>
  <li>401 (인증실패) : API 권한 설정이 안되어 있을 경우</li>
  <li>401 (인증오류) : 로그인 오픈 API를 호출할 때 접근 토큰(access_token) 값이 빠졌거나 잘못된 값 (기간 만료)을 설정하였을 경우</li>
  <li>403 (호출금지) : https가 아닌 http로 호출하였을 경우</li>
  <li>403 (호출금지) : 약관 동의를 하지 않고 호출할 경우 또는 권한이 없거나 비공개인 경우</li>
  <li>404 (API없음) : API 요청 URL이 잘못되었을 경우</li>
  <li>405 (메서드오류) : HTTP 메서드를 잘못하여 호출하였을 경우 (POST인데 GET으로 호출)</li>
  <li>429 (한도초과) : 오픈 API를 호출할 때 일 허용량을 초과하였을 경우</li>
  <li>
    <p>500 (서버오류) : API 호출은 정상적으로 했지만, API 서버 유지보수나 시스템 오류로 인한 에러가 발생하였을 경우</p>

    <p>​</p>
  </li>
</ul>

<h3 id="kakao-rest-api--">Kakao REST API (카카오톡, 카카오페이)</h3>

<p>​</p>

<h5 id="section-4">1. 먼저, 카카오 로그인 후에 사용자 토큰을 받아온다.</h5>

<h5 id="get-">2. 사용자 토큰을 헤더에 담아 GET으로 요청한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span> <span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">api</span><span class="o">/</span><span class="n">talk</span><span class="o">/</span><span class="n">profile</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="n">Host</span><span class="p">:</span> <span class="n">kapi</span><span class="o">.</span><span class="n">kakao</span><span class="o">.</span><span class="n">com</span>
<span class="n">Authorization</span><span class="p">:</span> <span class="n">Bearer</span> <span class="p">{</span><span class="n">access_token</span><span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="json-----">3. 응답은 JSON 형태로 다음과 같은 정보를 포함한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
 <span class="s">"nickName"</span><span class="p">:</span><span class="s">"홍길동"</span><span class="p">,</span>
 <span class="s">"profileImageURL"</span><span class="p">:</span><span class="s">"http://xxx.kakao.co.kr/.../aaa.jpg"</span><span class="p">,</span>
 <span class="s">"thumbnailURL"</span><span class="p">:</span><span class="s">"http://xxx.kakao.co.kr/.../bbb.jpg"</span><span class="p">,</span>
 <span class="s">"countryISO"</span><span class="p">:</span><span class="s">"KR"</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="response-code-example">Response Code Example</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
  <span class="s">"meta"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">"code"</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
    <span class="s">"response_time"</span><span class="p">:</span> <span class="p">{</span>
      <span class="s">"time"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s">"measure"</span><span class="p">:</span> <span class="s">"seconds"</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="s">"notifications"</span><span class="p">:</span> <span class="p">{},</span>
  <span class="s">"response"</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="error-code-example">Error Code Example</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
  <span class="s">"meta"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">"code"</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
    <span class="s">"error_detail"</span><span class="p">:</span> <span class="s">"The user has not authorized or the token is invalid."</span><span class="p">,</span>
    <span class="s">"error_type"</span><span class="p">:</span> <span class="s">"invalid_auth"</span><span class="p">,</span>
    <span class="s">"developer_friendly"</span><span class="p">:</span> <span class="s">"The user has not authorized or the token is invalid."</span><span class="p">,</span>
    <span class="s">"response_time"</span><span class="p">:</span> <span class="p">{</span>
      <span class="s">"time"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s">"measure"</span><span class="p">:</span> <span class="s">"seconds"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h2 id="section-5">참고자료</h2>

<ul>
  <li>API Platform Design : <a href="http://bcho.tistory.com/808">http://bcho.tistory.com/808</a></li>
  <li>Web API Design : <a href="https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf">https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf</a></li>
  <li>카카오 개발자센터 : <a href="https://developers.kakao.com">https://developers.kakao.com</a></li>
  <li>
    <p>네이버 개발자센터 : <a href="https://developers.naver.com">https://developers.naver.com</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
