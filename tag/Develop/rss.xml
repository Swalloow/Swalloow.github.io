<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>swalloow.github.io/</title>
   
   <link>http://swalloow.github.io/</link>
   <description>About Data Science, Data Engineering</description>
   <language>ko-KO</language>
   <managingEditor> Swalloow</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>분산 컨테이너 환경에서의 디자인 패턴</title>
	  <link>//container-patterns</link>
	  <author>Swalloow</author>
	  <pubDate>2019-01-26T19:18:00+09:00</pubDate>
	  <guid>//container-patterns</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>구글 클라우드 팀이 Kubernetes와 같은 Container Orchestration 기술을 개발하면서 겪은
분산 컨테이너 환경에서의 디자인 패턴에 대해 정리한 내용입니다.
분산 어플리케이션을 컨테이너 환경으로 옮기려는 분들에게 많은 도움이 될 듯 합니다.</p>

<p>​</p>

<h2 id="modular-container-design">Modular Container Design</h2>

<p>최근 많은 개발 환경이 Docker 기반의 컨테이너 환경으로 옮겨가고 있습니다.
그 중에서는 복잡한 의존성에서 벗어나 독립적으로 운영하고 싶어서 옮기는 경우가 많습니다.</p>

<p>하지만 분산 컨테이너 환경은 아주 복잡하게 연결되어 있어서 운영하기 힘듭니다.
복잡한 연결을 쉽게 이해하려면 이 문제가 어디에 해당하는지 경계를 잘 정의하는 것이 중요합니다.
이렇게 <strong>경계를 정의하고 분류하는 것을 모듈화</strong>라고 부릅니다.</p>

<p>우리는 과거부터 효율적인 코드를 작성하기 위해 절차지향 프로그래밍에서 객체지향 프로그래밍으로 변화해왔습니다.
객체지향 프로그래밍의 클래스는 경계를 정의한다는 측면에서 컨테이너 환경과 유사한 면이 있습니다.</p>

<p><img src="http://drive.google.com/uc?export=view&amp;id=1KTN3XFpFugvI6OXqnJdvc0LBUjW0HfbV" alt="modular" /></p>

<p>과거 모놀리틱 아키텍쳐에서는 왼쪽 그림과 같은 구조로 설계되어 왔습니다.
우리가 기여하거나 자주 수정하는 코드가 있는 반면, 코어 모듈이나 공통에 해당하는 부분은 잘 변하지 않습니다.</p>

<p>컨테이너 환경은 이와 조금 다릅니다.
우선 <strong>컨테이너 환경에서 컨테이너는 하나의 어플리케이션이 아니라는 점</strong>을 이해하고 있어야 합니다.
하나의 컨테이너는 객체지향 언어의 클래스 또는 함수와 유사합니다.
오른쪽 그림처럼 작은 모듈 조각을 모으고 조립해서 다음 어플리케이션을 설계하는 형태가 되어야 합니다.</p>

<p>​</p>

<h3 id="benefit">Benefit</h3>

<p>위와 같은 컨테이너 환경을 구성했을 때 가지는 장점은 아래와 같습니다.</p>

<ul>
  <li>이미 만들어 놓은 컨테이너를 재사용할 수 있고 사용하기 쉬움</li>
  <li>컨테이너 경계에 따라 팀의 역할을 분리시킬 수 있음</li>
  <li>분리되어 있기 때문에 각 모듈에 대해 더 깊게 이해할 수 있음</li>
  <li>각 모듈에 대해 작은 수정사항을 빠르게 업데이트할 수 있음</li>
  <li>
    <p>흔히 얘기하는 관심사의 분리를 만족시킬 수 있음 (Seperate concerns)</p>

    <p>​</p>
  </li>
</ul>

<h3 id="requirements">Requirements</h3>

<p>위와 같은 컨테이너 환경을 구성하기 위해 필요한 요소는 아래와 같습니다.</p>

<ul>
  <li>공통된 네임스페이스 (PID, IPC, 네트워크 등), 마치 localhost 처럼 사용할 수 있도록 하나의 컨테이너가 다른 컨테이너의 프로세스를 컨트롤 할 수 있어야 합니다.</li>
  <li>공유할 수 있는 파일 시스템, Kubernetes의 PV, PVC에 내한 내용을 떠올리면 이해하기 쉽습니다.</li>
  <li>어플리케이션을 구성할 때 노드의 분리도 고려되어야 합니다. 예시로 WordPress-MySQL 어플리케이션을 배포한다고 가정했을 때, WordPress가 배포된 노드와 MySQL 노드의 위치가 달라야 합니다. 그리고 WordPress, MySQL에 각각에 대한 Scale-out도 고려되어야 합니다.</li>
  <li>
    <p>컨테이너가 런타임 시점에 파라메터로 설정 값을 받을 수 있도록 설계되어야 합니다. 그리고 각 이미지에 대한 문서화도 필요합니다.
특히 여러 컨테이너에서 공통으로 사용하는 라이브러리의 경우 필요</p>

    <p>​</p>
  </li>
</ul>

<h2 id="sidecar-pattern">Sidecar Pattern</h2>

<p><img src="http://drive.google.com/uc?export=view&amp;id=1zkTfbZgsYUlylN6kGVXDjCqfZGVTo5jF" alt="" /></p>

<p>이제부터 자주 사용되는 세 가지 디자인 패턴을 소개드리려고 합니다.
먼저 첫 번째는 사이드 카 패턴입니다.
<strong>사이드 카 패턴은 이전에 사용되던 컨테이너의 기능을 확장시키고 싶을 때</strong> 유용하게 사용됩니다.
여기서 이전에 사용되던 컨테이너란 잘 변하지 않으며 같은 작업을 반복하는 어플리케이션을 말합니다.</p>

<p>위 그림의 예시에서 이전에 사용되던 컨테이너는 왼쪽의 node.js 어플리케이션 입니다.
node.js 어플리케이션은 단순히 파일 시스템에 접근하여 어떤 작업을 수행하는 일만 합니다.
만일 파일 시스템에 대해 git 동기화 기능을 추가하고 싶다면, 오른쪽 컨테이너처럼 확장시킬 수 있습니다.
node.js 어플리케이션은 사이드 카 컨테이너가 어떤 작업을 수행하는지 고려할 필요가 없습니다.
사이드 카 컨테이너 역시 어떤 어플리케이션이 이 파일을 서빙하는지 고려할 필요가 없습니다.
앞서 말한 것처럼 관심사의 분리를 만족시키며, 컨테이너를 관리하는 팀을 분리시킬 수 있습니다.
또한 사이드 카 컨테이너를 다른 어플리케이션에서 재사용할 수 있고, 더 다양한 기능으로 확장시킬 수 있습니다.</p>

<p>​</p>

<h2 id="ambassador-pattern">Ambassador Pattern</h2>

<p><img src="http://drive.google.com/uc?export=view&amp;id=1pzXLY74nqBfNti5cPd-zSw0kGPEh2CUK" alt="" /></p>

<p>다음은 엠베서더 패턴입니다.
<strong>엠베서더 패턴은 어플리케이션을 대신하여 외부의 네트워크 또는 요청을 처리해야할 때</strong> 유용하게 사용됩니다.</p>

<p>위 그림의 예시에서 어플리케이션은 PHP 앱이고 Memcache를 사용한 지속적인 해싱이 필요하다고 가정해보겠습니다.
그리고 Memcache 사용을 위해 <a href="https://github.com/twitter/twemproxy">twemproxy</a>라는 라이브러리를 가져와야 합니다.
위 그림처럼 어플리케이션과 twemproxy 컨테이너를 분리시킨다면,
twemproxy 컨테이너는 외부에 있는 Memcache 샤드를 관리하고 통신하는 역할을 수행할 수 있습니다.
기존에 있던 어플리케이션 컨테이너는 twemproxy 컨테이너와 같은 네임스페이스에 존재하지만, 외부의 통신에 대해서는 관여할 필요가 없습니다.
역시 마찬가지로 관심사의 분리를 만족시키며, 재사용될 수 있고, 다양한 기능으로 확장시킬 수 있습니다.</p>

<p>​</p>

<h2 id="adapter-pattern">Adapter Pattern</h2>

<p><img src="http://drive.google.com/uc?export=view&amp;id=1Vpp_gVNarlAql_eGKkBJ2ojntRkAYzQL" alt="" /></p>

<p>다음은 어댑터 패턴입니다.
<strong>어댑터 패턴은 추상화된 레이어가 필요할 때</strong> 유용하게 사용됩니다.</p>

<p>대표적인 예시로 위 그림과 같은 모니터링 에이전트가 있습니다.
일반적으로 Redis, Memcache, MySQL 등 다양한 컴포넌트에 모니터링이 필요합니다.
모놀리틱 구조로 설계되었다면, 새로운 컴포넌트에 대한 지원이 필요할때마다 변경이 필요합니다.
하지만 분리되어 있는 공통 인터페이스가 존재한다면, 새로운 컴포넌트를 쉽게 추가할 수 있습니다.
특히 오픈소스 진영에서는 많은 사람들이 다양한 컴포넌트를 사용하기 때문에 많이 활용됩니다.</p>

<p><img src="http://drive.google.com/uc?export=view&amp;id=1doLkvd4eNSQvCtw0KT1ipw2EVA0uTXJP" alt="" /></p>

<p>많이 사용하는 prometheus exporter도 이와 같은 패턴으로 설계되어 있습니다.
exporter는 모니터링 시스템과 쉽게 결합할 수 있습니다.
그리고 exporter와 memcache, redis는 결합해서 하나의 컨테이너로 배포하는 형태입니다.
redis-exporter에 코드 변경이 이루어지더라도 memcache-exporter는 변경될 필요가 없습니다.</p>

<p>​</p>

<h2 id="reference">Reference</h2>

<p>이외에도 Replication, Micro service Load Balancer에 사용되는 다양한 패턴이 존재합니다.
분산 컨테이너 환경에서 어플리케이션을 개발하는 일은 레고 블럭을 조립하는 것과 비슷합니다.
더 자세한 내용이 궁금하신 분은 아래 링크를 확인하시면 됩니다.</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=Ph3t8jIt894">DockerCon - Container patterns for modular distributed system design</a></li>
  <li>
    <p><a href="https://static.googleusercontent.com/media/research.google.com/ko//pubs/archive/45406.pdf">GooglePaper - Design patterns for container-based distributed systems</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Scala의 빌드 도구 SBT</title>
	  <link>//scala-sbt</link>
	  <author>Swalloow</author>
	  <pubDate>2017-07-08T21:18:00+09:00</pubDate>
	  <guid>//scala-sbt</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>Scala에는 SBT라는 빌드 도구가 있습니다.
SBT는 의존성 관리에 Apache ivy를 사용합니다.
앞으로 계속 내용을 추가할 예정입니다.</p>

<p>​</p>

<h3 id="sbt">SBT</h3>

<p>SBT로 생성한 프로젝트의 기본 디렉토리를 보면 <code class="highlighter-rouge">build.sbt</code>가 있습니다.
<code class="highlighter-rouge">sbt</code>라는 명령어를 통해 <code class="highlighter-rouge">sbt-shell</code>로 이동할 수 있습니다.</p>

<p>​</p>

<h3 id="sbt-">자주 사용하는 SBT 명령어</h3>

<ul>
  <li><code class="highlighter-rouge">actions</code> : 사용 가능한 명령 확인</li>
  <li><code class="highlighter-rouge">clean</code> : target 디렉토리의 생성된 모든 파일을 삭제</li>
  <li><code class="highlighter-rouge">update</code> : 프로젝트가 사용하는 라이브러리 다운로드</li>
  <li><code class="highlighter-rouge">compile</code> : 소스코드 컴파일</li>
  <li><code class="highlighter-rouge">test</code> : 테스트 실행</li>
  <li><code class="highlighter-rouge">run</code> : 메인 함수를 통해 코드를 실행</li>
  <li><code class="highlighter-rouge">reload</code> : 빌드 정의 변경 후 재실행</li>
  <li><code class="highlighter-rouge">console</code> : 스칼라 인터프리터를 실행</li>
  <li><code class="highlighter-rouge">package</code> : 배포 가능한 jar파일 생성</li>
  <li><code class="highlighter-rouge">publish-local</code> : 만들어진 jar를 로컬 ivy 캐시에 설치</li>
  <li>
    <p><code class="highlighter-rouge">publish</code> : jar를 원격 저장소에 배포 (원격 저장소 설정 필요)</p>

    <p>​</p>
  </li>
</ul>

<h2 id="reference">Reference</h2>

<p><a href="http://www.scala-sbt.org/0.13/docs/index.html">http://www.scala-sbt.org/0.13/docs/index.html</a></p>

<p>​</p>

	  ]]></description>
	</item>

	<item>
	  <title>Spring JPA, MyBatis</title>
	  <link>//spring-boot-jpa</link>
	  <author>Swalloow</author>
	  <pubDate>2017-04-05T21:18:00+09:00</pubDate>
	  <guid>//spring-boot-jpa</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>최근 스프링 부트를 공부하면서 이것저것 정리하는 중 입니다.</p>

<p>​</p>

<h3 id="jpa-hibernate">JPA, Hibernate</h3>

<p>스프링 JPA와 MyBatis 모두 <strong>Persistance API</strong> 입니다.
JPA는 기존의 EJB와 다른 POJO 기반의 ORM 모델을 제공하며,
대표적으로 <strong>Hibernate</strong> 프레임워크 구현체가 있습니다.</p>

<p>먼저, ORM이라는 개념에 대해 알아야 합니다.
<strong>ORM(Object Relational Mapper)</strong> 는 말 그대로 자바 객체와
데이터베이스의 Entity를 그대로 연결하는 것을 말합니다.
따라서, 모든 SQL문은 Hibernate의 HSQL을 통해 이루어집니다.</p>

<p>이런 개념이 생겨나게 된 이유를 생각해보면
객체지향적으로 데이터를 관리할 수 있기 때문에 비즈니스 로직에 집중 할 수 있으며,
객체지향 개발이 가능하다. 또한, 로직을 쿼리보다 객체에 집중할 수 있다.
따라서, 더 빠른 개발이 가능합니다.</p>

<p>​</p>

<h2 id="mybatis">MyBatis</h2>

<p>MyBatis는 <strong>SQL Mapper</strong> 입니다.
기존에 JDBC를 사용할 때는 DB와 관련된 여러 복잡한 설정(Connection) 들을 다루어야 했습니다.
SQL Mapper는 자바 객체를 실제 SQL문에 연결함으로써,
빠른 개발과 편리한 테스트 환경을 제공해주었습니다.</p>

<p>MyBatis 프로젝트는 원래 Apache Foundation의 iBatis 였으나,
생산성, 개발 프로세스, 커뮤니티 등의 이유로 Google Code로 이전되면서 이름이 바뀌었습니다.
마이그레이션이 되면서 바뀐 차이점은 아래와 같습니다.</p>

<ul>
  <li>JDK 1.5, Annotation</li>
  <li>
    <p>Dynatic SQL, XML Element</p>

    <p>​</p>
  </li>
</ul>

<h2 id="reference">Reference</h2>

<p>전 세계적으로 다양한 언어와 프레임워크가 ORM을 지원하는 방향으로
움직이고 있으며, 많은 회사에서 생산성이 높다는 사실을 입증했습니다.</p>

<p>하지만, MyBatis를 쓰더라도 본인이 쿼리 작성 능력이 뛰어나고,
쿼리 최적화에 자신이 있다면, 더 생산성이 높을 수 있습니다.</p>

<p>반대로, 데이터베이스 모델링에 대한 개념이 없다면,
Hibernate를 쓰더라도 성능 문제와 데이터 손실이 생길 수 있습니다.
ORM도 결국 SQL을 사용한 기술입니다.
따라서 ORM을 사용하더라도 어떤 SQL이 실행될 지 알아야 할 필요가 있습니다.
결국 상황을 잘 고려해서 본인에게 생산성이 더 높은 프레임워크를 선택하는 것이 옳은 것 같습니다.</p>

<p>OKKY 논쟁 글 : <a href="https://okky.kr/article/286812">https://okky.kr/article/286812</a></p>

<p>​</p>

	  ]]></description>
	</item>

	<item>
	  <title>파이썬 웹 어플리케이션 보안 점검 가이드</title>
	  <link>//flask-security</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-08T19:18:00+09:00</pubDate>
	  <guid>//flask-security</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>이 포스팅은 Jacob Kaplan-Moss가 2013년 호주 pycon에서 발표한 자료를 바탕으로 하며, OYT님이 최신화하여 정리해주신 자료를 참고하였습니다.</p>

<p>​   ​</p>

<h2 id="owasp-top-10">OWASP Top 10</h2>

<p>먼저, OWASP(The Open Web Application Security Project)는 오픈소스 웹 애플리케이션 보안 프로젝트로, 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하며,
웹 애플리케이션의 취약점 중에서 빈도가 많이 발생하고, 보안상 영향을 크게 줄 수 있는 것들의 10대 취약점들을 발표합니다.
보통 3년을 주기로 Top 10 리스트를 발표하는데 2017년에도 발표할 예정이라고 합니다.
Top 10 항목들은 다음과 같습니다.</p>

<ol>
  <li>injection</li>
  <li>Broken auth and session managment</li>
  <li>XSS(cross site scripting)</li>
  <li>Insecure direct object reference(bad url)</li>
  <li>Security misconfiguration(read official secret guideline)</li>
  <li>Sensitive data exposure</li>
  <li>Missing function-level access control(decorator)</li>
  <li>CSRF(Cross site request forgery)</li>
  <li>Components with known vulnerabilities(version check!)</li>
  <li>Unvalidated redirects
​</li>
</ol>

<p>이제 파이썬 웹 어플리케이션에서 이를 어떻게 대응할 수 있는지 알아보겠습니다.</p>

<p>​   ​</p>

<h3 id="sql-injection">1. SQL injection</h3>

<p>SQL 인젝션이란, 사용자가 입력한 값이 개발자가 의도치 않은 db query 결과를 초래하는 것, 또는 그것을 이용한 공격을 말합니다.
예를 들면, 아래와 같이 user_id를 string format 쿼리로 넣으면 이러한 공격에 취약할 수 있습니다.</p>

<script src="https://gist.github.com/Swalloow/9b0b074fa0939ee9a339a9da39d066ea.js"></script>

<ul>
  <li>단순 string formatted된 query가 있는지 확인</li>
  <li>raw query 사용 시 bind parameter를 사용했는지 확인</li>
</ul>

<p>​   ​</p>

<h3 id="session-management">2. Session Management</h3>

<p>세션 데이터는 항상 안전하지 않다고 생각해야 합니다. db에 저장되더라도 안전하지 않은건 마찬가지입니다.
특히 예기치 않은 공격에 대비하기 위해 <strong>서버 측에서 세션을 관리</strong> 하는 것이 필요합니다.</p>

<p>Flask에서는 <code class="highlighter-rouge">Flask-Session</code>이라는 확장 패키지를 통해 이를 쉽게 구현할 수 있습니다.
특히 <code class="highlighter-rouge">PERMANENT_SESSION_LIFETIME</code> 이라는 변수를 통해 일정 시간이 지나면 세션을 자동 파기할 수 있습니다.</p>

<ul>
  <li>코드 상에서 공격자가 직접 열람, 추가, 변경 할 수 없는 서버 단 세션 변수를 사용</li>
  <li>일정 시간이 지나면 세션을 자동 파기</li>
  <li>중복 로그인 방지</li>
</ul>

<p>​   ​</p>

<h3 id="xss-cross-site-scripting">3. XSS (Cross-site-scripting)</h3>

<p>XSS란, 웹페이지에 관리자가 의도하지 않는 스크립트(주로 javascript)를 사용자가 넣을 수 있는 상황을 말합니다.
예를 들면 비정상적인 페이지가 보이게하여 타 사용자의 사용을 방해하거나 쿠키 및 기타 개인정보를 특정 사이트로 전송하는 등의 문제가 이에 해당합니다.</p>

<script src="https://gist.github.com/Swalloow/6ddf641ae4cef63ac479c0865aecf23c.js"></script>

<ul>
  <li>유저 입력을 받는 html코드는 항상 escape 할 것</li>
  <li>아무리 똑똑해도 escape 기능을 끄지 말 것</li>
</ul>

<p>​   ​</p>

<h3 id="insecure-direct-object-references">4. Insecure Direct Object References</h3>

<p>일명 직접 객체 참조, 또는 Bad url은 개발자가 파일, 디렉토리, DB 키와 같은 내부 구현 객체를 참조하는 것을 노출시킬 때 발생합니다.
아래의 코드를 통해 예를 들어보겠습니다.</p>

<script src="https://gist.github.com/Swalloow/507ef580b2c1acf26c341fc44dfd0d3d.js"></script>

<ul>
  <li>user_id 등 db와 직접 관계된 값을 GET parameter로 사용하고 있는지 확인</li>
  <li>웹 방화벽에서 상위 혹은 하위 디렉토리로 이동하는 특수문자를 필터링할 것</li>
  <li>파일을 다운로드하는 소스코드에서는 직접적으로 파일의 경로 및 파일명을 파라미터로 받는 것을 피할 것</li>
</ul>

<p>​   ​</p>

<h3 id="security-misconfiguration">5. Security Misconfiguration</h3>

<p>기본으로 제공되는 값은 종종 안전하지 않기 때문에 보안 설정은 정의, 구현 및 유지되어야 합니다.
대표적으로 <strong>코드 난독화</strong> 가 이에 해당합니다.</p>

<p>파이썬에서는 <code class="highlighter-rouge">Base64</code> 패키지를 통해 Encoding/Decoding 하는 방법이 있습니다.
더 나아가 <code class="highlighter-rouge">pycrypto</code> 패키지를 사용하면 Crypto 모듈을 통해 AES 알고리즘으로 암호화할 수 있습니다.</p>

<ul>
  <li><a href="http://flask.pocoo.org/docs/security/">http://flask.pocoo.org/docs/security/</a> 를 정독해볼 것</li>
  <li>debug 모드를 off 하였는지 확인</li>
</ul>

<p>​   ​</p>

<h3 id="sensitive-data-exposure">6. Sensitive data exposure</h3>

<p>많은 웹 애플리케이션들이 신용카드, 개인 식별 정보 및 인증 정보와 같은 중요한 데이터를 제대로 보호하지 않습니다.
공격자는 신용카드 사기, 신분 도용 또는 다른 범죄를 수행하는 등 약하게 보호된 데이터를 훔치거나 변경할 수 있습니다.
따라서, 중요 데이터가 저장 또는 전송 중이거나 브라우저와 교환하는 경우 특별히 주의하여야 하며, 암호화해야 합니다.</p>

<p>REST API에서는 JSON으로 데이터를 통해 통신하기 때문에 <strong>JWE (JSON Web Encryption)</strong> 를 통해 JSON을 암호화해주는 방법이 있습니다.
파이썬의 <code class="highlighter-rouge">python-jose</code> 또는 <code class="highlighter-rouge">PyJWE</code>를 참고하시면 쉽게 구현할 수 있습니다.</p>

<ul>
  <li><code class="highlighter-rouge">JOSE(Javascript Object Signing and Encryption)</code> 규격을 통해 데이터 암호화</li>
  <li>모든 암호를 bcrypt or PBKDF2로 해시 암호화 하였는지 확인</li>
  <li>password 생성 rule을 정하였는지 확인</li>
</ul>

<p>​   ​
​</p>

<h3 id="missing-function-level-access-control">7. Missing function-level access control</h3>

<p>요청에 대해 적절히 확인하지 않을 경우 공격자는 적절한 권한 없이 기능에 접근하기 위한 요청을 위조할 수 있게 됩니다.
따라서, 관리자 페이지 등에 대하여 <strong>유저 권한을 클라이언트가 아닌 서버에서 판단</strong> 해야 하며
역할에 기반한 별도의 인증절차를 요구하도록 만들어야 하고 권한이 없는 유저들은 접근 불가하게 코딩해야 합니다.</p>

<script src="https://gist.github.com/Swalloow/3b727fdcf84c640077de8f414ad785dc.js"></script>

<ul>
  <li>로그인, 토큰 등 접근 관련 flow에서 hard-coding하지 않고 <code class="highlighter-rouge">decorator</code>등을 사용했는지 확인</li>
  <li>OAuth와 같이 Token 기반의 인증시스템을 통해 접근 권한을 부여</li>
</ul>

<p>​   ​</p>

<h3 id="csrfcross-site-request-forgery">8. CSRF(Cross site request forgery)</h3>

<p>CSRF는 로그인 된 사용자의 웹 애플리케이션에 세션 쿠키와 기타 다른 인증정보를 자동으로 포함하여 위조된 HTTP 요청을 강제로 보내도록 하는 것입니다.
공격자는 주로 상태(DB, 세션 등)를 변경하는 공격을 합니다. XSS를 방지하면 어느정도 커버되기도 합니다.</p>

<script src="https://gist.github.com/Swalloow/983d1b2509a47c8267a69e1c37434244.js"></script>

<ul>
  <li>GET 요청으로 상태를 바꾸는 것이 없는지 확인</li>
  <li>POST에 CSRF Token을 달아놓았는지 확인 (공격자가 주입해도 서버에서 거절)</li>
</ul>

<p>​   ​</p>

<h3 id="components-with-known-vulnerabilities">9. Components with known vulnerabilities</h3>

<p>컴포넌트, 라이브러리, 프레임워크 및 다른 소프트웨어 모듈은 대부분 항상 전체 권한으로 실행되어
취약한 컴포넌트를 악용하여 공격하는 경우 심각한 데이터 손실이 발생하거나 서버가 장악될 수 있습니다.</p>

<ul>
  <li>outdated 된 라이브러리가 있는지, 지속적인 업데이트</li>
  <li>사용되지 않는 기능들을 최대한 비활성화 할 것</li>
</ul>

<p>​   ​</p>

<h3 id="unvalidated-redirects">10. Unvalidated redirects</h3>

<p>웹에서 종종 사용자들을 다른 페이지로 리다이렉트 하거나 포워드하기 위해 신뢰할 수 없는 데이터를 사용하는 경우가 많습니다.
적절한 검증 절차가 없으면 공격자는 피해자를 피싱 또는 악성코드 사이트로 리다이렉트 될 수 있기 때문에 주의해야 합니다.</p>

<ul>
  <li>CORS(cross origin resource sharing)시 host whitelist를 관리하고 있는지</li>
  <li>flask-redirect는 언제나 안전하지 않음을 인지하고 사용하고 있는지</li>
</ul>

<p>​   ​</p>

<h3 id="section">정리 및 관련 링크</h3>

<p>저도 그렇고 학생 때는 대부분 보안을 고려하지 않은 웹 어플리케이션을 개발하는 경우가 많은데,
이 자료가 많은 도움이 되었으면 좋겠습니다!</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=sra9x44lXgU">Pycon youtube 자료</a></li>
  <li><a href="https://www.owasp.org/images/5/57/OWASP_Proactive_Controls_2.pdf">OWASP Top 10 Proactive Controls 2016</a></li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>JWT를 구현하면서 마주치게 되는 고민들</title>
	  <link>//implement-jwt</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-03T19:18:00+09:00</pubDate>
	  <guid>//implement-jwt</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>최근 모바일, 웹 등 다양한 환경에서 서버와 통신하면서 많은 사람들이 JWT 토큰 인증 방식을 추천합니다.
이 포스팅에서는 JWT를 이해하고 구현하면서 마주치게 되는 고민들에 대해 정리해보려 합니다.</p>

<p>​   ​</p>

<h2 id="json-web-token">JSON Web Token</h2>

<p><img src="https://cdn.auth0.com/blog/legacy-app-auth/legacy-app-auth-5.png" alt="JWT-Token" /></p>

<p>JWT에 대한 소개는 생략하고 Token이 어떻게 구성되어 있는지 간략하게 알아보겠습니다.
JSON Web Token은 세 파트로 나뉘어지며, 각 파트는 점(.)에 의해 구분됩니다.
이를 테면 <code class="highlighter-rouge">xxxxx.yyyyy.zzzzz</code> 이런식입니다.</p>

<ul>
  <li>Header는 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있습니다.</li>
  <li>Payload는 claim 정보를 포함하고 있습니다. userId, expire, scope 등이 여기에 해당합니다.</li>
  <li>마지막으로 Signature는 secret key를 포함하여 암호화되어 있습니다.</li>
</ul>

<p>​   ​</p>

<h2 id="jwt-process">JWT Process</h2>

<p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt="JWT-Diagram" /></p>

<p>일반적으로 JWT 토큰 기반의 인증 시스템은 위와 같은 프로세스로 이루어집니다.
처음 사용자를 등록할 때 Access token과 Refresh token이 모두 발급되어야 합니다.</p>

<ol>
  <li>
    <p>먼저 사용자가 id와 password를 입력하여 로그인을 시도합니다.</p>
  </li>
  <li>
    <p>서버는 요청을 확인하고 secret key를 통해 Access token을 발급합니다.</p>
  </li>
  <li>
    <p>이후 JWT가 요구되는 API를 요청할 때는
클라이언트가 Authorization header에 Access token을 담아서 보냅니다.</p>
  </li>
  <li>
    <p>서버는 JWT Signature를 체크하고 Payload로부터 user 정보를 확인해 데이터를 리턴합니다.</p>
  </li>
</ol>

<p>​   ​</p>

<h2 id="jwt--oauth----">JWT와 기존의 OAuth는 서로 어떤 관계가 있을까?</h2>

<p>토큰 기반의 인증 시스템을 처음 접한 사람이라면 저 두 가지 개념이 헷갈릴 수 있습니다.
먼저, 정답부터 말하자면 <u>JWT는 토큰 유형이고 OAuth는 토큰을 발급하고 인증하는 방법을 설명하는 일종의 프레임워크입니다.</u>
기존의 /outh/token endpoint에 의해 발급되는 모든 토큰은 일종의 OAuth 프레임워크에 의해 관리된다고 볼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
	</span><span class="nt">"token_type"</span><span class="p">:</span><span class="s2">"bearer"</span><span class="p">,</span><span class="w">
	</span><span class="nt">"access_token"</span><span class="p">:</span><span class="s2">"eyJ0eXAiOiJKV1QiLCJh"</span><span class="p">,</span><span class="w">
	</span><span class="nt">"expires_in"</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span><span class="w">
	</span><span class="nt">"refresh_token"</span><span class="p">:</span><span class="s2">"fdb8fdbecf1d03ce5e6125c067733c0d51de209c"</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>위의 토큰이 기존 OAuth에서 주로 사용하는 bearer 기반의 토큰 방식입니다.
다만 JWT는 토큰 자체에 유저 정보를 담아서 HTTP 헤더로 전달하기 때문에
유저 세션을 유지할 필요가 없고 가볍게 데이터를 주고받을 수 있다는 장점이 있습니다.</p>

<p>​   ​</p>

<h2 id="access-token-refresh-token---">Access Token과 Refresh Token을 어디에 저장해야 할까?</h2>

<p>앞서 말한것처럼 기본적으로 두 가지 토큰을 사용합니다.
API 요청을 허가하는데 Access Token을 사용하고, 액세스 토큰이 만료된 후 새로운 액세스 토큰을 얻기 위해 Refresh Token을 사용합니다.</p>

<p><img src="/assets/images/access token.png" alt="access_token" /></p>

<p>Access Token은 리소스에 직접 접근할 수 있도록 해주는 정보만을 가지고 있습니다. 즉, 클라이언트는 Access Token이 있어야 서버 자원에 접근할 수 있습니다. Access Token은 짧은 수명을 가지며, 만료기간을 갖습니다. 주로 <strong>세션</strong> 에 담아서 관리합니다.</p>

<p><img src="/assets/images/refresh token.png" alt="refresh_token" /></p>

<p>Refresh Token은 새로운 Access Token을 발급받기 위한 정보를 갖습니다. 즉, 클라이언트가 Access Token이 없거나 만료되었다면 Refresh Token을 통해 Auth Server에 요청해서 발급받을 수 있습니다. Refresh Token 또한 만료기간이 있지만 깁니다. Refresh Token은 중요하기 때문에 외부에 노출되지 않도록 엄격하게 관리해야 하므로 주로 <strong>데이터베이스</strong> 에 저장합니다.</p>

<p>토큰이 안전하게 관리되는지 여부는 어떻게 구현하느냐에 달려있습니다. 보통은 Access Token에 대해 직접적으로 인증(direct authorization) 체크합니다. 무슨 말이냐 하면, Access Token이 서버 자원에 접근하려고 하면 서버가 토큰에 있는 정보를 읽어 스스로 인증여부를 결정합니다. 반면에, Refresh Token은 Auth Server에 대한 체크가 필요합니다. 이때 다음과 같은 세 가지 사항을 고려해야 합니다.</p>

<ul>
  <li>빠른 인증 과정을 위해 토큰에 정보를 적게 담아야 합니다.</li>
  <li>노출된 Access Token에 대해서는 빠르게 만료시켜 리소스에 접근할 수 있는 가능성을 줄어야 합니다.</li>
  <li>Sliding sessions에 대한 처리가 필요합니다.</li>
</ul>

<p>​   ​</p>

<h4 id="sliding-sessions">Sliding sessions</h4>

<p>Sliding sessions은 일정 기간 사용하지 않으면 만료되는 세션입니다. 이 세션은 refresh token과 access token을 통해 구현할 수 있습니다. 먼저, 사용자가 작업을 수행하려하면 새 access token이 발급됩니다. 반면, 사용자가 만료된 access token을 사용하려 하면 세션은 비활성화되며 새 access token을 요청합니다. 이 상황에서 refresh token을 통해 새로운 토큰을 발급받을 지는 개발 팀이 결정하기에 따라 다릅니다.</p>

<p>​   ​</p>

<h2 id="section">토큰 재발급 로직에 대한 고민</h2>

<p>JWT를 쓴다면 만료시간을 꼭 명시적으로 두도록 하고 중간마다 토큰을 재발행하도록 권장하는 것이 대부분입니다.
리프레시 관련해서 정확한 내용이 정해져 있는 것은 아니지만 일반적인 API를 보면
최초 발급시 Access Token과 Refresh Token 2개를 발급하고 Access Token으로 API를 사용하다가
만료시간이 지나면 만료시간을 길게 준 Refresh Token을 이용해서 Access Token을 다시 발급합니다.</p>

<p>가장 일반적인 방법은 클라이언트가 토큰의 만료시간을 알 수 있기 때문에, 클라이언트에서 판단해서 만료시간이 넘었으면 토큰 재발급을 요청하는 방법입니다.
좀 더 쉽게 구현하는 방법은 TokenExpiredError가 발생했을 때 재발급을 해주는 것입니다.</p>

<p>만료된 토큰을 통해 접근하려고 하면 다음과 같은 오류가 나타나게 합니다.</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
	</span><span class="nt">"code"</span><span class="p">:</span><span class="mi">401</span><span class="p">,</span><span class="w">
	</span><span class="nt">"error"</span><span class="p">:</span><span class="s2">"invalid_token"</span><span class="p">,</span><span class="w">
	</span><span class="nt">"error_description"</span><span class="p">:</span><span class="s2">"The access token provided has expired."</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>​   ​</p>

<h2 id="section-1">기타, 참고자료</h2>

<p>Flask에는 Flask-JWT라는 패키지가 있지만 Scope나 Refresh Token에 대한 구현이 부족하기 때문에
pyjwt를 통해 직접 구현하는 방법을 추천합니다.</p>

<p>아래는 JWT에 대하여 가장 많이 도움이 되는 페이지입니다.
들어가서 가입하면 <strong>JWT Handbook</strong> 이라는 EBook도 무료로 제공합니다. <a href="https://jwt.io/">https://jwt.io/</a></p>

<ul>
  <li><a href="https://auth0.com/blog/ten-things-you-should-know-about-tokens-and-cookies/">10 things you should know about tokens and cookies</a></li>
  <li><a href="https://auth0.com/learn/refresh-tokens/">Learn refresh tokens</a></li>
  <li><a href="http://stackoverflow.com/questions/30826726/how-to-identify-if-the-oauth-token-has-expired">How to identify if the OAuth token has expired</a></li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>HTTPS와 SSL 인증서, 그리고 SHA1 알고리즘</title>
	  <link>//https-ssl</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-01T19:18:00+09:00</pubDate>
	  <guid>//https-ssl</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>크롬 업데이트 이후 몇몇 웹 페이지는 브라우저 주소 창에 <code class="highlighter-rouge">안전하지 않음</code>이 나타나고,
아니면 자물쇠 모양에 <code class="highlighter-rouge">안전함</code>이 표시되는 것을 볼 수 있습니다.
오늘은 그 두 가지 방식에 어떤 차이가 있는지, HTTPS와 SSL 인증서에 대해 알아보고
최근 구글과 리누스 토발즈의 언급으로 이슈화 되고 있는 SHA1 암호화 알고리즘에 대해 정리해보려 합니다.</p>

<p>​   ​</p>

<h2 id="http-https">HTTP와 HTTPS</h2>

<p>우선 간단히 웹 통신규약에 대해 설명하자면, <em>HTTP는 Hypertext 인 HTML을 전송하기 위한 통신규약</em> 을 의미합니다.
HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 확인하는 것이 매우 쉽습니다.
심각한 예를 들면, 로그인을 위해서 서버로 비밀번호를 전송하거나 중요한 기밀 문서를 열람하는 과정에서 악의적인 감청이나 데이터의 위변조 등이 일어날 수 있습니다.</p>

<p>이를 보완하기 위해 나온 것이 보안이 강화된 <strong>HTTPS</strong> 입니다.
HTTPS는 보안을 강화하기 위해 통신에서 일반 텍스트를 이용하지 않고 <strong>SSL이나 TLS 프로토콜</strong> 을 통해 세션 데이터를 암호화합니다.
이를 통해 데이터의 보안을 더 강화할 수 있지만 전적으로 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있습니다.</p>

<p>결국 크롬에 <code class="highlighter-rouge">안전하지 않음</code>으로 표기되는 페이지는 보안 인증서가 없는 페이지입니다.
반면에, <code class="highlighter-rouge">안전함</code>으로 표기되는 페이지는 기관으로부터 인증서를 받은 페이지입니다.
실제로 인터넷 익스플로러의 인터넷 옵션을 확인해보면 CA 라는 탭에서 인증서를 확인하실 수 있습니다.</p>

<p>​   ​</p>

<h2 id="ssl--">SSL 통신 과정</h2>

<p>그렇다면 HTTPS에 포함된 SSL 프로토콜이 어떤 과정을 통해 동작하는지 간단히 알아보겠습니다.
다시 설명하자면, <em>SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서</em> 라고 보시면 됩니다.
처음 클라이언트와 서버가 데이터를 주고 받기 위해서는 준비과정이 필요합니다. 이를 <strong>핸드쉐이크(HandShake)</strong> 라고 부릅니다.</p>

<p><img src="/assets/images/ssl-process.jpg" alt="ssl-process" /></p>

<ol>
  <li>
    <p>먼저, 클라이언트가 서버에 접속(Client Hello)한 직후에 서버는 클라이언트에게 인증서 정보를 전달(Server Hello)합니다.</p>
  </li>
  <li>
    <p>클라이언트(브라우저)는 이미 모든 CA 인증기관들에 대한 정보를 가지고 있기 때문에 공개키를 통해
전달받은 인증서를 복호화하고 신뢰할 수 있는 서버인지 확인합니다.</p>
  </li>
  <li>
    <p>안전함이 확인되면 클라이언트는 대칭키 암호화 방식을 통해 비밀키를 생성하고 이를 공개키 방식으로 암호화해서 서버에게 전달합니다.</p>
  </li>
  <li>
    <p>서버는 자신의 비공개 키로 복호화하여 서버와 클라이언트가 세션키를 공유하게 되면, 핸드쉐이크 과정의 종료를 서로에게 알립니다.</p>
  </li>
  <li>
    <p>이제 세션을 통해 서버와 클라이언트가 데이터를 주고 받게 됩니다.
여기서 세션키 값을 이용해서 대칭키 방식으로 암호화하기 때문에 HTTP 보다 안전합니다.</p>
  </li>
  <li>
    <p>데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려줍니다. 그리고 통신에서 사용한 대칭키인 세션키를 폐기합니다.</p>
  </li>
</ol>

<p>​   ​</p>

<h2 id="sha1------">SHA1 암호화 알고리즘은 더 이상 안전하지 않다?</h2>

<p>이 논란은 구글이 2월 중순쯤에 낡은 암호화 알고리즘 SHA1를 깨뜨리면서 시작되었습니다.
구글은 SHA1 알고리즘 해시값의 고유성을 깨뜨릴 수 있는 <strong>‘섀터드(SHAttered)’</strong> 라는 방법을 선보이면서,
SHA1에 의존하는 기술은 믿음직하지 않다는 점을 보여줬습니다.</p>

<p>여기서 섀터드 기법을 소개한 연구자들은 <em>Git이 SHA1에 의존하기 때문에 안전하지 않다</em> 고 말했습니다.
이에 리누스 토발즈는 <em>“깃은 데이터를 해시하기만 하는 게 아니라, 거기에 타입과 길이 필드를 측량한다”</em> 고 말하면서
당장은 하늘이 무너지는게 아니니 상관없다고 답변했습니다.</p>

<p>물론 당장은 아니지만 불안함에 많은 기관들이 SHA1 방식에서 <strong>SHA2 또는 SHA256</strong> 으로 옮겨가고 있습니다.
대표적으로 크롬, 파이어폭스 등의 브라우저들이 SHA1 인증서 퇴출에 노력하고 있고, 인터넷뱅킹이나 비트코인 같은 경우 SHA256 방식을 사용합니다.</p>

<p>리누스 토발즈의 글 : <a href="https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL">https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL</a></p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>Swagger로 API 문서화하기</title>
	  <link>//swagger-api-doc</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-25T19:18:00+09:00</pubDate>
	  <guid>//swagger-api-doc</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>개발에 있어서 API 문서화는 아주 중요하지만 번거로운 일 중에 하나입니다.
특히 pdf 또는 한글 파일로 관리하고 있다면 갱신할때마다 아주 번거롭습니다.</p>

<p>이를 해결하기 위해 자칭 세계에서 가장 유명한 API 프레임워크인 <strong>Swagger</strong> 를 사용해보겠습니다.
<a href="http://swagger.io/">Swagger 공식 홈페이지</a>를 보면 많은 정보가 있습니다.</p>

<p>​   ​</p>

<h3 id="swagger-ui">Swagger UI</h3>

<p>Swagger UI를 사용하면 웹 브라우저를 통해 Swagger에 정의된 REST API를 시각화하고 테스트할 수 있습니다.
내장된 테스트 기능을 사용하면 GUI로 API를 테스트하며 결과를 확인할 수 있습니다.
자세한 정보는 <a href="https://github.com/swagger-api/swagger-ui">GitHub: Swagger UI</a> 를 참고하시면 됩니다.</p>

<p>​   ​</p>

<h3 id="swagger-codegen">Swagger Codegen</h3>
<p>Swagger Codegen을 사용하면 REST API용 Swagger 문서를 통해 다양한 언어로 SDK를 생성할 수 있습니다.
생성된 SDK를 사용하여 API를 완전히 구현하기 전에 생성된 샘플 서버 구현에서 실시간으로 API를 테스트할 수 있습니다.
자세한 정보는 <a href="https://github.com/swagger-api/swagger-codegen">GitHub: Swagger Codegen</a> 를 참조하시면 됩니다.</p>

<p>​   ​</p>

<h3 id="swagger-editor">Swagger Editor</h3>

<p><a href="editor.swagger.io">editor.swagger.io</a> 에서 Swagger Editor, Swagger UI 및 Swagger Codegen을 제공합니다.
최대한 간편한 용도로 사용하시겠다면 yaml 이나 json 파일을 이곳에 import 해서 사용하셔도 됩니다.</p>

<p>이외에도 <a href="http://bigstickcarpet.com/swagger-parser/www/index.html">http://bigstickcarpet.com/swagger-parser/www/index.html</a>
Swagger Validator와 Parser가 있습니다.</p>

<p>​   ​</p>

<h3 id="docker-swagger-ui-">Docker로 Swagger UI를 적용해보자</h3>

<p>앞서 설명하자면 Docker로 실행하는 이유는 “아직 맥북에 npm 환경구축이 안되어서” 입니다.
<code class="highlighter-rouge">npm install</code> 을 통해 빌드하셔도 됩니다.</p>

<h5 id="section">1.</h5>
<p>먼저 로컬에 <a href="https://github.com/swagger-api/swagger-ui">Swagger UI GitHub 저장소</a>를 clone 해줍니다.</p>

<h5 id="section-1">2.</h5>
<p>그 다음 Docker를 실행하고 아래의 명령어를 통해 Dockerfile을 빌드합니다.
localhost:80 에 접속하면 Swagger-UI가 실행된 것을 볼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker build -t swagger-ui-builder .
docker run -p 80:8080 swagger-ui-builder</code></pre></figure>

<h5 id="section-2">3.</h5>
<p>이제 Swagger Editor로 문서를 작성하고 yaml 형식으로 다운로드 받고, 파일을 Swagger/dist/로 이동합니다.
그리고 Swagger/dist/index.html 파일의 url을 swagger.yaml로 수정합니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">search</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/url=</span><span class="se">([^</span><span class="sr">&amp;</span><span class="se">]</span><span class="sr">+</span><span class="se">)</span><span class="sr">/</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">url</span> <span class="o">&amp;&amp;</span> <span class="nx">url</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">url</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nx">url</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nx">url</span> <span class="o">=</span> <span class="s2">"swagger.yaml"</span><span class="p">;</span>
   <span class="p">}</span></code></pre></figure>

<p>이제 웹 서버에 올리기만 하면 API 문서를 쉽게 확인할 수 있습니다!</p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>충돌을 해결하기 위한 git stash 명령어</title>
	  <link>//git-stash</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-23T19:18:00+09:00</pubDate>
	  <guid>//git-stash</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>git을 사용하다보면 여러 변경내역이 생기게 됩니다.
예를 들면 내 로컬에서 변경된 내역을 아직 commit을 하지 않은 상태로 pull을 하게 되면,
충돌이 발생하게 되어 초보자에게는 난감한 상황이 됩니다.
이런 경우에 git stash 명령어를 사용하시면 편리합니다.</p>

<p>git stash 명령어는 unstaged 상태인 변경사항을 일시적으로 백업하고 워킹디렉토리를 깨끗한 상태로 유지합니다.
즉, 일종의 책갈피 역할을 한다고 보시면 됩니다.</p>

<p>​   ​</p>

<h4 id="git-stash">1. git stash</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash
Saved working directory and index state <span class="se">\</span>
  <span class="s2">"WIP on master: 049d078 added the index file"</span>
HEAD is now at 049d078 added the index file
<span class="o">(</span>To restore them <span class="nb">type</span> <span class="s2">"git stash apply"</span><span class="o">)</span></code></pre></figure>

<p>git stash 명령어를 실행하면 작업 중인 파일을 새로운 Stash에 저장합니다.</p>

<p>​   ​</p>

<h4 id="git-stash-list">2. git stash list</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash list
stash@<span class="o">{</span>0<span class="o">}</span>: WIP on master: 049d078 added the index file
stash@<span class="o">{</span>1<span class="o">}</span>: WIP on master: c264051 Revert <span class="s2">"added file_size"</span>
stash@<span class="o">{</span>2<span class="o">}</span>: WIP on master: 21d80a5 added number to log</code></pre></figure>

<p>git stash list 명령어를 통해 저장된 책갈피들의 리스트를 볼 수 있습니다.</p>

<p>​   ​</p>

<h4 id="git-stash-apply">3. git stash apply</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash apply
<span class="c"># On branch master</span>
<span class="c"># Changes not staged for commit:</span>
<span class="c">#   (use "git add &lt;file&gt;..." to update what will be committed)</span>
<span class="c">#</span>
<span class="c">#      modified:   index.html</span>
<span class="c">#      modified:   lib/simplegit.rb</span>
<span class="c">#</span></code></pre></figure>

<p>git stash apply 명령어를 사용하면 저장된 stash를 적용할 수 있습니다.</p>

<p>​   ​</p>

<h4 id="git-stash-drop">4. git stash drop</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash drop stash@<span class="o">{</span>0<span class="o">}</span>
Dropped stash@<span class="o">{</span>0<span class="o">}</span> <span class="o">(</span>364e91f3f268f0900bc3ee613f9f733e82aaed43<span class="o">)</span></code></pre></figure>

<p>apply 명령어로 stash를 적용한다고 해서 스택에서 사라지는게 아닙니다.
git stash drop 명령어를 통해 스택에서 삭제할 수 있습니다.</p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>다양한 소셜 API를 연동하기 전에 고려할 것들 (AWS Cognito)</title>
	  <link>//social-api-cognito</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-28T19:18:00+09:00</pubDate>
	  <guid>//social-api-cognito</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>최근에 대부분의 웹, 모바일 어플리케이션에서 카카오, 네이버 등 다양한 소셜 로그인 기능을 제공하고 있다.
만약 우리가 만들어야 할 어플리케이션이 다양한 소셜 로그인 API와 연동하여 사용자를 관리해야한다면, OAuth 인증, 보안 등 개발할 때 고려해야할 요소가 많을 것이다.</p>

<p>따라서, 이 글을 통해 최근 유행하는 클라우드 기반 웹 어플리케이션 설계 방식을 아주 간단히 보고 적합한 설계 방식을 선택하는데 도움이 되었으면 좋겠다.</p>

<p>OAuth2.0에 대해서는 이전에 쓴 글을 참조하길 바란다. <a href="http://swalloow.github.io/about-oauth2/">http://swalloow.github.io/about-oauth2/</a></p>

<p>​</p>

<h2 id="oauth-20-grant-flow">1. OAuth 2.0 Grant Flow</h2>

<p><img src="assets/images/OAuth2 Grant Flow1.png" alt="OAuth2 Grant Flow1" /></p>

<p>주로 자바스크립트 기반 웹 어플리케이션에서 많이 사용하는 방식이다. (스크립트 보안 유출 고려)
최근에는 모바일에서도 많이 사용한다고 한다.</p>

<p>​</p>

<p><img src="assets/images/OAuth2 Grant Flow2.png" alt="OAuth2 Grant Flow2" /></p>

<p>이 방식은 직접 ID, PW 보내는 방식으로 파트너나 자사 시스템에 사용한다.
기존의 HTTP 방식을 그대로 사용하기 용이하다.</p>

<p>위와 같은 방식을 사용했을 때의 장점은 OAuth 2.0을 몸소 체험할 수 있다는 것이다.
반면에, 단점은 다음과 같다.</p>

<ul>
  <li>사용자 데이터에 대한 보안을 고려해야 한다.</li>
  <li>Facebook, Twitter 모두 각자에게 최적화 되어 있어 확장성을 고려한 인증 인터페이스를 만들기 힘들다.</li>
  <li>Token만 존재하기 때문에 사용자 관리, 사용자를 구분하기가 힘들다.</li>
  <li>모바일과 웹 어플리케이션이 모두 존재한다면, 인증 및 디바이스 간 동기화 처리 문제가 있다.</li>
  <li>
    <p>시스템 충돌과 네트워크 연결 문제 또한 감당해야 한다.</p>

    <p>​</p>
  </li>
</ul>

<h2 id="aws-ec2--cognito-baas">2. AWS EC2 + Cognito (BaaS)</h2>

<p><img src="assets/images/AWS Authentication process.png" alt="AWS Authentication process" /></p>

<p>사용자 로그인, 인증 처리에 대해 AWS Cognito를 사용한 방법이다.
기본적인 EC2 인스턴스에 Cognito만 추가해서 사용하면 된다.</p>

<p>이러한 방법을 적용했을 때의 단점은 일단 클라우드에 요금을 내야 한다는 것이다.
또한, AWS Cognito에서 지원하지 않는 카카오 로그인 같은 경우 복잡한 과정이 필요하다.
반면에 장점은 다음과 같다.</p>

<ul>
  <li>SAML을 통한 보안 문제 해결.</li>
  <li>놀라운 확장성. (SOCIAL IDENTITY를 추가하기만 하면 끝, 모바일 앱까지 확장 가능)</li>
  <li>편리한 사용자 관리. (USER POOL 기능 제공)</li>
  <li>인증 및 디바이스간 동기화 처리. (Cognito Sync가 알아서 해준다)</li>
  <li>시스템 충돌과 네트워크 연결 문제. (Cognito Sync가 알아서 해준다)</li>
  <li>
    <p>위와 같은 문제를 신경 안쓰므로 로직에 집중해서 빠른 개발이 가능하다.</p>

    <p>​</p>
  </li>
</ul>

<h2 id="aws-serverless-architecture-baas--faas">3. AWS Serverless Architecture (BaaS + FaaS)</h2>

<p><img src="assets/images/AWS WebApp Application Architecture.png" alt="AWS WebApp Application Architecture" /></p>

<p>AWS API Gateway와 Lambda를 통한 서버리스 아키텍쳐에 대해서는 아래 링크를 참고하자.
서버리스 아키텍쳐는 서버를 관리할 필요 없이 특정 이벤트에 반응하는 함수를 등록하고, 해당 이벤트가 발생하면 함수가 실행되는 구조이다.
장점은 다음과 같다.</p>

<ul>
  <li>서버에 고성능이 필요할 시에는 비용이 절감된다.</li>
  <li>서비스 지향적인 설계가 가능하다. (마이크로 아키텍쳐)</li>
  <li>자동 스케일링</li>
  <li>코드 생산에 집중할 수 있고, 유연한 배포 및 테스트가 가능하다.</li>
</ul>

<p>반면에 단점은 다음과 같다.</p>

<ul>
  <li>AWS 과금이 많이 나올 수 있다. (쓸데없이 많이 고려한 설계일수도)</li>
  <li>
    <p>API Gateway, Lambda에 대한 러닝 커브가 상당하다. (많은 스터디 필요)</p>

    <p>​</p>
  </li>
</ul>

<h2 id="section">결론</h2>

<p>최근에 유행하는 서버리스 아키텍쳐나 마이크로 아키텍쳐를 무조건 도입해야하는 것은 절대 아니다.
각자 프로젝트의 상황에 맞는 방법을 선택하는게 답인듯하다.</p>

<p>​​</p>

<h2 id="section-1">참고하면 좋은 문서들</h2>

<ul>
  <li><a href="https://medium.com/@parkgeunhack/%EC%95%8C%EB%A0%89%EC%8A%A4%EC%9D%98-%EC%9D%B4%EC%95%BC%EA%B8%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-c3aa12baaa75#.kkskaeaqa">박근핵닷컴 서버 개발일지</a></li>
  <li><a href="https://aws.amazon.com/ko/cognito/?nc2=h_m1">AWS Cognito</a></li>
  <li><a href="https://aws.amazon.com/ko/blogs/korea/category/amazon-cognito/">AWS Cognito Blog</a></li>
  <li><a href="http://blog.aliencube.org/ko/2016/06/23/serverless-architectures/">Serverless-Architecture</a></li>
  <li><a href="http://www.popit.kr/why-microservice/">Popit - 마이크로서비스 아키텍쳐의 장단점</a></li>
  <li>
    <p><a href="http://bcho.tistory.com/942">조대협 블로그 - OAuth 2.0 Architecture</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Open API를 설계할 때 알아야 하는 것들</title>
	  <link>//open-api-guide</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-05T19:18:00+09:00</pubDate>
	  <guid>//open-api-guide</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>오픈 API를 사용하다보면 공통의 패턴을 발견할 수 있을 것이다.
이처럼, API를 설계할 때도 개발자들이 쉽게 사용할 수 있도록 만든 규칙이라는게 존재한다.
오늘은 RESTful한 Open API를 설계하기 위해 알아야 하는 것들에 대해 정리해보았다.</p>

<p>​</p>

<h2 id="open-api-">Open API 디자인</h2>

<p>​</p>

<h3 id="api-">API 란?</h3>

<blockquote>
  <p>운영체제, 시스템, 애플리케이션, 라이브러리 등을 개발자들이 프로그래밍 작업을 통해 응용 프로그램을 작성할 수 있는 다양한 인터페이스들을 총칭한다. (예: Window API, Java API, HTML5 API, Android API…) - 네이버 개발자센터 인용</p>
</blockquote>

<p>​</p>

<h3 id="api--1">오픈 API 란?</h3>

<blockquote>
  <p>API 중에서 플랫폼의 기능 또는 컨텐츠를 외부에서 쓸 수 있도록 웹 프로토콜(HTTP)로 호출할 수 있도록 개방(open)한 API를 의미한다. 네이버 개발자센터에서 제공하고 있는 지도, 검색을 비롯 기계번역, 캡차, 단축 URL 등 대부분 API 들은 HTTP로 호출할 수 있는 오픈 API에 해당한다. - 네이버 개발자센터 인용</p>
</blockquote>

<p>​</p>

<p>이제 기업 또는 사용자에게 제공할 RESTful Open API를 어떻게 설계할지 고민해보자.
기업에게 전문적으로 API를 공급하는 Apigee 사의 <strong>Web API Design</strong> 을 레퍼런스로 삼았다.</p>

<p>​</p>

<h2 id="best-web-api-design-rules">Best Web API Design Rules</h2>

<p>​</p>

<h5 id="url------2--url-">1. 기본 URL에는 동사가 아닌 명사를 사용, 리소스마다 2개의 기본 URL을 유지하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">/</span><span class="n">dogs</span> <span class="p">(</span><span class="n">Collection</span><span class="p">),</span> <span class="o">/</span><span class="n">dogs</span><span class="o">/</span><span class="mi">1234</span> <span class="p">(</span><span class="n">Element</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="http-post-get-put-delete-">2. 올바른 HTTP 메서드(POST, GET, PUT, DELETE)를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">POST</span><span class="p">(</span><span class="n">create</span><span class="p">),</span> <span class="n">GET</span><span class="p">(</span><span class="n">read</span><span class="p">),</span> <span class="n">PUT</span><span class="p">(</span><span class="n">update</span><span class="p">),</span> <span class="n">DELETE</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="section">3. 복수형 명사와 구체적인 이름을 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">/</span><span class="n">animals</span><span class="p">,</span> <span class="o">/</span><span class="n">dogs</span></code></pre></figure>

<p>​</p>

<h5 id="url----">4. 자원 간의 관계를 간단히 하여 URL 계층이 깊어지는 것을 피하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span>	<span class="o">/</span><span class="n">owners</span><span class="o">/</span><span class="mi">5678</span><span class="o">/</span><span class="n">dogs</span><span class="err">?</span><span class="n">color</span><span class="o">=</span><span class="n">red</span></code></pre></figure>

<p>​</p>

<h5 id="section-1">5. 오류 처리를 명확하게 하고 에러 스택은 절대 비공개 해야 한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">200</span> <span class="o">-</span> <span class="n">OK</span>
<span class="mi">400</span> <span class="o">-</span> <span class="n">Bad</span> <span class="n">Request</span>
<span class="mi">500</span> <span class="o">-</span> <span class="n">Internal</span> <span class="n">Server</span> <span class="n">Error</span>
<span class="mi">201</span> <span class="o">-</span> <span class="n">Created</span>
<span class="mi">304</span> <span class="o">-</span> <span class="n">Not</span> <span class="n">Modified</span>
<span class="mi">404</span> <span class="o">-</span> <span class="n">Not</span> <span class="n">Found</span>
<span class="mi">401</span> <span class="o">-</span> <span class="n">Unauthorized</span>
<span class="mi">403</span> <span class="o">-</span> <span class="n">Forbidden</span></code></pre></figure>

<p>​</p>

<h5 id="v------">6. 접두사 “v”로 버전을 지정하고 지속적인 버전 관리를 하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span>	<span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">dogs</span></code></pre></figure>

<p>​</p>

<h5 id="section-2">7. 데이터베이스에 없는 자원에 대한 응답일 경우 동사를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">ex</span><span class="p">)</span> <span class="n">Caculate</span><span class="p">,</span> <span class="n">Translate</span><span class="p">,</span> <span class="n">Convert</span> <span class="o">...</span></code></pre></figure>

<p>​</p>

<h5 id="javascript-----">8. 속성의 네이밍은 Javascript의 관습을 따르고 카멜 케이스를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="s">"createdAt"</span><span class="p">:</span> <span class="mi">123415125</span></code></pre></figure>

<p>​</p>

<h5 id="api---">9. 하위 도메인의 독립적인 API 요청 처리는 통일하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">company</span><span class="o">.</span><span class="n">com</span>
<span class="n">api</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">com</span>	<span class="p">(</span><span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">,</span> <span class="n">redirect</span><span class="p">)</span>
<span class="n">developers</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">com</span></code></pre></figure>

<p>​</p>

<h5 id="section-3">10. 기타</h5>

<ul>
  <li>권한 관리(OAuth)는 2.0을 사용하자.</li>
  <li>필요한 경우, SDK로 API를 보완하자.</li>
  <li>
    <p>API Facade Pattern을 API 설계에 고려해라.</p>

    <p>​</p>
  </li>
</ul>

<h3 id="naver-open-api">NAVER Open API</h3>

<p>실제 네이버와 카카오의 오픈 API는 어떻게 디자인되어 있는지 간단히 살펴보자.
<a href="https://developers.naver.com">https://developers.naver.com</a> 참조</p>

<blockquote>
  <p>이전(2015년 쯤)에는 네이버에서 제공하는 API를 사용하기 위해 ‘API 키’라는 유니크한 텍스트 문자열을 발급받고, 이를 API 호출시 같이 API 게이트웨이 서버로 전송함으로써 인증된 사용자임을 입증했다. 새로운 개발자센터에서는 API 키 방식은 더 이상 사용하지 않고 애플리케이션마다 일종의 유니크한 아이디와 비밀번호(클라이언트 아이디, 시크릿)값을 이용해서 인증하고 있다.</p>
</blockquote>

<p>​</p>

<h4 id="api--url--">1. API 호출 URL과 요청 변수</h4>

<ul>
  <li>https://openapi.naver.com/버전/서비스구분/API 구분 형태</li>
  <li>예시) 기계번역 API : https://openapi.naver.com/v1/language/translate</li>
  <li>요청변수란, 오픈 API를 호출할 때 함께 서버로 전송해야 하는 값이다.</li>
  <li>
    <p>요청변수에 한글이나 특수문자가 요청 변수값에 포함되어 있을 경우, 서버 전송 시 값이 깨지기 때문에 인코딩/디코딩 과정이 필요하다.</p>

    <p>​</p>
  </li>
</ul>

<h4 id="http-status-code">2. 에러 코드 정의 - HTTP status code</h4>

<ul>
  <li>400 (요청변수) : 필수 요청 변수가 빠졌거나 요청변수 이름이 잘못되었을 경우나 요청 변수 값을 URL 인코딩하지 않고 전송하였을 경우</li>
  <li>401 (인증실패) : 애플리케이션 클라이언트 아이디와 시크릿 값이 없거나 잘못되었을 경우</li>
  <li>401 (인증실패) : 클라이언트 아이디와 시크릿 값을 HTTP 헤더에 정확히 설정하지 않고 호출했을 경우</li>
  <li>401 (인증실패) : API 권한 설정이 안되어 있을 경우</li>
  <li>401 (인증오류) : 로그인 오픈 API를 호출할 때 접근 토큰(access_token) 값이 빠졌거나 잘못된 값 (기간 만료)을 설정하였을 경우</li>
  <li>403 (호출금지) : https가 아닌 http로 호출하였을 경우</li>
  <li>403 (호출금지) : 약관 동의를 하지 않고 호출할 경우 또는 권한이 없거나 비공개인 경우</li>
  <li>404 (API없음) : API 요청 URL이 잘못되었을 경우</li>
  <li>405 (메서드오류) : HTTP 메서드를 잘못하여 호출하였을 경우 (POST인데 GET으로 호출)</li>
  <li>429 (한도초과) : 오픈 API를 호출할 때 일 허용량을 초과하였을 경우</li>
  <li>
    <p>500 (서버오류) : API 호출은 정상적으로 했지만, API 서버 유지보수나 시스템 오류로 인한 에러가 발생하였을 경우</p>

    <p>​</p>
  </li>
</ul>

<h3 id="kakao-rest-api--">Kakao REST API (카카오톡, 카카오페이)</h3>

<p>​</p>

<h5 id="section-4">1. 먼저, 카카오 로그인 후에 사용자 토큰을 받아온다.</h5>

<h5 id="get-">2. 사용자 토큰을 헤더에 담아 GET으로 요청한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span> <span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">api</span><span class="o">/</span><span class="n">talk</span><span class="o">/</span><span class="n">profile</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="n">Host</span><span class="p">:</span> <span class="n">kapi</span><span class="o">.</span><span class="n">kakao</span><span class="o">.</span><span class="n">com</span>
<span class="n">Authorization</span><span class="p">:</span> <span class="n">Bearer</span> <span class="p">{</span><span class="n">access_token</span><span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="json-----">3. 응답은 JSON 형태로 다음과 같은 정보를 포함한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
 <span class="s">"nickName"</span><span class="p">:</span><span class="s">"홍길동"</span><span class="p">,</span>
 <span class="s">"profileImageURL"</span><span class="p">:</span><span class="s">"http://xxx.kakao.co.kr/.../aaa.jpg"</span><span class="p">,</span>
 <span class="s">"thumbnailURL"</span><span class="p">:</span><span class="s">"http://xxx.kakao.co.kr/.../bbb.jpg"</span><span class="p">,</span>
 <span class="s">"countryISO"</span><span class="p">:</span><span class="s">"KR"</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="response-code-example">Response Code Example</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
  <span class="s">"meta"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">"code"</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
    <span class="s">"response_time"</span><span class="p">:</span> <span class="p">{</span>
      <span class="s">"time"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s">"measure"</span><span class="p">:</span> <span class="s">"seconds"</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="s">"notifications"</span><span class="p">:</span> <span class="p">{},</span>
  <span class="s">"response"</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="error-code-example">Error Code Example</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
  <span class="s">"meta"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">"code"</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
    <span class="s">"error_detail"</span><span class="p">:</span> <span class="s">"The user has not authorized or the token is invalid."</span><span class="p">,</span>
    <span class="s">"error_type"</span><span class="p">:</span> <span class="s">"invalid_auth"</span><span class="p">,</span>
    <span class="s">"developer_friendly"</span><span class="p">:</span> <span class="s">"The user has not authorized or the token is invalid."</span><span class="p">,</span>
    <span class="s">"response_time"</span><span class="p">:</span> <span class="p">{</span>
      <span class="s">"time"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s">"measure"</span><span class="p">:</span> <span class="s">"seconds"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h2 id="section-5">참고자료</h2>

<ul>
  <li>API Platform Design : <a href="http://bcho.tistory.com/808">http://bcho.tistory.com/808</a></li>
  <li>Web API Design : <a href="https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf">https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf</a></li>
  <li>카카오 개발자센터 : <a href="https://developers.kakao.com">https://developers.kakao.com</a></li>
  <li>
    <p>네이버 개발자센터 : <a href="https://developers.naver.com">https://developers.naver.com</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
