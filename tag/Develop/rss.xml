<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>swalloow.github.io/</title>
   
   <link>http://swalloow.github.io/</link>
   <description>About Data Science, Data Engineering</description>
   <language>ko-KO</language>
   <managingEditor> Swalloow</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>빅데이터 처리에 Scala가 필요한 이유</title>
	  <link>//scala-for-bigdata</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-17T19:18:00+09:00</pubDate>
	  <guid>//scala-for-bigdata</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>StackOverFlow나 Quora를 보면 <strong>Scala has taken over the Big Data world.</strong> 라는 글을 많이 볼 수 있습니다.
게다가 Spark의 엔진은 Scala로 구현되어 있습니다. 이 포스팅에서는 데이터를 다루는데에 스칼라가 가지는 강점이 무엇인지 알아보고자 합니다.</p>

<p>​   ​</p>

<h2 id="scala--">Scala가 가지는 강점</h2>

<p>​   ​</p>

<h4 id="static-typing-type-inference">Static Typing, Type Inference</h4>

<p>스칼라의 <code class="highlighter-rouge">val</code> 변수는 한번 지정된 값을 바꾸지 않습니다.
이러한 변수를 <code class="highlighter-rouge">Immutable variable</code> 이라고 부릅니다. 예를 들면 아래와 같습니다.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="s">"Hello Scala"</span>
<span class="nc">String</span> <span class="k">=</span> <span class="nc">Hello</span> <span class="nc">Scala</span>

<span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="s">"Reassign to val"</span>
<span class="n">error</span><span class="k">:</span> <span class="kt">reassignment</span> <span class="kt">to</span> <span class="kt">val</span></code></pre></figure>

<p>위의 예제를 보면, msg 변수에 문자열을 할당했지만 어디에도 String 이라는 단어는 없습니다.
스칼라는 알아서 타입을 추론하여 지정해주기 때문입니다.
따라서, <code class="highlighter-rouge">val</code> 변수에 재할당을 시도하면 <code class="highlighter-rouge">reassignment to val</code> 이라는 오류가 발생하게 됩니다.</p>

<p>이처럼 스칼라는 input 타입을 보고 함수나 출력 값의 타입을 추론해주며 이를 통해 코드를 깔끔하게 유지할 수 있습니다.
또한, 다양하고 많은 데이터가 사용되는 경우 정적변수가 문제를 단순화 해주는 효과가 있습니다.</p>

<p>​   ​</p>

<h4 id="scalable-language">Scalable Language</h4>

<p>기존의 Hadoop 기반의 데이터 인프라는 자바 언어를 통해 MapReduce 연산 그리고 알고리즘을 구현해야했습니다.
하지만 자바는 코드가 너무 길어 생산성 그리고 가독성이 매우 떨어집니다.</p>

<p>스칼라는 모든 것들이 일관성있게 그리고 간결하게 구현되도록 설계되었습니다.
이를 통해 얻을 수 있는 장점은 <strong>“적은 양의 코드로 방대한 규모의 시스템을 작성할 수 있다”</strong> 는 것입니다.</p>

<p>연산자를 예로 들어보겠습니다.
자바에서는 ‘==’ 와 같은 비교연산자를 제공합니다.
하지만 비교연산자는 주소값을 비교하기 때문에
String과 같은 객체를 비교할 때는 <code class="highlighter-rouge">equal()</code> 메서드를 사용해서 비교해야 했습니다.
이 또한 스칼라의 Scalable과 거리가 멉니다.
스칼라에서는 모든 것이 Object이기 때문에 <code class="highlighter-rouge">==</code> 로 모든 비교가 가능합니다.</p>

<p>​   ​</p>

<h4 id="object-oriented-functional-language">Object Oriented, Functional Language</h4>

<figure class="highlight"><pre><code class="language-markdown" data-lang="markdown">y1 = 2x + 5
y2 = 4(y1) = 4(2x + 5)</code></pre></figure>

<p>함수형 언어를 이해하기 전에 어렸을 때 배웠던 함수식을 떠올려보겠습니다.
위의 식에서 x는 input, y는 output이 됩니다.
우리는 어떤 함수에 input을 넣으면 output이 나온다고 이해하고 있습니다.
그리고 아래의 식처럼 함수를 인자로 넣을 수도 있습니다 (합성함수).
함수형 언어도 이와 비슷합니다.</p>

<p>스칼라는 객체지향 프로그래밍과 함수형 프로그래밍을 모두 완벽하게 지원하는 언어입니다.
스칼라에서는 모든 것이 객체이며 함수가 <code class="highlighter-rouge">first object</code> 입니다.
함수를 마치 하나의 값으로 취급하며 이를 변수 또는 파라미터로 넘길 수 있습니다.</p>

<p>모든 것을 함수로 해결하면 의도하지 않은 동작(Side Effect)이 발생할 일이 없고,
한번 검증된 함수는 신뢰할 수 있기 때문에 버그가 줄어드는 효과가 있습니다.
또한, Immutable 변수는 문제를 단순화시켜주기 때문에 데이터 공유, 병렬처리에 강합니다.</p>

<p>​   ​</p>

<h2 id="java-scala-">Java와 Scala를 비교해보자</h2>

<p>Scala는 Interactive한 Shell을 제공합니다.
이렇게 바로 확인할 수 있는 Shell을 통해 데이터의 탐색적 분석이 가능합니다.
IntelliJ IDEA에서도 <code class="highlighter-rouge">Worksheet</code>이라는 기능을 통해 사용할 수 있습니다.
스칼라 개발환경은 <strong>Scala 2.12.1</strong> 이며, IDE는 <strong>IntelliJ IDEA</strong> 를 사용하였습니다.</p>

<p><img src="/assets/images/intellij.png" alt="IntelliJ" /></p>

<p>간단한 WordCount 예제를 통해 코드를 비교해보곘습니다.</p>

<h4 id="java-hadoop-word-count">JAVA Hadoop Word Count</h4>
<script src="https://gist.github.com/Swalloow/25a96ff50fdb60a9859972fa0e4bb92b.js"></script>

<p>​   ​</p>

<h4 id="scala-spark-word-count">Scala Spark Word Count</h4>
<script src="https://gist.github.com/Swalloow/ddc125f58b2b2ca4815444557d769bdb.js"></script>

<p>​   ​</p>

<h2 id="section">정리하자면,</h2>

<ul>
  <li>파이썬과 같이 아주 간결한 문법</li>
  <li>객체지향과 함수형 프로그래밍 모두 가능</li>
  <li>자바와 호환되며 JVM 위에서 실행되기 때문에 좋은 성능</li>
  <li>정적 타입을 지향</li>
  <li>REPL Shell을 활용하여 Scripting</li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>파이썬 웹 어플리케이션 보안 점검 가이드</title>
	  <link>//flask-security</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-08T19:18:00+09:00</pubDate>
	  <guid>//flask-security</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>이 포스팅은 Jacob Kaplan-Moss가 2013년 호주 pycon에서 발표한 자료를 바탕으로 하며, OYT님이 최신화하여 정리해주신 자료를 참고하였습니다.</p>

<p>​   ​</p>

<h2 id="owasp-top-10">OWASP Top 10</h2>

<p>먼저, OWASP(The Open Web Application Security Project)는 오픈소스 웹 애플리케이션 보안 프로젝트로, 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하며,
웹 애플리케이션의 취약점 중에서 빈도가 많이 발생하고, 보안상 영향을 크게 줄 수 있는 것들의 10대 취약점들을 발표합니다.
보통 3년을 주기로 Top 10 리스트를 발표하는데 2017년에도 발표할 예정이라고 합니다.
Top 10 항목들은 다음과 같습니다.</p>

<ol>
  <li>injection</li>
  <li>Broken auth and session managment</li>
  <li>XSS(cross site scripting)</li>
  <li>Insecure direct object reference(bad url)</li>
  <li>Security misconfiguration(read official secret guideline)</li>
  <li>Sensitive data exposure</li>
  <li>Missing function-level access control(decorator)</li>
  <li>CSRF(Cross site request forgery)</li>
  <li>Components with known vulnerabilities(version check!)</li>
  <li>Unvalidated redirects
​</li>
</ol>

<p>이제 파이썬 웹 어플리케이션에서 이를 어떻게 대응할 수 있는지 알아보겠습니다.</p>

<p>​   ​</p>

<h3 id="sql-injection">1. SQL injection</h3>

<p>SQL 인젝션이란, 사용자가 입력한 값이 개발자가 의도치 않은 db query 결과를 초래하는 것, 또는 그것을 이용한 공격을 말합니다.
예를 들면, 아래와 같이 user_id를 string format 쿼리로 넣으면 이러한 공격에 취약할 수 있습니다.</p>

<script src="https://gist.github.com/Swalloow/9b0b074fa0939ee9a339a9da39d066ea.js"></script>

<ul>
  <li>단순 string formatted된 query가 있는지 확인</li>
  <li>raw query 사용 시 bind parameter를 사용했는지 확인</li>
</ul>

<p>​   ​</p>

<h3 id="session-management">2. Session Management</h3>

<p>세션 데이터는 항상 안전하지 않다고 생각해야 합니다. db에 저장되더라도 안전하지 않은건 마찬가지입니다.
특히 예기치 않은 공격에 대비하기 위해 <strong>서버 측에서 세션을 관리</strong> 하는 것이 필요합니다.</p>

<p>Flask에서는 <code class="highlighter-rouge">Flask-Session</code>이라는 확장 패키지를 통해 이를 쉽게 구현할 수 있습니다.
특히 <code class="highlighter-rouge">PERMANENT_SESSION_LIFETIME</code> 이라는 변수를 통해 일정 시간이 지나면 세션을 자동 파기할 수 있습니다.</p>

<ul>
  <li>코드 상에서 공격자가 직접 열람, 추가, 변경 할 수 없는 서버 단 세션 변수를 사용</li>
  <li>일정 시간이 지나면 세션을 자동 파기</li>
  <li>중복 로그인 방지</li>
</ul>

<p>​   ​</p>

<h3 id="xss-cross-site-scripting">3. XSS (Cross-site-scripting)</h3>

<p>XSS란, 웹페이지에 관리자가 의도하지 않는 스크립트(주로 javascript)를 사용자가 넣을 수 있는 상황을 말합니다.
예를 들면 비정상적인 페이지가 보이게하여 타 사용자의 사용을 방해하거나 쿠키 및 기타 개인정보를 특정 사이트로 전송하는 등의 문제가 이에 해당합니다.</p>

<script src="https://gist.github.com/Swalloow/6ddf641ae4cef63ac479c0865aecf23c.js"></script>

<ul>
  <li>유저 입력을 받는 html코드는 항상 escape 할 것</li>
  <li>아무리 똑똑해도 escape 기능을 끄지 말 것</li>
</ul>

<p>​   ​</p>

<h3 id="insecure-direct-object-references">4. Insecure Direct Object References</h3>

<p>일명 직접 객체 참조, 또는 Bad url은 개발자가 파일, 디렉토리, DB 키와 같은 내부 구현 객체를 참조하는 것을 노출시킬 때 발생합니다.
아래의 코드를 통해 예를 들어보겠습니다.</p>

<script src="https://gist.github.com/Swalloow/507ef580b2c1acf26c341fc44dfd0d3d.js"></script>

<ul>
  <li>user_id 등 db와 직접 관계된 값을 GET parameter로 사용하고 있는지 확인</li>
  <li>웹 방화벽에서 상위 혹은 하위 디렉토리로 이동하는 특수문자를 필터링할 것</li>
  <li>파일을 다운로드하는 소스코드에서는 직접적으로 파일의 경로 및 파일명을 파라미터로 받는 것을 피할 것</li>
</ul>

<p>​   ​</p>

<h3 id="security-misconfiguration">5. Security Misconfiguration</h3>

<p>기본으로 제공되는 값은 종종 안전하지 않기 때문에 보안 설정은 정의, 구현 및 유지되어야 합니다.
대표적으로 <strong>코드 난독화</strong> 가 이에 해당합니다.</p>

<p>파이썬에서는 <code class="highlighter-rouge">Base64</code> 패키지를 통해 Encoding/Decoding 하는 방법이 있습니다.
더 나아가 <code class="highlighter-rouge">pycrypto</code> 패키지를 사용하면 Crypto 모듈을 통해 AES 알고리즘으로 암호화할 수 있습니다.</p>

<ul>
  <li><a href="http://flask.pocoo.org/docs/security/">http://flask.pocoo.org/docs/security/</a> 를 정독해볼 것</li>
  <li>debug 모드를 off 하였는지 확인</li>
</ul>

<p>​   ​</p>

<h3 id="sensitive-data-exposure">6. Sensitive data exposure</h3>

<p>많은 웹 애플리케이션들이 신용카드, 개인 식별 정보 및 인증 정보와 같은 중요한 데이터를 제대로 보호하지 않습니다.
공격자는 신용카드 사기, 신분 도용 또는 다른 범죄를 수행하는 등 약하게 보호된 데이터를 훔치거나 변경할 수 있습니다.
따라서, 중요 데이터가 저장 또는 전송 중이거나 브라우저와 교환하는 경우 특별히 주의하여야 하며, 암호화해야 합니다.</p>

<p>REST API에서는 JSON으로 데이터를 통해 통신하기 때문에 <strong>JWE (JSON Web Encryption)</strong> 를 통해 JSON을 암호화해주는 방법이 있습니다.
파이썬의 <code class="highlighter-rouge">python-jose</code> 또는 <code class="highlighter-rouge">PyJWE</code>를 참고하시면 쉽게 구현할 수 있습니다.</p>

<ul>
  <li><code class="highlighter-rouge">JOSE(Javascript Object Signing and Encryption)</code> 규격을 통해 데이터 암호화</li>
  <li>모든 암호를 bcrypt or PBKDF2로 해시 암호화 하였는지 확인</li>
  <li>password 생성 rule을 정하였는지 확인</li>
</ul>

<p>​   ​
​</p>

<h3 id="missing-function-level-access-control">7. Missing function-level access control</h3>

<p>요청에 대해 적절히 확인하지 않을 경우 공격자는 적절한 권한 없이 기능에 접근하기 위한 요청을 위조할 수 있게 됩니다.
따라서, 관리자 페이지 등에 대하여 <strong>유저 권한을 클라이언트가 아닌 서버에서 판단</strong> 해야 하며
역할에 기반한 별도의 인증절차를 요구하도록 만들어야 하고 권한이 없는 유저들은 접근 불가하게 코딩해야 합니다.</p>

<script src="https://gist.github.com/Swalloow/3b727fdcf84c640077de8f414ad785dc.js"></script>

<ul>
  <li>로그인, 토큰 등 접근 관련 flow에서 hard-coding하지 않고 <code class="highlighter-rouge">decorator</code>등을 사용했는지 확인</li>
  <li>OAuth와 같이 Token 기반의 인증시스템을 통해 접근 권한을 부여</li>
</ul>

<p>​   ​</p>

<h3 id="csrfcross-site-request-forgery">8. CSRF(Cross site request forgery)</h3>

<p>CSRF는 로그인 된 사용자의 웹 애플리케이션에 세션 쿠키와 기타 다른 인증정보를 자동으로 포함하여 위조된 HTTP 요청을 강제로 보내도록 하는 것입니다.
공격자는 주로 상태(DB, 세션 등)를 변경하는 공격을 합니다. XSS를 방지하면 어느정도 커버되기도 합니다.</p>

<script src="https://gist.github.com/Swalloow/983d1b2509a47c8267a69e1c37434244.js"></script>

<ul>
  <li>GET 요청으로 상태를 바꾸는 것이 없는지 확인</li>
  <li>POST에 CSRF Token을 달아놓았는지 확인 (공격자가 주입해도 서버에서 거절)</li>
</ul>

<p>​   ​</p>

<h3 id="components-with-known-vulnerabilities">9. Components with known vulnerabilities</h3>

<p>컴포넌트, 라이브러리, 프레임워크 및 다른 소프트웨어 모듈은 대부분 항상 전체 권한으로 실행되어
취약한 컴포넌트를 악용하여 공격하는 경우 심각한 데이터 손실이 발생하거나 서버가 장악될 수 있습니다.</p>

<ul>
  <li>outdated 된 라이브러리가 있는지, 지속적인 업데이트</li>
  <li>사용되지 않는 기능들을 최대한 비활성화 할 것</li>
</ul>

<p>​   ​</p>

<h3 id="unvalidated-redirects">10. Unvalidated redirects</h3>

<p>웹에서 종종 사용자들을 다른 페이지로 리다이렉트 하거나 포워드하기 위해 신뢰할 수 없는 데이터를 사용하는 경우가 많습니다.
적절한 검증 절차가 없으면 공격자는 피해자를 피싱 또는 악성코드 사이트로 리다이렉트 될 수 있기 때문에 주의해야 합니다.</p>

<ul>
  <li>CORS(cross origin resource sharing)시 host whitelist를 관리하고 있는지</li>
  <li>flask-redirect는 언제나 안전하지 않음을 인지하고 사용하고 있는지</li>
</ul>

<p>​   ​</p>

<h3 id="section">정리 및 관련 링크</h3>

<p>저도 그렇고 학생 때는 대부분 보안을 고려하지 않은 웹 어플리케이션을 개발하는 경우가 많은데,
이 자료가 많은 도움이 되었으면 좋겠습니다!</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=sra9x44lXgU">Pycon youtube 자료</a></li>
  <li><a href="https://www.owasp.org/images/5/57/OWASP_Proactive_Controls_2.pdf">OWASP Top 10 Proactive Controls 2016</a></li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>JWT를 구현하면서 마주치게 되는 고민들</title>
	  <link>//implement-jwt</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-03T19:18:00+09:00</pubDate>
	  <guid>//implement-jwt</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>최근 모바일, 웹 등 다양한 환경에서 서버와 통신하면서 많은 사람들이 JWT 토큰 인증 방식을 추천합니다.
이 포스팅에서는 JWT를 이해하고 구현하면서 마주치게 되는 고민들에 대해 정리해보려 합니다.</p>

<p>​   ​</p>

<h2 id="json-web-token">JSON Web Token</h2>

<p><img src="https://cdn.auth0.com/blog/legacy-app-auth/legacy-app-auth-5.png" alt="JWT-Token" /></p>

<p>JWT에 대한 소개는 생략하고 Token이 어떻게 구성되어 있는지 간략하게 알아보겠습니다.
JSON Web Token은 세 파트로 나뉘어지며, 각 파트는 점(.)에 의해 구분됩니다.
이를 테면 <code class="highlighter-rouge">xxxxx.yyyyy.zzzzz</code> 이런식입니다.</p>

<ul>
  <li>Header는 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있습니다.</li>
  <li>Payload는 claim 정보를 포함하고 있습니다. userId, expire, scope 등이 여기에 해당합니다.</li>
  <li>마지막으로 Signature는 secret key를 포함하여 암호화되어 있습니다.</li>
</ul>

<p>​   ​</p>

<h2 id="jwt-process">JWT Process</h2>

<p><img src="https://cdn.auth0.com/content/jwt/jwt-diagram.png" alt="JWT-Diagram" /></p>

<p>일반적으로 JWT 토큰 기반의 인증 시스템은 위와 같은 프로세스로 이루어집니다.
처음 사용자를 등록할 때 Access token과 Refresh token이 모두 발급되어야 합니다.</p>

<ol>
  <li>
    <p>먼저 사용자가 id와 password를 입력하여 로그인을 시도합니다.</p>
  </li>
  <li>
    <p>서버는 요청을 확인하고 secret key를 통해 Access token을 발급합니다.</p>
  </li>
  <li>
    <p>이후 JWT가 요구되는 API를 요청할 때는
클라이언트가 Authorization header에 Access token을 담아서 보냅니다.</p>
  </li>
  <li>
    <p>서버는 JWT Signature를 체크하고 Payload로부터 user 정보를 확인해 데이터를 리턴합니다.</p>
  </li>
</ol>

<p>​   ​</p>

<h2 id="jwt--oauth----">JWT와 기존의 OAuth는 서로 어떤 관계가 있을까?</h2>

<p>토큰 기반의 인증 시스템을 처음 접한 사람이라면 저 두 가지 개념이 헷갈릴 수 있습니다.
먼저, 정답부터 말하자면 <u>JWT는 토큰 유형이고 OAuth는 토큰을 발급하고 인증하는 방법을 설명하는 일종의 프레임워크입니다.</u>
기존의 /outh/token endpoint에 의해 발급되는 모든 토큰은 일종의 OAuth 프레임워크에 의해 관리된다고 볼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
	</span><span class="nt">"token_type"</span><span class="p">:</span><span class="s2">"bearer"</span><span class="p">,</span><span class="w">
	</span><span class="nt">"access_token"</span><span class="p">:</span><span class="s2">"eyJ0eXAiOiJKV1QiLCJh"</span><span class="p">,</span><span class="w">
	</span><span class="nt">"expires_in"</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span><span class="w">
	</span><span class="nt">"refresh_token"</span><span class="p">:</span><span class="s2">"fdb8fdbecf1d03ce5e6125c067733c0d51de209c"</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>위의 토큰이 기존 OAuth에서 주로 사용하는 bearer 기반의 토큰 방식입니다.
다만 JWT는 토큰 자체에 유저 정보를 담아서 HTTP 헤더로 전달하기 때문에
유저 세션을 유지할 필요가 없고 가볍게 데이터를 주고받을 수 있다는 장점이 있습니다.</p>

<p>​   ​</p>

<h2 id="access-token-refresh-token---">Access Token과 Refresh Token을 어디에 저장해야 할까?</h2>

<p>앞서 말한것처럼 기본적으로 두 가지 토큰을 사용합니다.
API 요청을 허가하는데 Access Token을 사용하고, 액세스 토큰이 만료된 후 새로운 액세스 토큰을 얻기 위해 Refresh Token을 사용합니다.</p>

<p><img src="/assets/images/access token.png" alt="access_token" /></p>

<p>Access Token은 리소스에 직접 접근할 수 있도록 해주는 정보만을 가지고 있습니다. 즉, 클라이언트는 Access Token이 있어야 서버 자원에 접근할 수 있습니다. Access Token은 짧은 수명을 가지며, 만료기간을 갖습니다. 주로 <strong>세션</strong> 에 담아서 관리합니다.</p>

<p><img src="/assets/images/refresh token.png" alt="refresh_token" /></p>

<p>Refresh Token은 새로운 Access Token을 발급받기 위한 정보를 갖습니다. 즉, 클라이언트가 Access Token이 없거나 만료되었다면 Refresh Token을 통해 Auth Server에 요청해서 발급받을 수 있습니다. Refresh Token 또한 만료기간이 있지만 깁니다. Refresh Token은 중요하기 때문에 외부에 노출되지 않도록 엄격하게 관리해야 하므로 주로 <strong>데이터베이스</strong> 에 저장합니다.</p>

<p>토큰이 안전하게 관리되는지 여부는 어떻게 구현하느냐에 달려있습니다. 보통은 Access Token에 대해 직접적으로 인증(direct authorization) 체크합니다. 무슨 말이냐 하면, Access Token이 서버 자원에 접근하려고 하면 서버가 토큰에 있는 정보를 읽어 스스로 인증여부를 결정합니다. 반면에, Refresh Token은 Auth Server에 대한 체크가 필요합니다. 이때 다음과 같은 세 가지 사항을 고려해야 합니다.</p>

<ul>
  <li>빠른 인증 과정을 위해 토큰에 정보를 적게 담아야 합니다.</li>
  <li>노출된 Access Token에 대해서는 빠르게 만료시켜 리소스에 접근할 수 있는 가능성을 줄어야 합니다.</li>
  <li>Sliding sessions에 대한 처리가 필요합니다.</li>
</ul>

<p>​   ​</p>

<h4 id="sliding-sessions">Sliding sessions</h4>

<p>Sliding sessions은 일정 기간 사용하지 않으면 만료되는 세션입니다. 이 세션은 refresh token과 access token을 통해 구현할 수 있습니다. 먼저, 사용자가 작업을 수행하려하면 새 access token이 발급됩니다. 반면, 사용자가 만료된 access token을 사용하려 하면 세션은 비활성화되며 새 access token을 요청합니다. 이 상황에서 refresh token을 통해 새로운 토큰을 발급받을 지는 개발 팀이 결정하기에 따라 다릅니다.</p>

<p>​   ​</p>

<h2 id="section">토큰 재발급 로직에 대한 고민</h2>

<p>JWT를 쓴다면 만료시간을 꼭 명시적으로 두도록 하고 중간마다 토큰을 재발행하도록 권장하는 것이 대부분입니다.
리프레시 관련해서 정확한 내용이 정해져 있는 것은 아니지만 일반적인 API를 보면
최초 발급시 Access Token과 Refresh Token 2개를 발급하고 Access Token으로 API를 사용하다가
만료시간이 지나면 만료시간을 길게 준 Refresh Token을 이용해서 Access Token을 다시 발급합니다.</p>

<p>가장 일반적인 방법은 클라이언트가 토큰의 만료시간을 알 수 있기 때문에, 클라이언트에서 판단해서 만료시간이 넘었으면 토큰 재발급을 요청하는 방법입니다.
좀 더 쉽게 구현하는 방법은 TokenExpiredError가 발생했을 때 재발급을 해주는 것입니다.</p>

<p>만료된 토큰을 통해 접근하려고 하면 다음과 같은 오류가 나타나게 합니다.</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
	</span><span class="nt">"code"</span><span class="p">:</span><span class="mi">401</span><span class="p">,</span><span class="w">
	</span><span class="nt">"error"</span><span class="p">:</span><span class="s2">"invalid_token"</span><span class="p">,</span><span class="w">
	</span><span class="nt">"error_description"</span><span class="p">:</span><span class="s2">"The access token provided has expired."</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>​   ​</p>

<h2 id="section-1">기타, 참고자료</h2>

<p>Flask에는 Flask-JWT라는 패키지가 있지만 Scope나 Refresh Token에 대한 구현이 부족하기 때문에
pyjwt를 통해 직접 구현하는 방법을 추천합니다.</p>

<p>아래는 JWT에 대하여 가장 많이 도움이 되는 페이지입니다.
들어가서 가입하면 <strong>JWT Handbook</strong> 이라는 EBook도 무료로 제공합니다. <a href="https://jwt.io/">https://jwt.io/</a></p>

<ul>
  <li><a href="https://auth0.com/blog/ten-things-you-should-know-about-tokens-and-cookies/">10 things you should know about tokens and cookies</a></li>
  <li><a href="https://auth0.com/learn/refresh-tokens/">Learn refresh tokens</a></li>
  <li><a href="http://stackoverflow.com/questions/30826726/how-to-identify-if-the-oauth-token-has-expired">How to identify if the OAuth token has expired</a></li>
</ul>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>HTTPS와 SSL 인증서, 그리고 SHA1 알고리즘</title>
	  <link>//https-ssl</link>
	  <author>Swalloow</author>
	  <pubDate>2017-03-01T19:18:00+09:00</pubDate>
	  <guid>//https-ssl</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>크롬 업데이트 이후 몇몇 웹 페이지는 브라우저 주소 창에 <code class="highlighter-rouge">안전하지 않음</code>이 나타나고,
아니면 자물쇠 모양에 <code class="highlighter-rouge">안전함</code>이 표시되는 것을 볼 수 있습니다.
오늘은 그 두 가지 방식에 어떤 차이가 있는지, HTTPS와 SSL 인증서에 대해 알아보고
최근 구글과 리누스 토발즈의 언급으로 이슈화 되고 있는 SHA1 암호화 알고리즘에 대해 정리해보려 합니다.</p>

<p>​   ​</p>

<h2 id="http-https">HTTP와 HTTPS</h2>

<p>우선 간단히 웹 통신규약에 대해 설명하자면, <em>HTTP는 Hypertext 인 HTML을 전송하기 위한 통신규약</em> 을 의미합니다.
HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고 받는 메시지를 확인하는 것이 매우 쉽습니다.
심각한 예를 들면, 로그인을 위해서 서버로 비밀번호를 전송하거나 중요한 기밀 문서를 열람하는 과정에서 악의적인 감청이나 데이터의 위변조 등이 일어날 수 있습니다.</p>

<p>이를 보완하기 위해 나온 것이 보안이 강화된 <strong>HTTPS</strong> 입니다.
HTTPS는 보안을 강화하기 위해 통신에서 일반 텍스트를 이용하지 않고 <strong>SSL이나 TLS 프로토콜</strong> 을 통해 세션 데이터를 암호화합니다.
이를 통해 데이터의 보안을 더 강화할 수 있지만 전적으로 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있습니다.</p>

<p>결국 크롬에 <code class="highlighter-rouge">안전하지 않음</code>으로 표기되는 페이지는 보안 인증서가 없는 페이지입니다.
반면에, <code class="highlighter-rouge">안전함</code>으로 표기되는 페이지는 기관으로부터 인증서를 받은 페이지입니다.
실제로 인터넷 익스플로러의 인터넷 옵션을 확인해보면 CA 라는 탭에서 인증서를 확인하실 수 있습니다.</p>

<p>​   ​</p>

<h2 id="ssl--">SSL 통신 과정</h2>

<p>그렇다면 HTTPS에 포함된 SSL 프로토콜이 어떤 과정을 통해 동작하는지 간단히 알아보겠습니다.
다시 설명하자면, <em>SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서</em> 라고 보시면 됩니다.
처음 클라이언트와 서버가 데이터를 주고 받기 위해서는 준비과정이 필요합니다. 이를 <strong>핸드쉐이크(HandShake)</strong> 라고 부릅니다.</p>

<p><img src="/assets/images/ssl-process.jpg" alt="ssl-process" /></p>

<ol>
  <li>
    <p>먼저, 클라이언트가 서버에 접속(Client Hello)한 직후에 서버는 클라이언트에게 인증서 정보를 전달(Server Hello)합니다.</p>
  </li>
  <li>
    <p>클라이언트(브라우저)는 이미 모든 CA 인증기관들에 대한 정보를 가지고 있기 때문에 공개키를 통해
전달받은 인증서를 복호화하고 신뢰할 수 있는 서버인지 확인합니다.</p>
  </li>
  <li>
    <p>안전함이 확인되면 클라이언트는 대칭키 암호화 방식을 통해 비밀키를 생성하고 이를 공개키 방식으로 암호화해서 서버에게 전달합니다.</p>
  </li>
  <li>
    <p>서버는 자신의 비공개 키로 복호화하여 서버와 클라이언트가 세션키를 공유하게 되면, 핸드쉐이크 과정의 종료를 서로에게 알립니다.</p>
  </li>
  <li>
    <p>이제 세션을 통해 서버와 클라이언트가 데이터를 주고 받게 됩니다.
여기서 세션키 값을 이용해서 대칭키 방식으로 암호화하기 때문에 HTTP 보다 안전합니다.</p>
  </li>
  <li>
    <p>데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려줍니다. 그리고 통신에서 사용한 대칭키인 세션키를 폐기합니다.</p>
  </li>
</ol>

<p>​   ​</p>

<h2 id="sha1------">SHA1 암호화 알고리즘은 더 이상 안전하지 않다?</h2>

<p>이 논란은 구글이 2월 중순쯤에 낡은 암호화 알고리즘 SHA1를 깨뜨리면서 시작되었습니다.
구글은 SHA1 알고리즘 해시값의 고유성을 깨뜨릴 수 있는 <strong>‘섀터드(SHAttered)’</strong> 라는 방법을 선보이면서,
SHA1에 의존하는 기술은 믿음직하지 않다는 점을 보여줬습니다.</p>

<p>여기서 섀터드 기법을 소개한 연구자들은 <em>Git이 SHA1에 의존하기 때문에 안전하지 않다</em> 고 말했습니다.
이에 리누스 토발즈는 <em>“깃은 데이터를 해시하기만 하는 게 아니라, 거기에 타입과 길이 필드를 측량한다”</em> 고 말하면서
당장은 하늘이 무너지는게 아니니 상관없다고 답변했습니다.</p>

<p>물론 당장은 아니지만 불안함에 많은 기관들이 SHA1 방식에서 <strong>SHA2 또는 SHA256</strong> 으로 옮겨가고 있습니다.
대표적으로 크롬, 파이어폭스 등의 브라우저들이 SHA1 인증서 퇴출에 노력하고 있고, 인터넷뱅킹이나 비트코인 같은 경우 SHA256 방식을 사용합니다.</p>

<p>리누스 토발즈의 글 : <a href="https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL">https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL</a></p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>Swagger로 API 문서화하기</title>
	  <link>//swagger-api-doc</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-25T19:18:00+09:00</pubDate>
	  <guid>//swagger-api-doc</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>개발에 있어서 API 문서화는 아주 중요하지만 번거로운 일 중에 하나입니다.
특히 pdf 또는 한글 파일로 관리하고 있다면 갱신할때마다 아주 번거롭습니다.</p>

<p>이를 해결하기 위해 자칭 세계에서 가장 유명한 API 프레임워크인 <strong>Swagger</strong> 를 사용해보겠습니다.
<a href="http://swagger.io/">Swagger 공식 홈페이지</a>를 보면 많은 정보가 있습니다.</p>

<p>​   ​</p>

<h3 id="swagger-ui">Swagger UI</h3>

<p>Swagger UI를 사용하면 웹 브라우저를 통해 Swagger에 정의된 REST API를 시각화하고 테스트할 수 있습니다.
내장된 테스트 기능을 사용하면 GUI로 API를 테스트하며 결과를 확인할 수 있습니다.
자세한 정보는 <a href="https://github.com/swagger-api/swagger-ui">GitHub: Swagger UI</a> 를 참고하시면 됩니다.</p>

<p>​   ​</p>

<h3 id="swagger-codegen">Swagger Codegen</h3>
<p>Swagger Codegen을 사용하면 REST API용 Swagger 문서를 통해 다양한 언어로 SDK를 생성할 수 있습니다.
생성된 SDK를 사용하여 API를 완전히 구현하기 전에 생성된 샘플 서버 구현에서 실시간으로 API를 테스트할 수 있습니다.
자세한 정보는 <a href="https://github.com/swagger-api/swagger-codegen">GitHub: Swagger Codegen</a> 를 참조하시면 됩니다.</p>

<p>​   ​</p>

<h3 id="swagger-editor">Swagger Editor</h3>

<p><a href="editor.swagger.io">editor.swagger.io</a> 에서 Swagger Editor, Swagger UI 및 Swagger Codegen을 제공합니다.
최대한 간편한 용도로 사용하시겠다면 yaml 이나 json 파일을 이곳에 import 해서 사용하셔도 됩니다.</p>

<p>이외에도 <a href="http://bigstickcarpet.com/swagger-parser/www/index.html">http://bigstickcarpet.com/swagger-parser/www/index.html</a>
Swagger Validator와 Parser가 있습니다.</p>

<p>​   ​</p>

<h3 id="docker-swagger-ui-">Docker로 Swagger UI를 적용해보자</h3>

<p>앞서 설명하자면 Docker로 실행하는 이유는 “아직 맥북에 npm 환경구축이 안되어서” 입니다.
<code class="highlighter-rouge">npm install</code> 을 통해 빌드하셔도 됩니다.</p>

<h5 id="section">1.</h5>
<p>먼저 로컬에 <a href="https://github.com/swagger-api/swagger-ui">Swagger UI GitHub 저장소</a>를 clone 해줍니다.</p>

<h5 id="section-1">2.</h5>
<p>그 다음 Docker를 실행하고 아래의 명령어를 통해 Dockerfile을 빌드합니다.
localhost:80 에 접속하면 Swagger-UI가 실행된 것을 볼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker build -t swagger-ui-builder .
docker run -p 80:8080 swagger-ui-builder</code></pre></figure>

<h5 id="section-2">3.</h5>
<p>이제 Swagger Editor로 문서를 작성하고 yaml 형식으로 다운로드 받고, 파일을 Swagger/dist/로 이동합니다.
그리고 Swagger/dist/index.html 파일의 url을 swagger.yaml로 수정합니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">search</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/url=</span><span class="se">([^</span><span class="sr">&amp;</span><span class="se">]</span><span class="sr">+</span><span class="se">)</span><span class="sr">/</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">url</span> <span class="o">&amp;&amp;</span> <span class="nx">url</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">url</span> <span class="o">=</span> <span class="nb">decodeURIComponent</span><span class="p">(</span><span class="nx">url</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="nx">url</span> <span class="o">=</span> <span class="s2">"swagger.yaml"</span><span class="p">;</span>
   <span class="p">}</span></code></pre></figure>

<p>이제 웹 서버에 올리기만 하면 API 문서를 쉽게 확인할 수 있습니다!</p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>충돌을 해결하기 위한 git stash 명령어</title>
	  <link>//git-stash</link>
	  <author>Swalloow</author>
	  <pubDate>2017-02-23T19:18:00+09:00</pubDate>
	  <guid>//git-stash</guid>
	  <description><![CDATA[
	     <p>​   ​</p>

<p>git을 사용하다보면 여러 변경내역이 생기게 됩니다.
예를 들면 내 로컬에서 변경된 내역을 아직 commit을 하지 않은 상태로 pull을 하게 되면,
충돌이 발생하게 되어 초보자에게는 난감한 상황이 됩니다.
이런 경우에 git stash 명령어를 사용하시면 편리합니다.</p>

<p>git stash 명령어는 unstaged 상태인 변경사항을 일시적으로 백업하고 워킹디렉토리를 깨끗한 상태로 유지합니다.
즉, 일종의 책갈피 역할을 한다고 보시면 됩니다.</p>

<p>​   ​</p>

<h4 id="git-stash">1. git stash</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash
Saved working directory and index state <span class="se">\</span>
  <span class="s2">"WIP on master: 049d078 added the index file"</span>
HEAD is now at 049d078 added the index file
<span class="o">(</span>To restore them <span class="nb">type</span> <span class="s2">"git stash apply"</span><span class="o">)</span></code></pre></figure>

<p>git stash 명령어를 실행하면 작업 중인 파일을 새로운 Stash에 저장합니다.</p>

<p>​   ​</p>

<h4 id="git-stash-list">2. git stash list</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash list
stash@<span class="o">{</span>0<span class="o">}</span>: WIP on master: 049d078 added the index file
stash@<span class="o">{</span>1<span class="o">}</span>: WIP on master: c264051 Revert <span class="s2">"added file_size"</span>
stash@<span class="o">{</span>2<span class="o">}</span>: WIP on master: 21d80a5 added number to log</code></pre></figure>

<p>git stash list 명령어를 통해 저장된 책갈피들의 리스트를 볼 수 있습니다.</p>

<p>​   ​</p>

<h4 id="git-stash-apply">3. git stash apply</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash apply
<span class="c"># On branch master</span>
<span class="c"># Changes not staged for commit:</span>
<span class="c">#   (use "git add &lt;file&gt;..." to update what will be committed)</span>
<span class="c">#</span>
<span class="c">#      modified:   index.html</span>
<span class="c">#      modified:   lib/simplegit.rb</span>
<span class="c">#</span></code></pre></figure>

<p>git stash apply 명령어를 사용하면 저장된 stash를 적용할 수 있습니다.</p>

<p>​   ​</p>

<h4 id="git-stash-drop">4. git stash drop</h4>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>git stash drop stash@<span class="o">{</span>0<span class="o">}</span>
Dropped stash@<span class="o">{</span>0<span class="o">}</span> <span class="o">(</span>364e91f3f268f0900bc3ee613f9f733e82aaed43<span class="o">)</span></code></pre></figure>

<p>apply 명령어로 stash를 적용한다고 해서 스택에서 사라지는게 아닙니다.
git stash drop 명령어를 통해 스택에서 삭제할 수 있습니다.</p>

<p>​   ​</p>

	  ]]></description>
	</item>

	<item>
	  <title>다양한 소셜 API를 연동하기 전에 고려할 것들 (AWS Cognito)</title>
	  <link>//social-api-cognito</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-28T19:18:00+09:00</pubDate>
	  <guid>//social-api-cognito</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>최근에 대부분의 웹, 모바일 어플리케이션에서 카카오, 네이버 등 다양한 소셜 로그인 기능을 제공하고 있다.
만약 우리가 만들어야 할 어플리케이션이 다양한 소셜 로그인 API와 연동하여 사용자를 관리해야한다면, OAuth 인증, 보안 등 개발할 때 고려해야할 요소가 많을 것이다.</p>

<p>따라서, 이 글을 통해 최근 유행하는 클라우드 기반 웹 어플리케이션 설계 방식을 아주 간단히 보고 적합한 설계 방식을 선택하는데 도움이 되었으면 좋겠다.</p>

<p>OAuth2.0에 대해서는 이전에 쓴 글을 참조하길 바란다. <a href="http://swalloow.github.io/about-oauth2/">http://swalloow.github.io/about-oauth2/</a></p>

<p>​</p>

<h2 id="oauth-20-grant-flow">1. OAuth 2.0 Grant Flow</h2>

<p><img src="assets/images/OAuth2 Grant Flow1.png" alt="OAuth2 Grant Flow1" /></p>

<p>주로 자바스크립트 기반 웹 어플리케이션에서 많이 사용하는 방식이다. (스크립트 보안 유출 고려)
최근에는 모바일에서도 많이 사용한다고 한다.</p>

<p>​</p>

<p><img src="assets/images/OAuth2 Grant Flow2.png" alt="OAuth2 Grant Flow2" /></p>

<p>이 방식은 직접 ID, PW 보내는 방식으로 파트너나 자사 시스템에 사용한다.
기존의 HTTP 방식을 그대로 사용하기 용이하다.</p>

<p>위와 같은 방식을 사용했을 때의 장점은 OAuth 2.0을 몸소 체험할 수 있다는 것이다.
반면에, 단점은 다음과 같다.</p>

<ul>
  <li>사용자 데이터에 대한 보안을 고려해야 한다.</li>
  <li>Facebook, Twitter 모두 각자에게 최적화 되어 있어 확장성을 고려한 인증 인터페이스를 만들기 힘들다.</li>
  <li>Token만 존재하기 때문에 사용자 관리, 사용자를 구분하기가 힘들다.</li>
  <li>모바일과 웹 어플리케이션이 모두 존재한다면, 인증 및 디바이스 간 동기화 처리 문제가 있다.</li>
  <li>
    <p>시스템 충돌과 네트워크 연결 문제 또한 감당해야 한다.</p>

    <p>​</p>
  </li>
</ul>

<h2 id="aws-ec2--cognito-baas">2. AWS EC2 + Cognito (BaaS)</h2>

<p><img src="assets/images/AWS Authentication process.png" alt="AWS Authentication process" /></p>

<p>사용자 로그인, 인증 처리에 대해 AWS Cognito를 사용한 방법이다.
기본적인 EC2 인스턴스에 Cognito만 추가해서 사용하면 된다.</p>

<p>이러한 방법을 적용했을 때의 단점은 일단 클라우드에 요금을 내야 한다는 것이다.
또한, AWS Cognito에서 지원하지 않는 카카오 로그인 같은 경우 복잡한 과정이 필요하다.
반면에 장점은 다음과 같다.</p>

<ul>
  <li>SAML을 통한 보안 문제 해결.</li>
  <li>놀라운 확장성. (SOCIAL IDENTITY를 추가하기만 하면 끝, 모바일 앱까지 확장 가능)</li>
  <li>편리한 사용자 관리. (USER POOL 기능 제공)</li>
  <li>인증 및 디바이스간 동기화 처리. (Cognito Sync가 알아서 해준다)</li>
  <li>시스템 충돌과 네트워크 연결 문제. (Cognito Sync가 알아서 해준다)</li>
  <li>
    <p>위와 같은 문제를 신경 안쓰므로 로직에 집중해서 빠른 개발이 가능하다.</p>

    <p>​</p>
  </li>
</ul>

<h2 id="aws-serverless-architecture-baas--faas">3. AWS Serverless Architecture (BaaS + FaaS)</h2>

<p><img src="assets/images/AWS WebApp Application Architecture.png" alt="AWS WebApp Application Architecture" /></p>

<p>AWS API Gateway와 Lambda를 통한 서버리스 아키텍쳐에 대해서는 아래 링크를 참고하자.
서버리스 아키텍쳐는 서버를 관리할 필요 없이 특정 이벤트에 반응하는 함수를 등록하고, 해당 이벤트가 발생하면 함수가 실행되는 구조이다.
장점은 다음과 같다.</p>

<ul>
  <li>서버에 고성능이 필요할 시에는 비용이 절감된다.</li>
  <li>서비스 지향적인 설계가 가능하다. (마이크로 아키텍쳐)</li>
  <li>자동 스케일링</li>
  <li>코드 생산에 집중할 수 있고, 유연한 배포 및 테스트가 가능하다.</li>
</ul>

<p>반면에 단점은 다음과 같다.</p>

<ul>
  <li>AWS 과금이 많이 나올 수 있다. (쓸데없이 많이 고려한 설계일수도)</li>
  <li>
    <p>API Gateway, Lambda에 대한 러닝 커브가 상당하다. (많은 스터디 필요)</p>

    <p>​</p>
  </li>
</ul>

<h2 id="section">결론</h2>

<p>최근에 유행하는 서버리스 아키텍쳐나 마이크로 아키텍쳐를 무조건 도입해야하는 것은 절대 아니다.
각자 프로젝트의 상황에 맞는 방법을 선택하는게 답인듯하다.</p>

<p>​​</p>

<h2 id="section-1">참고하면 좋은 문서들</h2>

<ul>
  <li><a href="https://medium.com/@parkgeunhack/%EC%95%8C%EB%A0%89%EC%8A%A4%EC%9D%98-%EC%9D%B4%EC%95%BC%EA%B8%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%84%9C%EB%B2%84-%EA%B0%9C%EB%B0%9C%EC%9D%BC%EC%A7%80-c3aa12baaa75#.kkskaeaqa">박근핵닷컴 서버 개발일지</a></li>
  <li><a href="https://aws.amazon.com/ko/cognito/?nc2=h_m1">AWS Cognito</a></li>
  <li><a href="https://aws.amazon.com/ko/blogs/korea/category/amazon-cognito/">AWS Cognito Blog</a></li>
  <li><a href="http://blog.aliencube.org/ko/2016/06/23/serverless-architectures/">Serverless-Architecture</a></li>
  <li><a href="http://www.popit.kr/why-microservice/">Popit - 마이크로서비스 아키텍쳐의 장단점</a></li>
  <li>
    <p><a href="http://bcho.tistory.com/942">조대협 블로그 - OAuth 2.0 Architecture</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Open API를 설계할 때 알아야 하는 것들</title>
	  <link>//open-api-guide</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-05T19:18:00+09:00</pubDate>
	  <guid>//open-api-guide</guid>
	  <description><![CDATA[
	     <p>​</p>

<p>오픈 API를 사용하다보면 공통의 패턴을 발견할 수 있을 것이다.
이처럼, API를 설계할 때도 개발자들이 쉽게 사용할 수 있도록 만든 규칙이라는게 존재한다.
오늘은 RESTful한 Open API를 설계하기 위해 알아야 하는 것들에 대해 정리해보았다.</p>

<p>​</p>

<h2 id="open-api-">Open API 디자인</h2>

<p>​</p>

<h3 id="api-">API 란?</h3>

<blockquote>
  <p>운영체제, 시스템, 애플리케이션, 라이브러리 등을 개발자들이 프로그래밍 작업을 통해 응용 프로그램을 작성할 수 있는 다양한 인터페이스들을 총칭한다. (예: Window API, Java API, HTML5 API, Android API…) - 네이버 개발자센터 인용</p>
</blockquote>

<p>​</p>

<h3 id="api--1">오픈 API 란?</h3>

<blockquote>
  <p>API 중에서 플랫폼의 기능 또는 컨텐츠를 외부에서 쓸 수 있도록 웹 프로토콜(HTTP)로 호출할 수 있도록 개방(open)한 API를 의미한다. 네이버 개발자센터에서 제공하고 있는 지도, 검색을 비롯 기계번역, 캡차, 단축 URL 등 대부분 API 들은 HTTP로 호출할 수 있는 오픈 API에 해당한다. - 네이버 개발자센터 인용</p>
</blockquote>

<p>​</p>

<p>이제 기업 또는 사용자에게 제공할 RESTful Open API를 어떻게 설계할지 고민해보자.
기업에게 전문적으로 API를 공급하는 Apigee 사의 <strong>Web API Design</strong> 을 레퍼런스로 삼았다.</p>

<p>​</p>

<h2 id="best-web-api-design-rules">Best Web API Design Rules</h2>

<p>​</p>

<h5 id="url------2--url-">1. 기본 URL에는 동사가 아닌 명사를 사용, 리소스마다 2개의 기본 URL을 유지하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">/</span><span class="n">dogs</span> <span class="p">(</span><span class="n">Collection</span><span class="p">),</span> <span class="o">/</span><span class="n">dogs</span><span class="o">/</span><span class="mi">1234</span> <span class="p">(</span><span class="n">Element</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="http-post-get-put-delete-">2. 올바른 HTTP 메서드(POST, GET, PUT, DELETE)를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">POST</span><span class="p">(</span><span class="n">create</span><span class="p">),</span> <span class="n">GET</span><span class="p">(</span><span class="n">read</span><span class="p">),</span> <span class="n">PUT</span><span class="p">(</span><span class="n">update</span><span class="p">),</span> <span class="n">DELETE</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span></code></pre></figure>

<p>​</p>

<h5 id="section">3. 복수형 명사와 구체적인 이름을 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">/</span><span class="n">animals</span><span class="p">,</span> <span class="o">/</span><span class="n">dogs</span></code></pre></figure>

<p>​</p>

<h5 id="url----">4. 자원 간의 관계를 간단히 하여 URL 계층이 깊어지는 것을 피하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span>	<span class="o">/</span><span class="n">owners</span><span class="o">/</span><span class="mi">5678</span><span class="o">/</span><span class="n">dogs</span><span class="err">?</span><span class="n">color</span><span class="o">=</span><span class="n">red</span></code></pre></figure>

<p>​</p>

<h5 id="section-1">5. 오류 처리를 명확하게 하고 에러 스택은 절대 비공개 해야 한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="mi">200</span> <span class="o">-</span> <span class="n">OK</span>
<span class="mi">400</span> <span class="o">-</span> <span class="n">Bad</span> <span class="n">Request</span>
<span class="mi">500</span> <span class="o">-</span> <span class="n">Internal</span> <span class="n">Server</span> <span class="n">Error</span>
<span class="mi">201</span> <span class="o">-</span> <span class="n">Created</span>
<span class="mi">304</span> <span class="o">-</span> <span class="n">Not</span> <span class="n">Modified</span>
<span class="mi">404</span> <span class="o">-</span> <span class="n">Not</span> <span class="n">Found</span>
<span class="mi">401</span> <span class="o">-</span> <span class="n">Unauthorized</span>
<span class="mi">403</span> <span class="o">-</span> <span class="n">Forbidden</span></code></pre></figure>

<p>​</p>

<h5 id="v------">6. 접두사 “v”로 버전을 지정하고 지속적인 버전 관리를 하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span>	<span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">dogs</span></code></pre></figure>

<p>​</p>

<h5 id="section-2">7. 데이터베이스에 없는 자원에 대한 응답일 경우 동사를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">ex</span><span class="p">)</span> <span class="n">Caculate</span><span class="p">,</span> <span class="n">Translate</span><span class="p">,</span> <span class="n">Convert</span> <span class="o">...</span></code></pre></figure>

<p>​</p>

<h5 id="javascript-----">8. 속성의 네이밍은 Javascript의 관습을 따르고 카멜 케이스를 사용하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="s">"createdAt"</span><span class="p">:</span> <span class="mi">123415125</span></code></pre></figure>

<p>​</p>

<h5 id="api---">9. 하위 도메인의 독립적인 API 요청 처리는 통일하자.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">company</span><span class="o">.</span><span class="n">com</span>
<span class="n">api</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">com</span>	<span class="p">(</span><span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">,</span> <span class="n">redirect</span><span class="p">)</span>
<span class="n">developers</span><span class="o">.</span><span class="n">company</span><span class="o">.</span><span class="n">com</span></code></pre></figure>

<p>​</p>

<h5 id="section-3">10. 기타</h5>

<ul>
  <li>권한 관리(OAuth)는 2.0을 사용하자.</li>
  <li>필요한 경우, SDK로 API를 보완하자.</li>
  <li>
    <p>API Facade Pattern을 API 설계에 고려해라.</p>

    <p>​</p>
  </li>
</ul>

<h3 id="naver-open-api">NAVER Open API</h3>

<p>실제 네이버와 카카오의 오픈 API는 어떻게 디자인되어 있는지 간단히 살펴보자.
<a href="https://developers.naver.com">https://developers.naver.com</a> 참조</p>

<blockquote>
  <p>이전(2015년 쯤)에는 네이버에서 제공하는 API를 사용하기 위해 ‘API 키’라는 유니크한 텍스트 문자열을 발급받고, 이를 API 호출시 같이 API 게이트웨이 서버로 전송함으로써 인증된 사용자임을 입증했다. 새로운 개발자센터에서는 API 키 방식은 더 이상 사용하지 않고 애플리케이션마다 일종의 유니크한 아이디와 비밀번호(클라이언트 아이디, 시크릿)값을 이용해서 인증하고 있다.</p>
</blockquote>

<p>​</p>

<h4 id="api--url--">1. API 호출 URL과 요청 변수</h4>

<ul>
  <li>https://openapi.naver.com/버전/서비스구분/API 구분 형태</li>
  <li>예시) 기계번역 API : https://openapi.naver.com/v1/language/translate</li>
  <li>요청변수란, 오픈 API를 호출할 때 함께 서버로 전송해야 하는 값이다.</li>
  <li>
    <p>요청변수에 한글이나 특수문자가 요청 변수값에 포함되어 있을 경우, 서버 전송 시 값이 깨지기 때문에 인코딩/디코딩 과정이 필요하다.</p>

    <p>​</p>
  </li>
</ul>

<h4 id="http-status-code">2. 에러 코드 정의 - HTTP status code</h4>

<ul>
  <li>400 (요청변수) : 필수 요청 변수가 빠졌거나 요청변수 이름이 잘못되었을 경우나 요청 변수 값을 URL 인코딩하지 않고 전송하였을 경우</li>
  <li>401 (인증실패) : 애플리케이션 클라이언트 아이디와 시크릿 값이 없거나 잘못되었을 경우</li>
  <li>401 (인증실패) : 클라이언트 아이디와 시크릿 값을 HTTP 헤더에 정확히 설정하지 않고 호출했을 경우</li>
  <li>401 (인증실패) : API 권한 설정이 안되어 있을 경우</li>
  <li>401 (인증오류) : 로그인 오픈 API를 호출할 때 접근 토큰(access_token) 값이 빠졌거나 잘못된 값 (기간 만료)을 설정하였을 경우</li>
  <li>403 (호출금지) : https가 아닌 http로 호출하였을 경우</li>
  <li>403 (호출금지) : 약관 동의를 하지 않고 호출할 경우 또는 권한이 없거나 비공개인 경우</li>
  <li>404 (API없음) : API 요청 URL이 잘못되었을 경우</li>
  <li>405 (메서드오류) : HTTP 메서드를 잘못하여 호출하였을 경우 (POST인데 GET으로 호출)</li>
  <li>429 (한도초과) : 오픈 API를 호출할 때 일 허용량을 초과하였을 경우</li>
  <li>
    <p>500 (서버오류) : API 호출은 정상적으로 했지만, API 서버 유지보수나 시스템 오류로 인한 에러가 발생하였을 경우</p>

    <p>​</p>
  </li>
</ul>

<h3 id="kakao-rest-api--">Kakao REST API (카카오톡, 카카오페이)</h3>

<p>​</p>

<h5 id="section-4">1. 먼저, 카카오 로그인 후에 사용자 토큰을 받아온다.</h5>

<h5 id="get-">2. 사용자 토큰을 헤더에 담아 GET으로 요청한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">GET</span> <span class="o">/</span><span class="n">v1</span><span class="o">/</span><span class="n">api</span><span class="o">/</span><span class="n">talk</span><span class="o">/</span><span class="n">profile</span> <span class="n">HTTP</span><span class="o">/</span><span class="mf">1.1</span>
<span class="n">Host</span><span class="p">:</span> <span class="n">kapi</span><span class="o">.</span><span class="n">kakao</span><span class="o">.</span><span class="n">com</span>
<span class="n">Authorization</span><span class="p">:</span> <span class="n">Bearer</span> <span class="p">{</span><span class="n">access_token</span><span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="json-----">3. 응답은 JSON 형태로 다음과 같은 정보를 포함한다.</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
 <span class="s">"nickName"</span><span class="p">:</span><span class="s">"홍길동"</span><span class="p">,</span>
 <span class="s">"profileImageURL"</span><span class="p">:</span><span class="s">"http://xxx.kakao.co.kr/.../aaa.jpg"</span><span class="p">,</span>
 <span class="s">"thumbnailURL"</span><span class="p">:</span><span class="s">"http://xxx.kakao.co.kr/.../bbb.jpg"</span><span class="p">,</span>
 <span class="s">"countryISO"</span><span class="p">:</span><span class="s">"KR"</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="response-code-example">Response Code Example</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
  <span class="s">"meta"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">"code"</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
    <span class="s">"response_time"</span><span class="p">:</span> <span class="p">{</span>
      <span class="s">"time"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s">"measure"</span><span class="p">:</span> <span class="s">"seconds"</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="s">"notifications"</span><span class="p">:</span> <span class="p">{},</span>
  <span class="s">"response"</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h5 id="error-code-example">Error Code Example</h5>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="p">{</span>
  <span class="s">"meta"</span><span class="p">:</span> <span class="p">{</span>
    <span class="s">"code"</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
    <span class="s">"error_detail"</span><span class="p">:</span> <span class="s">"The user has not authorized or the token is invalid."</span><span class="p">,</span>
    <span class="s">"error_type"</span><span class="p">:</span> <span class="s">"invalid_auth"</span><span class="p">,</span>
    <span class="s">"developer_friendly"</span><span class="p">:</span> <span class="s">"The user has not authorized or the token is invalid."</span><span class="p">,</span>
    <span class="s">"response_time"</span><span class="p">:</span> <span class="p">{</span>
      <span class="s">"time"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s">"measure"</span><span class="p">:</span> <span class="s">"seconds"</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>​</p>

<h2 id="section-5">참고자료</h2>

<ul>
  <li>API Platform Design : <a href="http://bcho.tistory.com/808">http://bcho.tistory.com/808</a></li>
  <li>Web API Design : <a href="https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf">https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf</a></li>
  <li>카카오 개발자센터 : <a href="https://developers.kakao.com">https://developers.kakao.com</a></li>
  <li>
    <p>네이버 개발자센터 : <a href="https://developers.naver.com">https://developers.naver.com</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>OAuth2에 대해 알아보자</title>
	  <link>//about-oauth2</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-05T19:18:00+09:00</pubDate>
	  <guid>//about-oauth2</guid>
	  <description><![CDATA[
	     <p>먼저 OAuth 인증을 이해하기 위해 필요한 몇 가지 개념들에 대해 알아보자. OAuth 인증을 진행할 때 해당 서비스 제공자는 ‘제 3자가 어떤 정보나 서비스에 사용자의 권한으로 접근하려 하는데 허용하겠느냐’라는 안내 메시지를 보여 주는 것이다.</p>

<p>​   ​</p>

<h3 id="section">인증과 허가</h3>

<ol>
  <li>Authentication : 인증</li>
  <li>
    <p>Authorization : 허가</p>

    <p>​   ​</p>
  </li>
</ol>

<p>일반 로그인은 사원이 63빌딩에 출입하는 것이라면, (사원증이 있어야 출입가능)</p>

<p>OAuth는 1층에서 방문증을 수령한 후 63빌딩에 출입하는 것이다. (방문증만 있어도 출입가능)</p>

<p>​   ​</p>

<h2 id="oauth-10-">OAuth 1.0의 특징</h2>

<p>기존의 다른 인증방식(OpenID)과 구분되는 특징은 크게 두 가지이다.</p>

<ol>
  <li>API 인증 시, 써드파티 어플리케이션에게 사용자의 비번을 노출하지 않고 인증할 수 있다는 점</li>
  <li>
    <p>인증(Authentication)과 API 권한(Authorization) 부여를 동시에 할 수 있다는 점</p>

    <p>​</p>
  </li>
</ol>

<h2 id="oauth-10--1">OAuth 1.0의 동작방식</h2>

<p>OAuth 1.0은 기본적으로 user / consumer / service provider가 있어야 한다.</p>

<p>OAuth 1.0 인증을 3-legged OAuth 라고도 하는데 결국 주체가 셋 이라는 말이다.</p>

<p><img src="assets/images/oauth1_triangle.png" alt="oauth1_triangle" /></p>

<p>우리의 서비스에서 트위터 로그인을 연동한다고 가정해보자. 사용자 입장에서는 아이디 / 비밀번호를 통해 가입하면 그 정보를 이용해서 무슨 짓을 할지 모르기 때문에 꺼려한다. OAuth 1.0은 우리의 서비스(Consumer)에게 인증토큰 (Access Token)만을 전달하고 서비스에서 인증토큰으로 트위터 API(Service Provider)를 사용할 수 있도록 해준다.</p>

<p>​</p>

<h3 id="outh-10-">Outh 1.0 프로세스</h3>

<ol>
  <li>사용자(User)가 트위터 로그인 요청</li>
  <li>사용자를 트위터(Service Provider) 로그인 화면으로 리다이렉트</li>
  <li>트위터 로그인 진행</li>
  <li>
    <p>서비스(Consumer)로 인증토큰(Access Token)이 전달</p>

    <p>​</p>
  </li>
</ol>

<h3 id="section-1">인증토큰의 장점</h3>

<ul>
  <li>사용자의 아이디 / 패스워드를 몰라도 토큰을 통해 허가 받은 API에 접근 가능</li>
  <li>필요한 API에만 제한적으로 접근할 수 있도록 권한 제어 가능</li>
  <li>저장되어 있는 인증토큰이 유출되더라도 트위터의 관리자 화면에서 인증토큰의 권한 취소 가능</li>
  <li>
    <p>사용자가 트위터(Service Provider)의 패스워드를 변경해도 인증토큰은 계속 유효</p>

    <p>​</p>
  </li>
</ul>

<h2 id="oauth-20-">OAuth 2.0의 개선사항</h2>

<p>일단 OAuth 2.0은 1.0과 호환되지 않으며 용어부터 많은 것이 다르다. 모바일에서의 사용성 문제나 서명과 같은 개발이 복잡하고 기능과 규모의 확장성 등을 지원하기 위해 만들어진 표준이다. 표준이 매우 크고 복잡해서 이름도 “OAuth 인증 프레임워크(OAuth 2.0 Authorization Framework)” 이다. <a href="http://tools.ietf.org/wg/oauth/">http://tools.ietf.org/wg/oauth/</a> 에서 확인 가능</p>

<p>​</p>

<h3 id="oauth-10--">OAuth 1.0에서 개선된 사항</h3>

<ol>
  <li>용어 변경
    <ul>
      <li>Resource Owner : 사용자</li>
      <li>Resource Server : REST API 서버</li>
      <li>Authorization Server : 인증서버 (API 서버와 같을 수도 있음)</li>
      <li>Client : 써드파티 어플리케이션 (서비스)</li>
    </ul>

    <p>​</p>
  </li>
  <li>간단하고 직관적
    <ul>
      <li>OAuth 1.0에서는 HTTPS가 필수</li>
      <li>Signature 없이 생성, 호출 가능</li>
      <li>URL 인코딩이 필요없음</li>
    </ul>

    <p>​</p>
  </li>
  <li>더 많은 인증 방법을 지원
    <ul>
      <li>이전에는 HMAC을 이용한 암호화 인증만 지원</li>
      <li>OAuth 2.0은 여러 인증 방식을 통해 웹 / 모바일 등 다양한 시나리오에 대응 가능</li>
      <li>Access Token의 Life-time을 지정하여 만료일 설정 가능</li>
    </ul>

    <p>​</p>
  </li>
  <li>대형 서비스로의 확장성 지원
    <ul>
      <li>커다란 서비스는 인증 서버를 분리하거나 다중화 할 수 있어야 함</li>
      <li>Authorization Server의 역할을 명확히 하여 이에 대한 고려가 되었음</li>
    </ul>

    <p>​</p>
  </li>
</ol>

<h2 id="oauth-20--">OAuth 2.0 사용 서비스</h2>

<p>2013년까지만 해도 1.0만 지원하거나 2.0으로 개선하는 인터넷 서비스 기업이 많았지만,</p>

<p>현재는 대부분 2.0만 지원한다고 봐도 무방하다. (1.0은 자체 로그인에만 사용하는 기업이 많음)</p>

<ul>
  <li>
    <p>Facebook, Instagram, Google, LinkedIn, Twitter…</p>

    <p>​</p>
  </li>
</ul>

<h2 id="section-2">참고하면 좋은 자료</h2>

<ul>
  <li>Naver D2 : <a href="http://d2.naver.com/helloworld/24942">http://d2.naver.com/helloworld/24942</a></li>
  <li>정리 잘 된 블로그 : <a href="http://earlybird.kr/1584">http://earlybird.kr/1584</a></li>
  <li>
    <p>조대협의 블로그 : <a href="http://bcho.tistory.com/942">http://bcho.tistory.com/942</a></p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>윈도우 10에서 bash를 통해 Jekyll 블로그 간단하게 설치하기</title>
	  <link>//windows-bash-jekyll</link>
	  <author>Swalloow</author>
	  <pubDate>2017-01-03T19:18:00+09:00</pubDate>
	  <guid>//windows-bash-jekyll</guid>
	  <description><![CDATA[
	     <p>기존에 Windows 환경에서 Jekyll 블로그를 설치하는 글을 살펴보던 중 환경변수와 루비에 스트레스 받아서, 새로 포스팅하기로 마음 먹었습니다. (2017년 1월 2일 기준)</p>

<p>​</p>

<h2 id="ruby-">윈도우 10에서 Ruby 설치</h2>

<ol>
  <li><code class="highlighter-rouge">프로그램 및 기능 &gt; Windows 기능 켜기/끄기 &gt; Linux용 Windows 하위 시스템</code> 체큰</li>
  <li>cmd 창에서 <code class="highlighter-rouge">bash</code> 를 입력, Windows Subsystem for Linux 환경실행</li>
</ol>

<p>처음 실행한다면, 아무것도 설치되지 않은 상태이기 때문에 초기 설정을 해주시면 좋습니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">sudo</span> <span class="o">-</span><span class="n">s</span>
<span class="err">$</span> <span class="n">apt</span> <span class="n">update</span>
<span class="err">$</span> <span class="n">apt</span> <span class="n">install</span> <span class="n">make</span> <span class="n">gcc</span></code></pre></figure>

<p>이제 루비를 설치해보겠습니다. 놀랍게도 윈도우 bash에서는 <code class="highlighter-rouge">apt install ruby</code> 를 통해 설치하려는 경우, 루비 1.9.3 버전만 설치됩니다 ! (rvm과 rbenv를 사용해봐도 동일) 하지만, Jekyll 에서 최소 2.0 이상의 버전을 요구하기 때문에 brightbox를 통해 최신 버전을 설치하였습니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">apt</span><span class="o">-</span><span class="n">add</span><span class="o">-</span><span class="n">repository</span> <span class="n">ppa</span><span class="p">:</span><span class="n">brightbox</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="n">ng</span>
<span class="err">$</span> <span class="n">apt</span> <span class="n">update</span>
<span class="err">$</span> <span class="n">apt</span> <span class="n">install</span> <span class="n">ruby2</span><span class="o">.</span><span class="mi">3</span> <span class="n">ruby2</span><span class="o">.</span><span class="mi">3</span><span class="o">-</span><span class="n">dev</span> <span class="n">ruby</span><span class="o">-</span><span class="n">switch</span></code></pre></figure>

<p>여기까지 설치되고 나면 뭔가 안심이 됩니다. 하지만 이제 시작에 불과합니다.</p>

<p>​</p>

<h2 id="jekyll-">Jekyll 설치하기</h2>

<p>이제 설치하려는 경로로 이동해서 jekyll을 설치할 차례입니다. 여기에서는 바탕화면에 설치해보도록 하겠습니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">jekyll</span>
<span class="err">$</span> <span class="n">cd</span> <span class="o">/</span><span class="n">mnt</span><span class="o">/</span><span class="n">c</span><span class="o">/</span><span class="n">Users</span><span class="o">/&lt;</span><span class="n">your</span> <span class="n">username</span><span class="o">&gt;/</span><span class="n">Desktop</span>
<span class="err">$</span> <span class="n">jekyll</span> <span class="n">new</span> <span class="n">myblog</span> <span class="o">&amp;&amp;</span> <span class="n">cd</span> <span class="n">myblog</span>
<span class="err">$</span> <span class="n">jekyll</span> <span class="n">serve</span> <span class="o">-</span><span class="n">w</span></code></pre></figure>

<p>속도를 측정해보면, Bash는 <code class="highlighter-rouge">0.329초</code>, PowerShell은 <code class="highlighter-rouge">0.364초</code> 로 Bash에서 실행시키는 것이 더 빠르다고 합니다.
여기까지가 아주 기본적인 형태의 jekyll 블로그 설치 과정입니다.</p>

<p>​</p>

<h2 id="jekyll--1">테마까지 한번에 적용하여 Jekyll 설치하기</h2>

<p>기본 설치를 끝내면 그냥 빈 화면만 나타나기 때문에 허전합니다. 그래서 이번에는 테마까지 한번에 적용하여 설치하는 방법을 알려드리겠습니다. (방금꺼는 <code class="highlighter-rouge">gem uninstall -all</code> 명령어를 통해 삭제하셔도 됩니다)</p>

<ol>
  <li>먼저, <code class="highlighter-rouge">&lt;사용자이름&gt;.github.io</code> 라는 이름의 Repository를 생성합니다.</li>
  <li>생성한 저장소를 로컬에 clone 하고 cd 명령어를 통해 위치로 이동합니다.</li>
  <li>
    <p>마음에 드는 Jekyll 테마를 다운로드 받아 로컬에 압축해제 합니다. <a href="http://jekyllthemes.org/">http://jekyllthemes.org/</a></p>

    <p>​</p>
  </li>
</ol>

<p>구조를 처음 보시면 복잡한데, 우리가 건드릴 부분은 <code class="highlighter-rouge">_config.yml</code> 과 <code class="highlighter-rouge">Gemfile</code> 입니다. Gemfile은 GitHub Pages에 필요한 라이브러리를 설치하도록 정의한 파일이라고 보시면 됩니다.
데스크탑과 노트북 또는 맥북을 사용해보신 분은 아시겠지만, GitHub Pages에서 의존성 문제가 아주 빈번하게 발생합니다.</p>

<ul>
  <li>
    <p>의존성을 가지는 라이브러리 참고 (<a href="https://pages.github.com/versions/">https://pages.github.com/versions/</a>)</p>

    <p>​</p>
  </li>
</ul>

<p>위의 링크처럼 각 라이브러리마다 버전 정보를 따로 관리해도 되지만, <code class="highlighter-rouge">gem 'github-pages'</code> 를 통해 관리하는 방법이 가장 간편합니다.
이를 통해 github-pages의 최신 의존성 정보를 간단하게 업데이트할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">vi</span> <span class="n">Gemfile</span>

<span class="n">source</span> <span class="s">'https://rubygems.org'</span>
<span class="n">gem</span> <span class="s">'github-pages'</span></code></pre></figure>

<p>​</p>

<p>이제 bundler를 설치할 차례입니다. bundler는 라이브러리 설치를 위한 패키지 매니저입니다.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="err">$</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
<span class="err">$</span> <span class="n">bundle</span> <span class="n">install</span>
<span class="err">$</span> <span class="n">bundle</span> <span class="n">update</span></code></pre></figure>

<p>이제 Gemfile에 있는 라이브러리를 설치하고 업데이트까지 완료했습니다.
의존성 정보를 확인하시려면 <code class="highlighter-rouge">github-pages versions</code> 명령어를 입력하시면 됩니다.</p>

<p>​</p>

<h4 id="jeykll-331---">1. jeykll 3.3.1 버전에서 오류 발생</h4>

<p>최근 <em>Windows+Bash Subsystem</em> 에서 powershell을 defalut cmd로 확장하는 과정에서 생겨난 버그</p>

<ul>
  <li>
    <p>(https://github.com/jekyll/jekyll/issues/5462 참조)</p>

    <p>​</p>
  </li>
</ul>

<p>해결방법은 다음과 같습니다. 첫번째 방법은 번거롭기 때문에 두번째 방법을 추천합니다.</p>

<ol>
  <li>
    <p>jeykll 3.3.1 버전을 삭제하고 3.2.1 버전으로 하향시키기</p>
  </li>
  <li>
    <p>build.rb에서 코드 수정하기</p>

    <p>​</p>
  </li>
</ol>

<p>build.rb의 위치를 찾는 방법</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">bundle</span> <span class="n">show</span> <span class="n">jekyll</span></code></pre></figure>

<p>그리고 <code class="highlighter-rouge">lib/jekyll/commands/build.rb</code>로 이동해서 다음과 같이 수정합니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">if</span> <span class="no">Utils</span><span class="o">::</span><span class="no">Platforms</span><span class="p">.</span><span class="nf">windows?</span> <span class="o">-&gt;</span> <span class="k">unless</span> <span class="no">Utils</span><span class="o">::</span><span class="no">Platforms</span><span class="p">.</span><span class="nf">windows?</span></code></pre></figure>

<p>​</p>

<h4 id="jekyll-serve--">2. jekyll serve에서 오류 발생</h4>

<p>실행 명령어 <code class="highlighter-rouge">jekyll serve</code> 하면 여기서 끝날줄 알았는데
또 오류 발생 (https://github.com/jekyll/jekyll/issues/5233 참조)
역시 마찬가지로 <em>Windows+Bash Subsystem</em> 버그라고 합니다..</p>

<p><code class="highlighter-rouge">jekyll serve --force_polling</code>  옵션을 통해 해결하실 수 있습니다.</p>

<p>​</p>

<h2 id="section">결론</h2>

<p>쓰다보니 간단하지 않은 것 같지만 제가 삽질했던 부분을 빠르게 건너뛴다면,
윈도우 사용자도 금방 설치할 수 있습니다 (Bash on Windows 만세 !)
다만, 정신건강을 위해 맥을 사용하는걸 추천합니다.</p>

<p>​</p>

<h4 id="section-1">참고하면 좋은 페이지</h4>

<ul>
  <li>GitHub Help : https://help.github.com/articles/configuring-jekyll/</li>
  <li>https://nolboo.kim/blog/2013/10/15/free-blog-with-github-jekyll/#configyml</li>
  <li>http://my2kong.net/2016/07/07/jekyll-blogging-theme/</li>
  <li>
    <p>Jekyll QuickStart : http://jekyllbootstrap.com/usage/jekyll-quick-start.html</p>

    <p>​</p>
  </li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
